/-
Copyright (c) 2020 Kexing Ying. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kexing Ying

! This file was ported from Lean 3 source module group_theory.subgroup.basic
! leanprover-community/mathlib commit a11f9106a169dd302a285019e5165f8ab32ff433
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Group.Conj
import Mathbin.Algebra.Module.Basic
import Mathbin.Algebra.Order.Group.InjSurj
import Mathbin.Data.Countable.Basic
import Mathbin.GroupTheory.Submonoid.Centralizer
import Mathbin.Logic.Encodable.Basic
import Mathbin.Order.Atoms
import Mathbin.Tactic.ApplyFun

/-!
# Subgroups

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines multiplicative and additive subgroups as an extension of submonoids, in a bundled
form (unbundled subgroups are in `deprecated/subgroups.lean`).

We prove subgroups of a group form a complete lattice, and results about images and preimages of
subgroups under group homomorphisms. The bundled subgroups use bundled monoid homomorphisms.

There are also theorems about the subgroups generated by an element or a subset of a group,
defined both inductively and as the infimum of the set of subgroups containing a given
element/subset.

Special thanks goes to Amelia Livingston and Yury Kudryashov for their help and inspiration.

## Main definitions

Notation used here:

- `G N` are `group`s

- `A` is an `add_group`

- `H K` are `subgroup`s of `G` or `add_subgroup`s of `A`

- `x` is an element of type `G` or type `A`

- `f g : N →* G` are group homomorphisms

- `s k` are sets of elements of type `G`

Definitions in the file:

* `subgroup G` : the type of subgroups of a group `G`

* `add_subgroup A` : the type of subgroups of an additive group `A`

* `complete_lattice (subgroup G)` : the subgroups of `G` form a complete lattice

* `subgroup.closure k` : the minimal subgroup that includes the set `k`

* `subgroup.subtype` : the natural group homomorphism from a subgroup of group `G` to `G`

* `subgroup.gi` : `closure` forms a Galois insertion with the coercion to set

* `subgroup.comap H f` : the preimage of a subgroup `H` along the group homomorphism `f` is also a
  subgroup

* `subgroup.map f H` : the image of a subgroup `H` along the group homomorphism `f` is also a
  subgroup

* `subgroup.prod H K` : the product of subgroups `H`, `K` of groups `G`, `N` respectively, `H × K`
  is a subgroup of `G × N`

* `monoid_hom.range f` : the range of the group homomorphism `f` is a subgroup

* `monoid_hom.ker f` : the kernel of a group homomorphism `f` is the subgroup of elements `x : G`
  such that `f x = 1`

* `monoid_hom.eq_locus f g` : given group homomorphisms `f`, `g`, the elements of `G` such that
  `f x = g x` form a subgroup of `G`

## Implementation notes

Subgroup inclusion is denoted `≤` rather than `⊆`, although `∈` is defined as
membership of a subgroup's underlying set.

## Tags
subgroup, subgroups
-/


open Function

variable {G G' : Type _} [Group G] [Group G']

variable {A : Type _} [AddGroup A]

section SubgroupClass

#print InvMemClass /-
/-- `inv_mem_class S G` states `S` is a type of subsets `s ⊆ G` closed under inverses. -/
class InvMemClass (S G : Type _) [Inv G] [SetLike S G] : Prop where
  inv_mem : ∀ {s : S} {x}, x ∈ s → x⁻¹ ∈ s
#align inv_mem_class InvMemClass
-/

export InvMemClass (inv_mem)

#print NegMemClass /-
/-- `neg_mem_class S G` states `S` is a type of subsets `s ⊆ G` closed under negation. -/
class NegMemClass (S G : Type _) [Neg G] [SetLike S G] : Prop where
  neg_mem : ∀ {s : S} {x}, x ∈ s → -x ∈ s
#align neg_mem_class NegMemClass
-/

export NegMemClass (neg_mem)

#print SubgroupClass /-
/-- `subgroup_class S G` states `S` is a type of subsets `s ⊆ G` that are subgroups of `G`. -/
class SubgroupClass (S G : Type _) [DivInvMonoid G] [SetLike S G] extends SubmonoidClass S G,
  InvMemClass S G : Prop
#align subgroup_class SubgroupClass
-/

#print AddSubgroupClass /-
/-- `add_subgroup_class S G` states `S` is a type of subsets `s ⊆ G` that are
additive subgroups of `G`. -/
class AddSubgroupClass (S G : Type _) [SubNegMonoid G] [SetLike S G] extends AddSubmonoidClass S G,
  NegMemClass S G : Prop
#align add_subgroup_class AddSubgroupClass
-/

attribute [to_additive] InvMemClass SubgroupClass

variable {M S : Type _} [DivInvMonoid M] [SetLike S M] [hSM : SubgroupClass S M] {H K : S}

include hSM

/- warning: div_mem -> div_mem is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {S : Type.{u2}} [_inst_4 : DivInvMonoid.{u1} M] [_inst_5 : SetLike.{u2, u1} S M] [hSM : SubgroupClass.{u2, u1} S M _inst_4 _inst_5] {H : S} {x : M} {y : M}, (Membership.Mem.{u1, u2} M S (SetLike.hasMem.{u2, u1} S M _inst_5) x H) -> (Membership.Mem.{u1, u2} M S (SetLike.hasMem.{u2, u1} S M _inst_5) y H) -> (Membership.Mem.{u1, u2} M S (SetLike.hasMem.{u2, u1} S M _inst_5) (HDiv.hDiv.{u1, u1, u1} M M M (instHDiv.{u1} M (DivInvMonoid.toHasDiv.{u1} M _inst_4)) x y) H)
but is expected to have type
  forall {M : Type.{u2}} {S : Type.{u1}} [_inst_4 : DivInvMonoid.{u2} M] [_inst_5 : SetLike.{u1, u2} S M] [hSM : SubgroupClass.{u1, u2} S M _inst_4 _inst_5] {H : S} {x : M} {y : M}, (Membership.mem.{u2, u1} M S (SetLike.instMembership.{u1, u2} S M _inst_5) x H) -> (Membership.mem.{u2, u1} M S (SetLike.instMembership.{u1, u2} S M _inst_5) y H) -> (Membership.mem.{u2, u1} M S (SetLike.instMembership.{u1, u2} S M _inst_5) (HDiv.hDiv.{u2, u2, u2} M M M (instHDiv.{u2} M (DivInvMonoid.toDiv.{u2} M _inst_4)) x y) H)
Case conversion may be inaccurate. Consider using '#align div_mem div_memₓ'. -/
/-- A subgroup is closed under division. -/
@[to_additive "An additive subgroup is closed under subtraction."]
theorem div_mem {x y : M} (hx : x ∈ H) (hy : y ∈ H) : x / y ∈ H := by
  rw [div_eq_mul_inv] <;> exact mul_mem hx (inv_mem hy)
#align div_mem div_mem
#align sub_mem sub_mem

/- warning: zpow_mem -> zpow_mem is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {S : Type.{u2}} [_inst_4 : DivInvMonoid.{u1} M] [_inst_5 : SetLike.{u2, u1} S M] [hSM : SubgroupClass.{u2, u1} S M _inst_4 _inst_5] {K : S} {x : M}, (Membership.Mem.{u1, u2} M S (SetLike.hasMem.{u2, u1} S M _inst_5) x K) -> (forall (n : Int), Membership.Mem.{u1, u2} M S (SetLike.hasMem.{u2, u1} S M _inst_5) (HPow.hPow.{u1, 0, u1} M Int M (instHPow.{u1, 0} M Int (DivInvMonoid.Pow.{u1} M _inst_4)) x n) K)
but is expected to have type
  forall {M : Type.{u2}} {S : Type.{u1}} [_inst_4 : DivInvMonoid.{u2} M] [_inst_5 : SetLike.{u1, u2} S M] [hSM : SubgroupClass.{u1, u2} S M _inst_4 _inst_5] {K : S} {x : M}, (Membership.mem.{u2, u1} M S (SetLike.instMembership.{u1, u2} S M _inst_5) x K) -> (forall (n : Int), Membership.mem.{u2, u1} M S (SetLike.instMembership.{u1, u2} S M _inst_5) (HPow.hPow.{u2, 0, u2} M Int M (instHPow.{u2, 0} M Int (DivInvMonoid.Pow.{u2} M _inst_4)) x n) K)
Case conversion may be inaccurate. Consider using '#align zpow_mem zpow_memₓ'. -/
@[to_additive]
theorem zpow_mem {x : M} (hx : x ∈ K) : ∀ n : ℤ, x ^ n ∈ K
  | (n : ℕ) => by
    rw [zpow_ofNat]
    exact pow_mem hx n
  | -[n+1] => by
    rw [zpow_negSucc]
    exact inv_mem (pow_mem hx n.succ)
#align zpow_mem zpow_mem
#align zsmul_mem zsmul_mem

omit hSM

variable [SetLike S G] [hSG : SubgroupClass S G]

include hSG

/- warning: inv_mem_iff -> inv_mem_iff is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Type.{u2}} {H : S} [_inst_6 : SetLike.{u2, u1} S G] [hSG : SubgroupClass.{u2, u1} S G (Group.toDivInvMonoid.{u1} G _inst_1) _inst_6] {x : G}, Iff (Membership.Mem.{u1, u2} G S (SetLike.hasMem.{u2, u1} S G _inst_6) (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) x) H) (Membership.Mem.{u1, u2} G S (SetLike.hasMem.{u2, u1} S G _inst_6) x H)
but is expected to have type
  forall {G : Type.{u2}} {_inst_1 : Type.{u1}} [S : InvolutiveInv.{u1} _inst_1] {H : SetLike.{u2, u1} G _inst_1} [_inst_6 : InvMemClass.{u2, u1} G _inst_1 (InvolutiveInv.toInv.{u1} _inst_1 S) H] {hSG : G} {x : _inst_1}, Iff (Membership.mem.{u1, u2} _inst_1 G (SetLike.instMembership.{u2, u1} G _inst_1 H) (Inv.inv.{u1} _inst_1 (InvolutiveInv.toInv.{u1} _inst_1 S) x) hSG) (Membership.mem.{u1, u2} _inst_1 G (SetLike.instMembership.{u2, u1} G _inst_1 H) x hSG)
Case conversion may be inaccurate. Consider using '#align inv_mem_iff inv_mem_iffₓ'. -/
@[simp, to_additive]
theorem inv_mem_iff {x : G} : x⁻¹ ∈ H ↔ x ∈ H :=
  ⟨fun h => inv_inv x ▸ inv_mem h, inv_mem⟩
#align inv_mem_iff inv_mem_iff
#align neg_mem_iff neg_mem_iff

/- warning: div_mem_comm_iff -> div_mem_comm_iff is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Type.{u2}} {H : S} [_inst_6 : SetLike.{u2, u1} S G] [hSG : SubgroupClass.{u2, u1} S G (Group.toDivInvMonoid.{u1} G _inst_1) _inst_6] {a : G} {b : G}, Iff (Membership.Mem.{u1, u2} G S (SetLike.hasMem.{u2, u1} S G _inst_6) (HDiv.hDiv.{u1, u1, u1} G G G (instHDiv.{u1} G (DivInvMonoid.toHasDiv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a b) H) (Membership.Mem.{u1, u2} G S (SetLike.hasMem.{u2, u1} S G _inst_6) (HDiv.hDiv.{u1, u1, u1} G G G (instHDiv.{u1} G (DivInvMonoid.toHasDiv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) b a) H)
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {S : Type.{u1}} {H : S} [_inst_6 : SetLike.{u1, u2} S G] [hSG : SubgroupClass.{u1, u2} S G (Group.toDivInvMonoid.{u2} G _inst_1) _inst_6] {a : G} {b : G}, Iff (Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) (HDiv.hDiv.{u2, u2, u2} G G G (instHDiv.{u2} G (DivInvMonoid.toDiv.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) a b) H) (Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) (HDiv.hDiv.{u2, u2, u2} G G G (instHDiv.{u2} G (DivInvMonoid.toDiv.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) b a) H)
Case conversion may be inaccurate. Consider using '#align div_mem_comm_iff div_mem_comm_iffₓ'. -/
@[to_additive]
theorem div_mem_comm_iff {a b : G} : a / b ∈ H ↔ b / a ∈ H := by
  rw [← inv_mem_iff, div_eq_mul_inv, div_eq_mul_inv, mul_inv_rev, inv_inv]
#align div_mem_comm_iff div_mem_comm_iff
#align sub_mem_comm_iff sub_mem_comm_iff

/- warning: exists_inv_mem_iff_exists_mem -> exists_inv_mem_iff_exists_mem is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Type.{u2}} {H : S} [_inst_6 : SetLike.{u2, u1} S G] [hSG : SubgroupClass.{u2, u1} S G (Group.toDivInvMonoid.{u1} G _inst_1) _inst_6] {P : G -> Prop}, Iff (Exists.{succ u1} G (fun (x : G) => And (Membership.Mem.{u1, u2} G S (SetLike.hasMem.{u2, u1} S G _inst_6) x H) (P (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) x)))) (Exists.{succ u1} G (fun (x : G) => Exists.{0} (Membership.Mem.{u1, u2} G S (SetLike.hasMem.{u2, u1} S G _inst_6) x H) (fun (H : Membership.Mem.{u1, u2} G S (SetLike.hasMem.{u2, u1} S G _inst_6) x H) => P x)))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {S : Type.{u1}} {H : S} [_inst_6 : SetLike.{u1, u2} S G] [hSG : SubgroupClass.{u1, u2} S G (Group.toDivInvMonoid.{u2} G _inst_1) _inst_6] {P : G -> Prop}, Iff (Exists.{succ u2} G (fun (x : G) => And (Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H) (P (Inv.inv.{u2} G (InvOneClass.toInv.{u2} G (DivInvOneMonoid.toInvOneClass.{u2} G (DivisionMonoid.toDivInvOneMonoid.{u2} G (Group.toDivisionMonoid.{u2} G _inst_1)))) x)))) (Exists.{succ u2} G (fun (x : G) => And (Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H) (P x)))
Case conversion may be inaccurate. Consider using '#align exists_inv_mem_iff_exists_mem exists_inv_mem_iff_exists_memₓ'. -/
@[simp, to_additive]
theorem exists_inv_mem_iff_exists_mem {P : G → Prop} : (∃ x : G, x ∈ H ∧ P x⁻¹) ↔ ∃ x ∈ H, P x := by
  constructor <;>
    · rintro ⟨x, x_in, hx⟩
      exact ⟨x⁻¹, inv_mem x_in, by simp [hx]⟩
#align exists_inv_mem_iff_exists_mem exists_inv_mem_iff_exists_mem
#align exists_neg_mem_iff_exists_mem exists_neg_mem_iff_exists_mem

/- warning: mul_mem_cancel_right -> mul_mem_cancel_right is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Type.{u2}} {H : S} [_inst_6 : SetLike.{u2, u1} S G] [hSG : SubgroupClass.{u2, u1} S G (Group.toDivInvMonoid.{u1} G _inst_1) _inst_6] {x : G} {y : G}, (Membership.Mem.{u1, u2} G S (SetLike.hasMem.{u2, u1} S G _inst_6) x H) -> (Iff (Membership.Mem.{u1, u2} G S (SetLike.hasMem.{u2, u1} S G _inst_6) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) y x) H) (Membership.Mem.{u1, u2} G S (SetLike.hasMem.{u2, u1} S G _inst_6) y H))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {S : Type.{u1}} {H : S} [_inst_6 : SetLike.{u1, u2} S G] [hSG : SubgroupClass.{u1, u2} S G (Group.toDivInvMonoid.{u2} G _inst_1) _inst_6] {x : G} {y : G}, (Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H) -> (Iff (Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) (HMul.hMul.{u2, u2, u2} G G G (instHMul.{u2} G (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) y x) H) (Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) y H))
Case conversion may be inaccurate. Consider using '#align mul_mem_cancel_right mul_mem_cancel_rightₓ'. -/
@[to_additive]
theorem mul_mem_cancel_right {x y : G} (h : x ∈ H) : y * x ∈ H ↔ y ∈ H :=
  ⟨fun hba => by simpa using mul_mem hba (inv_mem h), fun hb => mul_mem hb h⟩
#align mul_mem_cancel_right mul_mem_cancel_right
#align add_mem_cancel_right add_mem_cancel_right

/- warning: mul_mem_cancel_left -> mul_mem_cancel_left is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Type.{u2}} {H : S} [_inst_6 : SetLike.{u2, u1} S G] [hSG : SubgroupClass.{u2, u1} S G (Group.toDivInvMonoid.{u1} G _inst_1) _inst_6] {x : G} {y : G}, (Membership.Mem.{u1, u2} G S (SetLike.hasMem.{u2, u1} S G _inst_6) x H) -> (Iff (Membership.Mem.{u1, u2} G S (SetLike.hasMem.{u2, u1} S G _inst_6) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x y) H) (Membership.Mem.{u1, u2} G S (SetLike.hasMem.{u2, u1} S G _inst_6) y H))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {S : Type.{u1}} {H : S} [_inst_6 : SetLike.{u1, u2} S G] [hSG : SubgroupClass.{u1, u2} S G (Group.toDivInvMonoid.{u2} G _inst_1) _inst_6] {x : G} {y : G}, (Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H) -> (Iff (Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) (HMul.hMul.{u2, u2, u2} G G G (instHMul.{u2} G (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) x y) H) (Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) y H))
Case conversion may be inaccurate. Consider using '#align mul_mem_cancel_left mul_mem_cancel_leftₓ'. -/
@[to_additive]
theorem mul_mem_cancel_left {x y : G} (h : x ∈ H) : x * y ∈ H ↔ y ∈ H :=
  ⟨fun hab => by simpa using mul_mem (inv_mem h) hab, mul_mem h⟩
#align mul_mem_cancel_left mul_mem_cancel_left
#align add_mem_cancel_left add_mem_cancel_left

namespace SubgroupClass

omit hSG

include hSM

#print SubgroupClass.inv /-
/-- A subgroup of a group inherits an inverse. -/
@[to_additive "An additive subgroup of a `add_group` inherits an inverse."]
instance inv : Inv H :=
  ⟨fun a => ⟨a⁻¹, inv_mem a.2⟩⟩
#align subgroup_class.has_inv SubgroupClass.inv
#align add_subgroup_class.has_neg AddSubgroupClass.neg
-/

#print SubgroupClass.div /-
/-- A subgroup of a group inherits a division -/
@[to_additive "An additive subgroup of an `add_group` inherits a subtraction."]
instance div : Div H :=
  ⟨fun a b => ⟨a / b, div_mem a.2 b.2⟩⟩
#align subgroup_class.has_div SubgroupClass.div
#align add_subgroup_class.has_sub AddSubgroupClass.sub
-/

omit hSM

#print AddSubgroupClass.zsmul /-
/-- An additive subgroup of an `add_group` inherits an integer scaling. -/
instance AddSubgroupClass.zsmul {M S} [SubNegMonoid M] [SetLike S M] [AddSubgroupClass S M]
    {H : S} : SMul ℤ H :=
  ⟨fun n a => ⟨n • a, zsmul_mem a.2 n⟩⟩
#align add_subgroup_class.has_zsmul AddSubgroupClass.zsmul
-/

include hSM

#print SubgroupClass.zpow /-
/-- A subgroup of a group inherits an integer power. -/
@[to_additive]
instance zpow : Pow H ℤ :=
  ⟨fun a n => ⟨a ^ n, zpow_mem a.2 n⟩⟩
#align subgroup_class.has_zpow SubgroupClass.zpow
#align add_subgroup_class.has_zsmul AddSubgroupClass.zsmul
-/

/- warning: subgroup_class.coe_inv -> SubgroupClass.coe_inv is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {S : Type.{u2}} [_inst_4 : DivInvMonoid.{u1} M] [_inst_5 : SetLike.{u2, u1} S M] [hSM : SubgroupClass.{u2, u1} S M _inst_4 _inst_5] {H : S} (x : coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S M _inst_5) H), Eq.{succ u1} M ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S M _inst_5) H) M (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S M _inst_5) H) M (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S M _inst_5) H) M (coeBase.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S M _inst_5) H) M (coeSubtype.{succ u1} M (fun (x : M) => Membership.Mem.{u1, u2} M S (SetLike.hasMem.{u2, u1} S M _inst_5) x H))))) (Inv.inv.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S M _inst_5) H) (SubgroupClass.inv.{u1, u2} M S _inst_4 _inst_5 hSM H) x)) (Inv.inv.{u1} M (DivInvMonoid.toHasInv.{u1} M _inst_4) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S M _inst_5) H) M (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S M _inst_5) H) M (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S M _inst_5) H) M (coeBase.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S M _inst_5) H) M (coeSubtype.{succ u1} M (fun (x : M) => Membership.Mem.{u1, u2} M S (SetLike.hasMem.{u2, u1} S M _inst_5) x H))))) x))
but is expected to have type
  forall {M : Type.{u2}} [S : Group.{u2} M] {_inst_4 : Type.{u1}} {_inst_5 : _inst_4} [hSM : SetLike.{u1, u2} _inst_4 M] [H : SubgroupClass.{u1, u2} _inst_4 M (Group.toDivInvMonoid.{u2} M S) hSM] (x : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M _inst_4 (SetLike.instMembership.{u1, u2} _inst_4 M hSM) x _inst_5)), Eq.{succ u2} M (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M _inst_4 (SetLike.instMembership.{u1, u2} _inst_4 M hSM) x _inst_5) (Inv.inv.{u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M _inst_4 (SetLike.instMembership.{u1, u2} _inst_4 M hSM) x _inst_5)) (SubgroupClass.inv.{u2, u1} M _inst_4 (Group.toDivInvMonoid.{u2} M S) hSM H _inst_5) x)) (Inv.inv.{u2} M (InvOneClass.toInv.{u2} M (DivInvOneMonoid.toInvOneClass.{u2} M (DivisionMonoid.toDivInvOneMonoid.{u2} M (Group.toDivisionMonoid.{u2} M S)))) (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M _inst_4 (SetLike.instMembership.{u1, u2} _inst_4 M hSM) x _inst_5) x))
Case conversion may be inaccurate. Consider using '#align subgroup_class.coe_inv SubgroupClass.coe_invₓ'. -/
@[simp, norm_cast, to_additive]
theorem coe_inv (x : H) : ↑(x⁻¹ : H) = (x⁻¹ : M) :=
  rfl
#align subgroup_class.coe_inv SubgroupClass.coe_inv
#align add_subgroup_class.coe_neg AddSubgroupClass.coe_neg

/- warning: subgroup_class.coe_div -> SubgroupClass.coe_div is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {S : Type.{u2}} [_inst_4 : DivInvMonoid.{u1} M] [_inst_5 : SetLike.{u2, u1} S M] [hSM : SubgroupClass.{u2, u1} S M _inst_4 _inst_5] {H : S} (x : coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S M _inst_5) H) (y : coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S M _inst_5) H), Eq.{succ u1} M ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S M _inst_5) H) M (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S M _inst_5) H) M (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S M _inst_5) H) M (coeBase.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S M _inst_5) H) M (coeSubtype.{succ u1} M (fun (x : M) => Membership.Mem.{u1, u2} M S (SetLike.hasMem.{u2, u1} S M _inst_5) x H))))) (HDiv.hDiv.{u1, u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S M _inst_5) H) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S M _inst_5) H) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S M _inst_5) H) (instHDiv.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S M _inst_5) H) (SubgroupClass.div.{u1, u2} M S _inst_4 _inst_5 hSM H)) x y)) (HDiv.hDiv.{u1, u1, u1} M M M (instHDiv.{u1} M (DivInvMonoid.toHasDiv.{u1} M _inst_4)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S M _inst_5) H) M (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S M _inst_5) H) M (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S M _inst_5) H) M (coeBase.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S M _inst_5) H) M (coeSubtype.{succ u1} M (fun (x : M) => Membership.Mem.{u1, u2} M S (SetLike.hasMem.{u2, u1} S M _inst_5) x H))))) x) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S M _inst_5) H) M (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S M _inst_5) H) M (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S M _inst_5) H) M (coeBase.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S M _inst_5) H) M (coeSubtype.{succ u1} M (fun (x : M) => Membership.Mem.{u1, u2} M S (SetLike.hasMem.{u2, u1} S M _inst_5) x H))))) y))
but is expected to have type
  forall {M : Type.{u2}} [S : Group.{u2} M] {_inst_4 : Type.{u1}} {_inst_5 : _inst_4} [hSM : SetLike.{u1, u2} _inst_4 M] [H : SubgroupClass.{u1, u2} _inst_4 M (Group.toDivInvMonoid.{u2} M S) hSM] (x : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M _inst_4 (SetLike.instMembership.{u1, u2} _inst_4 M hSM) x _inst_5)) (y : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M _inst_4 (SetLike.instMembership.{u1, u2} _inst_4 M hSM) x _inst_5)), Eq.{succ u2} M (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M _inst_4 (SetLike.instMembership.{u1, u2} _inst_4 M hSM) x _inst_5) (HDiv.hDiv.{u2, u2, u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M _inst_4 (SetLike.instMembership.{u1, u2} _inst_4 M hSM) x _inst_5)) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M _inst_4 (SetLike.instMembership.{u1, u2} _inst_4 M hSM) x _inst_5)) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M _inst_4 (SetLike.instMembership.{u1, u2} _inst_4 M hSM) x _inst_5)) (instHDiv.{u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M _inst_4 (SetLike.instMembership.{u1, u2} _inst_4 M hSM) x _inst_5)) (SubgroupClass.div.{u2, u1} M _inst_4 (Group.toDivInvMonoid.{u2} M S) hSM H _inst_5)) x y)) (HDiv.hDiv.{u2, u2, u2} M M M (instHDiv.{u2} M (DivInvMonoid.toDiv.{u2} M (Group.toDivInvMonoid.{u2} M S))) (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M _inst_4 (SetLike.instMembership.{u1, u2} _inst_4 M hSM) x _inst_5) x) (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M _inst_4 (SetLike.instMembership.{u1, u2} _inst_4 M hSM) x _inst_5) y))
Case conversion may be inaccurate. Consider using '#align subgroup_class.coe_div SubgroupClass.coe_divₓ'. -/
@[simp, norm_cast, to_additive]
theorem coe_div (x y : H) : (↑(x / y) : M) = ↑x / ↑y :=
  rfl
#align subgroup_class.coe_div SubgroupClass.coe_div
#align add_subgroup_class.coe_sub AddSubgroupClass.coe_sub

omit hSM

variable (H)

include hSG

#print SubgroupClass.toGroup /-
-- Prefer subclasses of `group` over subclasses of `subgroup_class`.
/-- A subgroup of a group inherits a group structure. -/
@[to_additive "An additive subgroup of an `add_group` inherits an `add_group` structure."]
instance (priority := 75) toGroup : Group H :=
  Subtype.coe_injective.Group _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)
    (fun _ _ => rfl) fun _ _ => rfl
#align subgroup_class.to_group SubgroupClass.toGroup
#align add_subgroup_class.to_add_group AddSubgroupClass.toAddGroup
-/

omit hSG

#print SubgroupClass.toCommGroup /-
-- Prefer subclasses of `comm_group` over subclasses of `subgroup_class`.
/-- A subgroup of a `comm_group` is a `comm_group`. -/
@[to_additive "An additive subgroup of an `add_comm_group` is an `add_comm_group`."]
instance (priority := 75) toCommGroup {G : Type _} [CommGroup G] [SetLike S G] [SubgroupClass S G] :
    CommGroup H :=
  Subtype.coe_injective.CommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)
    (fun _ _ => rfl) fun _ _ => rfl
#align subgroup_class.to_comm_group SubgroupClass.toCommGroup
#align add_subgroup_class.to_add_comm_group AddSubgroupClass.toAddCommGroup
-/

#print SubgroupClass.toOrderedCommGroup /-
-- Prefer subclasses of `group` over subclasses of `subgroup_class`.
/-- A subgroup of an `ordered_comm_group` is an `ordered_comm_group`. -/
@[to_additive "An additive subgroup of an `add_ordered_comm_group` is an `add_ordered_comm_group`."]
instance (priority := 75) toOrderedCommGroup {G : Type _} [OrderedCommGroup G] [SetLike S G]
    [SubgroupClass S G] : OrderedCommGroup H :=
  Subtype.coe_injective.OrderedCommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)
    (fun _ _ => rfl) fun _ _ => rfl
#align subgroup_class.to_ordered_comm_group SubgroupClass.toOrderedCommGroup
#align add_subgroup_class.to_ordered_add_comm_group AddSubgroupClass.toOrderedAddCommGroup
-/

#print SubgroupClass.toLinearOrderedCommGroup /-
-- Prefer subclasses of `group` over subclasses of `subgroup_class`.
/-- A subgroup of a `linear_ordered_comm_group` is a `linear_ordered_comm_group`. -/
@[to_additive
      "An additive subgroup of a `linear_ordered_add_comm_group` is a\n  `linear_ordered_add_comm_group`."]
instance (priority := 75) toLinearOrderedCommGroup {G : Type _} [LinearOrderedCommGroup G]
    [SetLike S G] [SubgroupClass S G] : LinearOrderedCommGroup H :=
  Subtype.coe_injective.LinearOrderedCommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl)
    (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) fun _ _ => rfl
#align subgroup_class.to_linear_ordered_comm_group SubgroupClass.toLinearOrderedCommGroup
#align add_subgroup_class.to_linear_ordered_add_comm_group AddSubgroupClass.toLinearOrderedAddCommGroup
-/

include hSG

#print SubgroupClass.subtype /-
/-- The natural group hom from a subgroup of group `G` to `G`. -/
@[to_additive "The natural group hom from an additive subgroup of `add_group` `G` to `G`."]
def subtype : H →* G :=
  ⟨coe, rfl, fun _ _ => rfl⟩
#align subgroup_class.subtype SubgroupClass.subtype
#align add_subgroup_class.subtype AddSubgroupClass.subtype
-/

/- warning: subgroup_class.coe_subtype -> SubgroupClass.coeSubtype is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Type.{u2}} (H : S) [_inst_6 : SetLike.{u2, u1} S G] [hSG : SubgroupClass.{u2, u1} S G (Group.toDivInvMonoid.{u1} G _inst_1) _inst_6], Eq.{succ u1} ((fun (_x : MonoidHom.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) -> G) (SubgroupClass.subtype.{u1, u2} G _inst_1 S H _inst_6 hSG)) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) -> G) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (SubgroupClass.subtype.{u1, u2} G _inst_1 S H _inst_6 hSG)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) G (coeBase.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u2} G S (SetLike.hasMem.{u2, u1} S G _inst_6) x H))))))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {S : Type.{u1}} (H : S) [_inst_6 : SetLike.{u1, u2} S G] [hSG : SubgroupClass.{u1, u2} S G (Group.toDivInvMonoid.{u2} G _inst_1) _inst_6], Eq.{succ u2} (forall (a : Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) => G) a) (FunLike.coe.{succ u2, succ u2, succ u2} (MonoidHom.{u2, u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) G (Monoid.toMulOneClass.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Group.toDivInvMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (SubgroupClass.toGroup.{u2, u1} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (fun (_x : Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) => G) _x) (MulHomClass.toFunLike.{u2, u2, u2} (MonoidHom.{u2, u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) G (Monoid.toMulOneClass.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Group.toDivInvMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (SubgroupClass.toGroup.{u2, u1} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) G (MulOneClass.toMul.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Monoid.toMulOneClass.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Group.toDivInvMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (SubgroupClass.toGroup.{u2, u1} G _inst_1 S H _inst_6 hSG))))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MonoidHomClass.toMulHomClass.{u2, u2, u2} (MonoidHom.{u2, u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) G (Monoid.toMulOneClass.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Group.toDivInvMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (SubgroupClass.toGroup.{u2, u1} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) G (Monoid.toMulOneClass.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Group.toDivInvMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (SubgroupClass.toGroup.{u2, u1} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (MonoidHom.monoidHomClass.{u2, u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) G (Monoid.toMulOneClass.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Group.toDivInvMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (SubgroupClass.toGroup.{u2, u1} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))) (SubgroupClass.subtype.{u2, u1} G _inst_1 S H _inst_6 hSG)) (Subtype.val.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Set.{u2} G) (Set.instMembershipSet.{u2} G) x (SetLike.coe.{u1, u2} S G _inst_6 H)))
Case conversion may be inaccurate. Consider using '#align subgroup_class.coe_subtype SubgroupClass.coeSubtypeₓ'. -/
@[simp, to_additive]
theorem coeSubtype : (subtype H : H → G) = coe :=
  rfl
#align subgroup_class.coe_subtype SubgroupClass.coeSubtype
#align add_subgroup_class.coe_subtype AddSubgroupClass.coeSubtype

variable {H}

/- warning: subgroup_class.coe_pow -> SubgroupClass.coe_pow is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Type.{u2}} {H : S} [_inst_6 : SetLike.{u2, u1} S G] [hSG : SubgroupClass.{u2, u1} S G (Group.toDivInvMonoid.{u1} G _inst_1) _inst_6] (x : coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (n : Nat), Eq.{succ u1} G ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) G (coeBase.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u2} G S (SetLike.hasMem.{u2, u1} S G _inst_6) x H))))) (HPow.hPow.{u1, 0, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) Nat (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (instHPow.{u1, 0} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) Nat (SubmonoidClass.nPow.{u1, u2} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) S _inst_6 (SubgroupClass.to_submonoidClass.{u2, u1} S G (Group.toDivInvMonoid.{u1} G _inst_1) _inst_6 hSG) H)) x n)) (HPow.hPow.{u1, 0, u1} G Nat G (instHPow.{u1, 0} G Nat (Monoid.Pow.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) G (coeBase.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u2} G S (SetLike.hasMem.{u2, u1} S G _inst_6) x H))))) x) n)
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {S : Type.{u1}} {H : S} [_inst_6 : SetLike.{u1, u2} S G] [hSG : SubgroupClass.{u1, u2} S G (Group.toDivInvMonoid.{u2} G _inst_1) _inst_6] (x : Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (n : Nat), Eq.{succ u2} G (Subtype.val.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Set.{u2} G) (Set.instMembershipSet.{u2} G) x (SetLike.coe.{u1, u2} S G _inst_6 H)) (HPow.hPow.{u2, 0, u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) Nat (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (instHPow.{u2, 0} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) Nat (SubmonoidClass.nPow.{u2, u1} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)) S _inst_6 (SubgroupClass.toSubmonoidClass.{u1, u2} S G (Group.toDivInvMonoid.{u2} G _inst_1) _inst_6 hSG) H)) x n)) (HPow.hPow.{u2, 0, u2} G Nat G (instHPow.{u2, 0} G Nat (Monoid.Pow.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Subtype.val.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Set.{u2} G) (Set.instMembershipSet.{u2} G) x (SetLike.coe.{u1, u2} S G _inst_6 H)) x) n)
Case conversion may be inaccurate. Consider using '#align subgroup_class.coe_pow SubgroupClass.coe_powₓ'. -/
@[simp, norm_cast, to_additive coe_smul]
theorem coe_pow (x : H) (n : ℕ) : ((x ^ n : H) : G) = x ^ n :=
  (subtype H : H →* G).map_pow _ _
#align subgroup_class.coe_pow SubgroupClass.coe_pow
#align add_subgroup_class.coe_smul AddSubgroupClass.coe_nsmul

/- warning: subgroup_class.coe_zpow -> SubgroupClass.coe_zpow is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Type.{u2}} {H : S} [_inst_6 : SetLike.{u2, u1} S G] [hSG : SubgroupClass.{u2, u1} S G (Group.toDivInvMonoid.{u1} G _inst_1) _inst_6] (x : coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (n : Int), Eq.{succ u1} G ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) G (coeBase.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u2} G S (SetLike.hasMem.{u2, u1} S G _inst_6) x H))))) (HPow.hPow.{u1, 0, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) Int (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (instHPow.{u1, 0} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) Int (SubgroupClass.zpow.{u1, u2} G S (Group.toDivInvMonoid.{u1} G _inst_1) _inst_6 hSG H)) x n)) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) G (coeBase.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u2} G S (SetLike.hasMem.{u2, u1} S G _inst_6) x H))))) x) n)
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {S : Type.{u1}} {H : S} [_inst_6 : SetLike.{u1, u2} S G] [hSG : SubgroupClass.{u1, u2} S G (Group.toDivInvMonoid.{u2} G _inst_1) _inst_6] (x : Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (n : Int), Eq.{succ u2} G (Subtype.val.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Set.{u2} G) (Set.instMembershipSet.{u2} G) x (SetLike.coe.{u1, u2} S G _inst_6 H)) (HPow.hPow.{u2, 0, u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) Int (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (instHPow.{u2, 0} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) Int (SubgroupClass.zpow.{u2, u1} G S (Group.toDivInvMonoid.{u2} G _inst_1) _inst_6 hSG H)) x n)) (HPow.hPow.{u2, 0, u2} G Int G (instHPow.{u2, 0} G Int (DivInvMonoid.Pow.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Subtype.val.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Set.{u2} G) (Set.instMembershipSet.{u2} G) x (SetLike.coe.{u1, u2} S G _inst_6 H)) x) n)
Case conversion may be inaccurate. Consider using '#align subgroup_class.coe_zpow SubgroupClass.coe_zpowₓ'. -/
@[simp, norm_cast, to_additive]
theorem coe_zpow (x : H) (n : ℤ) : ((x ^ n : H) : G) = x ^ n :=
  (subtype H : H →* G).map_zpow _ _
#align subgroup_class.coe_zpow SubgroupClass.coe_zpow
#align add_subgroup_class.coe_zsmul AddSubgroupClass.coe_zsmul

/- warning: subgroup_class.inclusion -> SubgroupClass.inclusion is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Type.{u2}} [_inst_6 : SetLike.{u2, u1} S G] [hSG : SubgroupClass.{u2, u1} S G (Group.toDivInvMonoid.{u1} G _inst_1) _inst_6] {H : S} {K : S}, (LE.le.{u2} S (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (SetLike.partialOrder.{u2, u1} S G _inst_6))) H K) -> (MonoidHom.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG)))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Type.{u2}} [_inst_6 : SetLike.{u2, u1} S G] [hSG : SubgroupClass.{u2, u1} S G (Group.toDivInvMonoid.{u1} G _inst_1) _inst_6] {H : S} {K : S}, (LE.le.{u2} S (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (SetLike.instPartialOrder.{u2, u1} S G _inst_6))) H K) -> (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG)))))
Case conversion may be inaccurate. Consider using '#align subgroup_class.inclusion SubgroupClass.inclusionₓ'. -/
/-- The inclusion homomorphism from a subgroup `H` contained in `K` to `K`. -/
@[to_additive "The inclusion homomorphism from a additive subgroup `H` contained in `K` to `K`."]
def inclusion {H K : S} (h : H ≤ K) : H →* K :=
  MonoidHom.mk' (fun x => ⟨x, h x.Prop⟩) fun ⟨a, ha⟩ ⟨b, hb⟩ => rfl
#align subgroup_class.inclusion SubgroupClass.inclusion
#align add_subgroup_class.inclusion AddSubgroupClass.inclusion

/- warning: subgroup_class.inclusion_self -> SubgroupClass.inclusion_self is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Type.{u2}} {H : S} [_inst_6 : SetLike.{u2, u1} S G] [hSG : SubgroupClass.{u2, u1} S G (Group.toDivInvMonoid.{u1} G _inst_1) _inst_6] (x : coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H), Eq.{succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG))))) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG))))) => (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) -> (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H)) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG))))) (SubgroupClass.inclusion.{u1, u2} G _inst_1 S _inst_6 hSG H H (le_rfl.{u2} S (PartialOrder.toPreorder.{u2} S (SetLike.partialOrder.{u2, u1} S G _inst_6)) H)) x) x
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {S : Type.{u1}} {H : S} [_inst_6 : SetLike.{u1, u2} S G] [hSG : SubgroupClass.{u1, u2} S G (Group.toDivInvMonoid.{u2} G _inst_1) _inst_6] (x : Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) => Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) x) (FunLike.coe.{succ u2, succ u2, succ u2} (MonoidHom.{u2, u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Monoid.toMulOneClass.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Group.toDivInvMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (SubgroupClass.toGroup.{u2, u1} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Group.toDivInvMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (SubgroupClass.toGroup.{u2, u1} G _inst_1 S H _inst_6 hSG))))) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (fun (_x : Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) => Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) _x) (MulHomClass.toFunLike.{u2, u2, u2} (MonoidHom.{u2, u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Monoid.toMulOneClass.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Group.toDivInvMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (SubgroupClass.toGroup.{u2, u1} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Group.toDivInvMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (SubgroupClass.toGroup.{u2, u1} G _inst_1 S H _inst_6 hSG))))) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (MulOneClass.toMul.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Monoid.toMulOneClass.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Group.toDivInvMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (SubgroupClass.toGroup.{u2, u1} G _inst_1 S H _inst_6 hSG))))) (MulOneClass.toMul.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Monoid.toMulOneClass.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Group.toDivInvMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (SubgroupClass.toGroup.{u2, u1} G _inst_1 S H _inst_6 hSG))))) (MonoidHomClass.toMulHomClass.{u2, u2, u2} (MonoidHom.{u2, u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Monoid.toMulOneClass.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Group.toDivInvMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (SubgroupClass.toGroup.{u2, u1} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Group.toDivInvMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (SubgroupClass.toGroup.{u2, u1} G _inst_1 S H _inst_6 hSG))))) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Monoid.toMulOneClass.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Group.toDivInvMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (SubgroupClass.toGroup.{u2, u1} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Group.toDivInvMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (SubgroupClass.toGroup.{u2, u1} G _inst_1 S H _inst_6 hSG)))) (MonoidHom.monoidHomClass.{u2, u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Monoid.toMulOneClass.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Group.toDivInvMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (SubgroupClass.toGroup.{u2, u1} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (Group.toDivInvMonoid.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u1} G S (SetLike.instMembership.{u1, u2} S G _inst_6) x H)) (SubgroupClass.toGroup.{u2, u1} G _inst_1 S H _inst_6 hSG))))))) (SubgroupClass.inclusion.{u2, u1} G _inst_1 S _inst_6 hSG H H (le_rfl.{u1} S (PartialOrder.toPreorder.{u1} S (SetLike.instPartialOrder.{u1, u2} S G _inst_6)) H)) x) x
Case conversion may be inaccurate. Consider using '#align subgroup_class.inclusion_self SubgroupClass.inclusion_selfₓ'. -/
@[simp, to_additive]
theorem inclusion_self (x : H) : inclusion le_rfl x = x :=
  by
  cases x
  rfl
#align subgroup_class.inclusion_self SubgroupClass.inclusion_self
#align add_subgroup_class.inclusion_self AddSubgroupClass.inclusion_self

/- warning: subgroup_class.inclusion_mk -> SubgroupClass.inclusion_mk is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Type.{u2}} {H : S} {K : S} [_inst_6 : SetLike.{u2, u1} S G] [hSG : SubgroupClass.{u2, u1} S G (Group.toDivInvMonoid.{u1} G _inst_1) _inst_6] {h : LE.le.{u2} S (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (SetLike.partialOrder.{u2, u1} S G _inst_6))) H K} (x : G) (hx : Membership.Mem.{u1, u2} G S (SetLike.hasMem.{u2, u1} S G _inst_6) x H), Eq.{succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) => (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) -> (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K)) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) (SubgroupClass.inclusion.{u1, u2} G _inst_1 S _inst_6 hSG H K h) (Subtype.mk.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u2} G S (SetLike.hasMem.{u2, u1} S G _inst_6) x H) x hx)) (Subtype.mk.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u2} G S (SetLike.hasMem.{u2, u1} S G _inst_6) x K) x (h x hx))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Type.{u2}} {H : S} {K : S} [_inst_6 : SetLike.{u2, u1} S G] [hSG : SubgroupClass.{u2, u1} S G (Group.toDivInvMonoid.{u1} G _inst_1) _inst_6] {h : LE.le.{u2} S (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (SetLike.instPartialOrder.{u2, u1} S G _inst_6))) H K} (x : G) (hx : Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) => Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Subtype.mk.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H) x hx)) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (fun (_x : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) => Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG))))) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG)))) (MonoidHom.monoidHomClass.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))))) (SubgroupClass.inclusion.{u1, u2} G _inst_1 S _inst_6 hSG H K h) (Subtype.mk.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H) x hx)) (Subtype.mk.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K) x (h x hx))
Case conversion may be inaccurate. Consider using '#align subgroup_class.inclusion_mk SubgroupClass.inclusion_mkₓ'. -/
@[simp, to_additive]
theorem inclusion_mk {h : H ≤ K} (x : G) (hx : x ∈ H) : inclusion h ⟨x, hx⟩ = ⟨x, h hx⟩ :=
  rfl
#align subgroup_class.inclusion_mk SubgroupClass.inclusion_mk
#align add_subgroup_class.inclusion_mk AddSubgroupClass.inclusion_mk

/- warning: subgroup_class.inclusion_right -> SubgroupClass.inclusion_right is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Type.{u2}} {H : S} {K : S} [_inst_6 : SetLike.{u2, u1} S G] [hSG : SubgroupClass.{u2, u1} S G (Group.toDivInvMonoid.{u1} G _inst_1) _inst_6] (h : LE.le.{u2} S (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (SetLike.partialOrder.{u2, u1} S G _inst_6))) H K) (x : coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (hx : Membership.Mem.{u1, u2} G S (SetLike.hasMem.{u2, u1} S G _inst_6) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) G (coeBase.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u2} G S (SetLike.hasMem.{u2, u1} S G _inst_6) x K))))) x) H), Eq.{succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) => (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) -> (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K)) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) (SubgroupClass.inclusion.{u1, u2} G _inst_1 S _inst_6 hSG H K h) (Subtype.mk.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u2} G S (SetLike.hasMem.{u2, u1} S G _inst_6) x H) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) G (coeBase.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u2} G S (SetLike.hasMem.{u2, u1} S G _inst_6) x K))))) x) hx)) x
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Type.{u2}} {H : S} {K : S} [_inst_6 : SetLike.{u2, u1} S G] [hSG : SubgroupClass.{u2, u1} S G (Group.toDivInvMonoid.{u1} G _inst_1) _inst_6] (h : LE.le.{u2} S (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (SetLike.instPartialOrder.{u2, u1} S G _inst_6))) H K) (x : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (hx : Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u2, u1} S G _inst_6 K)) x) H), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) => Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Subtype.mk.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u2, u1} S G _inst_6 K)) x) hx)) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (fun (_x : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) => Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG))))) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG)))) (MonoidHom.monoidHomClass.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))))) (SubgroupClass.inclusion.{u1, u2} G _inst_1 S _inst_6 hSG H K h) (Subtype.mk.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u2, u1} S G _inst_6 K)) x) hx)) x
Case conversion may be inaccurate. Consider using '#align subgroup_class.inclusion_right SubgroupClass.inclusion_rightₓ'. -/
@[to_additive]
theorem inclusion_right (h : H ≤ K) (x : K) (hx : (x : G) ∈ H) : inclusion h ⟨x, hx⟩ = x :=
  by
  cases x
  rfl
#align subgroup_class.inclusion_right SubgroupClass.inclusion_right
#align add_subgroup_class.inclusion_right AddSubgroupClass.inclusion_right

/- warning: subgroup_class.inclusion_inclusion -> SubgroupClass.inclusion_inclusion is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Type.{u2}} {H : S} {K : S} [_inst_6 : SetLike.{u2, u1} S G] [hSG : SubgroupClass.{u2, u1} S G (Group.toDivInvMonoid.{u1} G _inst_1) _inst_6] {L : S} (hHK : LE.le.{u2} S (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (SetLike.partialOrder.{u2, u1} S G _inst_6))) H K) (hKL : LE.le.{u2} S (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (SetLike.partialOrder.{u2, u1} S G _inst_6))) K L) (x : coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H), Eq.{succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) L) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) L) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) L) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) L) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) L) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S L _inst_6 hSG))))) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) L) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) L) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) L) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) L) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S L _inst_6 hSG))))) => (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) -> (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) L)) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) L) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) L) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) L) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) L) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S L _inst_6 hSG))))) (SubgroupClass.inclusion.{u1, u2} G _inst_1 S _inst_6 hSG K L hKL) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) => (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) -> (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K)) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) (SubgroupClass.inclusion.{u1, u2} G _inst_1 S _inst_6 hSG H K hHK) x)) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) L) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) L) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) L) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) L) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S L _inst_6 hSG))))) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) L) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) L) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) L) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) L) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S L _inst_6 hSG))))) => (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) -> (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) L)) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) L) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) L) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) L) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) L) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S L _inst_6 hSG))))) (SubgroupClass.inclusion.{u1, u2} G _inst_1 S _inst_6 hSG H L (LE.le.trans.{u2} S (PartialOrder.toPreorder.{u2} S (SetLike.partialOrder.{u2, u1} S G _inst_6)) H K L hHK hKL)) x)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Type.{u2}} {H : S} {K : S} [_inst_6 : SetLike.{u2, u1} S G] [hSG : SubgroupClass.{u2, u1} S G (Group.toDivInvMonoid.{u1} G _inst_1) _inst_6] {L : S} (hHK : LE.le.{u2} S (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (SetLike.instPartialOrder.{u2, u1} S G _inst_6))) H K) (hKL : LE.le.{u2} S (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (SetLike.instPartialOrder.{u2, u1} S G _inst_6))) K L) (x : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) => Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (fun (a : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) => Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) a) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG))))) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG)))) (MonoidHom.monoidHomClass.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))))) (SubgroupClass.inclusion.{u1, u2} G _inst_1 S _inst_6 hSG H K hHK) x)) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S L _inst_6 hSG))))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (fun (_x : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) => Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S L _inst_6 hSG))))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S L _inst_6 hSG))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S L _inst_6 hSG))))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S L _inst_6 hSG)))) (MonoidHom.monoidHomClass.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S L _inst_6 hSG))))))) (SubgroupClass.inclusion.{u1, u2} G _inst_1 S _inst_6 hSG K L hKL) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (fun (_x : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) => Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG))))) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG)))) (MonoidHom.monoidHomClass.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))))) (SubgroupClass.inclusion.{u1, u2} G _inst_1 S _inst_6 hSG H K hHK) x)) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S L _inst_6 hSG))))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (fun (_x : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) => Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S L _inst_6 hSG))))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG))))) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S L _inst_6 hSG))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S L _inst_6 hSG))))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S L _inst_6 hSG)))) (MonoidHom.monoidHomClass.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x L)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S L _inst_6 hSG))))))) (SubgroupClass.inclusion.{u1, u2} G _inst_1 S _inst_6 hSG H L (LE.le.trans.{u2} S (PartialOrder.toPreorder.{u2} S (SetLike.instPartialOrder.{u2, u1} S G _inst_6)) H K L hHK hKL)) x)
Case conversion may be inaccurate. Consider using '#align subgroup_class.inclusion_inclusion SubgroupClass.inclusion_inclusionₓ'. -/
@[simp]
theorem inclusion_inclusion {L : S} (hHK : H ≤ K) (hKL : K ≤ L) (x : H) :
    inclusion hKL (inclusion hHK x) = inclusion (hHK.trans hKL) x :=
  by
  cases x
  rfl
#align subgroup_class.inclusion_inclusion SubgroupClass.inclusion_inclusion

/- warning: subgroup_class.coe_inclusion -> SubgroupClass.coe_inclusion is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Type.{u2}} [_inst_6 : SetLike.{u2, u1} S G] [hSG : SubgroupClass.{u2, u1} S G (Group.toDivInvMonoid.{u1} G _inst_1) _inst_6] {H : S} {K : S} {h : LE.le.{u2} S (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (SetLike.partialOrder.{u2, u1} S G _inst_6))) H K} (a : coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H), Eq.{succ u1} G ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) G (coeBase.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u2} G S (SetLike.hasMem.{u2, u1} S G _inst_6) x K))))) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) => (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) -> (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K)) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) (SubgroupClass.inclusion.{u1, u2} G _inst_1 S _inst_6 hSG H K h) a)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) G (coeBase.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u2} G S (SetLike.hasMem.{u2, u1} S G _inst_6) x H))))) a)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Type.{u2}} [_inst_6 : SetLike.{u2, u1} S G] [hSG : SubgroupClass.{u2, u1} S G (Group.toDivInvMonoid.{u1} G _inst_1) _inst_6] {H : S} {K : S} {h : LE.le.{u2} S (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (SetLike.instPartialOrder.{u2, u1} S G _inst_6))) H K} (a : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)), Eq.{succ u1} G (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u2, u1} S G _inst_6 K)) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (fun (_x : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) => Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG))))) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG)))) (MonoidHom.monoidHomClass.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG))))))) (SubgroupClass.inclusion.{u1, u2} G _inst_1 S _inst_6 hSG H K h) a)) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u2, u1} S G _inst_6 H)) a)
Case conversion may be inaccurate. Consider using '#align subgroup_class.coe_inclusion SubgroupClass.coe_inclusionₓ'. -/
@[simp, to_additive]
theorem coe_inclusion {H K : S} {h : H ≤ K} (a : H) : (inclusion h a : G) = a :=
  by
  cases a
  simp only [inclusion, [anonymous], MonoidHom.mk'_apply]
#align subgroup_class.coe_inclusion SubgroupClass.coe_inclusion
#align add_subgroup_class.coe_inclusion AddSubgroupClass.coe_inclusion

/- warning: subgroup_class.subtype_comp_inclusion -> SubgroupClass.subtype_comp_inclusion is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Type.{u2}} [_inst_6 : SetLike.{u2, u1} S G] [hSG : SubgroupClass.{u2, u1} S G (Group.toDivInvMonoid.{u1} G _inst_1) _inst_6] {H : S} {K : S} (hH : LE.le.{u2} S (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (SetLike.partialOrder.{u2, u1} S G _inst_6))) H K), Eq.{succ u1} (MonoidHom.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MonoidHom.comp.{u1, u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) H) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (Group.toDivInvMonoid.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S G _inst_6) K) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (SubgroupClass.subtype.{u1, u2} G _inst_1 S K _inst_6 hSG) (SubgroupClass.inclusion.{u1, u2} G _inst_1 S _inst_6 hSG H K hH)) (SubgroupClass.subtype.{u1, u2} G _inst_1 S H _inst_6 hSG)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Type.{u2}} [_inst_6 : SetLike.{u2, u1} S G] [hSG : SubgroupClass.{u2, u1} S G (Group.toDivInvMonoid.{u1} G _inst_1) _inst_6] {H : S} {K : S} (hH : LE.le.{u2} S (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (SetLike.instPartialOrder.{u2, u1} S G _inst_6))) H K), Eq.{succ u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) G (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MonoidHom.comp.{u1, u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) G (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x H)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S H _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u2} G S (SetLike.instMembership.{u2, u1} S G _inst_6) x K)) (SubgroupClass.toGroup.{u1, u2} G _inst_1 S K _inst_6 hSG)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (SubgroupClass.subtype.{u1, u2} G _inst_1 S K _inst_6 hSG) (SubgroupClass.inclusion.{u1, u2} G _inst_1 S _inst_6 hSG H K hH)) (SubgroupClass.subtype.{u1, u2} G _inst_1 S H _inst_6 hSG)
Case conversion may be inaccurate. Consider using '#align subgroup_class.subtype_comp_inclusion SubgroupClass.subtype_comp_inclusionₓ'. -/
@[simp, to_additive]
theorem subtype_comp_inclusion {H K : S} (hH : H ≤ K) :
    (subtype K).comp (inclusion hH) = subtype H :=
  by
  ext
  simp only [MonoidHom.comp_apply, coeSubtype, coe_inclusion]
#align subgroup_class.subtype_comp_inclusion SubgroupClass.subtype_comp_inclusion
#align add_subgroup_class.subtype_comp_inclusion AddSubgroupClass.subtype_comp_inclusion

end SubgroupClass

end SubgroupClass

#print Subgroup /-
/-- A subgroup of a group `G` is a subset containing 1, closed under multiplication
and closed under multiplicative inverse. -/
structure Subgroup (G : Type _) [Group G] extends Submonoid G where
  inv_mem' {x} : x ∈ carrier → x⁻¹ ∈ carrier
#align subgroup Subgroup
-/

#print AddSubgroup /-
/-- An additive subgroup of an additive group `G` is a subset containing 0, closed
under addition and additive inverse. -/
structure AddSubgroup (G : Type _) [AddGroup G] extends AddSubmonoid G where
  neg_mem' {x} : x ∈ carrier → -x ∈ carrier
#align add_subgroup AddSubgroup
-/

attribute [to_additive] Subgroup

attribute [to_additive AddSubgroup.toAddSubmonoid] Subgroup.toSubmonoid

/-- Reinterpret a `subgroup` as a `submonoid`. -/
add_decl_doc Subgroup.toSubmonoid

/-- Reinterpret an `add_subgroup` as an `add_submonoid`. -/
add_decl_doc AddSubgroup.toAddSubmonoid

namespace Subgroup

@[to_additive]
instance : SetLike (Subgroup G) G where
  coe := Subgroup.carrier
  coe_injective' p q h := by cases p <;> cases q <;> congr

@[to_additive]
instance : SubgroupClass (Subgroup G) G
    where
  mul_mem := Subgroup.mul_mem'
  one_mem := Subgroup.one_mem'
  inv_mem := Subgroup.inv_mem'

/- warning: subgroup.mem_carrier -> Subgroup.mem_carrier is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Subgroup.{u1} G _inst_1} {x : G}, Iff (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) x (Subgroup.carrier.{u1} G _inst_1 s)) (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x s)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Subgroup.{u1} G _inst_1} {x : G}, Iff (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (Subsemigroup.carrier.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Submonoid.toSubsemigroup.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 s)))) (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x s)
Case conversion may be inaccurate. Consider using '#align subgroup.mem_carrier Subgroup.mem_carrierₓ'. -/
@[simp, to_additive]
theorem mem_carrier {s : Subgroup G} {x : G} : x ∈ s.carrier ↔ x ∈ s :=
  Iff.rfl
#align subgroup.mem_carrier Subgroup.mem_carrier
#align add_subgroup.mem_carrier AddSubgroup.mem_carrier

/- warning: subgroup.mem_mk -> Subgroup.mem_mk is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G} {x : G} (h_one : forall {a : G} {b : G}, (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) a s) -> (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) b s) -> (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) a b) s)) (h_mul : Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) s) (h_inv : forall {x : G}, (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) x s) -> (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) x) s)), Iff (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (Subgroup.mk.{u1} G _inst_1 s h_one h_mul h_inv)) (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) x s)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G} {x : G} (h_one : forall {a : G} {b : G}, (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) a s) -> (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) b s) -> (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) a b) s)) (h_mul : s (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (MulOneClass.toOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) (h_inv : forall {x : G}, (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (Subsemigroup.carrier.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Submonoid.toSubsemigroup.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Submonoid.mk.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subsemigroup.mk.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) s h_one) h_mul)))) -> (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) x) (Subsemigroup.carrier.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Submonoid.toSubsemigroup.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Submonoid.mk.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subsemigroup.mk.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) s h_one) h_mul))))), Iff (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.mk.{u1} G _inst_1 (Submonoid.mk.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subsemigroup.mk.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) s h_one) h_mul) h_inv)) (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x s)
Case conversion may be inaccurate. Consider using '#align subgroup.mem_mk Subgroup.mem_mkₓ'. -/
@[simp, to_additive]
theorem mem_mk {s : Set G} {x : G} (h_one) (h_mul) (h_inv) : x ∈ mk s h_one h_mul h_inv ↔ x ∈ s :=
  Iff.rfl
#align subgroup.mem_mk Subgroup.mem_mk
#align add_subgroup.mem_mk AddSubgroup.mem_mk

/- warning: subgroup.coe_set_mk -> Subgroup.coe_set_mk is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G} (h_one : forall {a : G} {b : G}, (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) a s) -> (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) b s) -> (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) a b) s)) (h_mul : Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) s) (h_inv : forall {x : G}, (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) x s) -> (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) x) s)), Eq.{succ u1} (Set.{u1} G) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.mk.{u1} G _inst_1 s h_one h_mul h_inv)) s
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G} (h_one : forall {a : G} {b : G}, (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) a s) -> (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) b s) -> (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) a b) s)) (h_mul : s (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (MulOneClass.toOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) (h_inv : forall {x : G}, (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (Subsemigroup.carrier.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Submonoid.toSubsemigroup.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Submonoid.mk.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subsemigroup.mk.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) s h_one) h_mul)))) -> (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) x) (Subsemigroup.carrier.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Submonoid.toSubsemigroup.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Submonoid.mk.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subsemigroup.mk.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) s h_one) h_mul))))), Eq.{succ u1} (Set.{u1} G) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (Subgroup.mk.{u1} G _inst_1 (Submonoid.mk.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subsemigroup.mk.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) s h_one) h_mul) h_inv)) s
Case conversion may be inaccurate. Consider using '#align subgroup.coe_set_mk Subgroup.coe_set_mkₓ'. -/
@[simp, to_additive]
theorem coe_set_mk {s : Set G} (h_one) (h_mul) (h_inv) : (mk s h_one h_mul h_inv : Set G) = s :=
  rfl
#align subgroup.coe_set_mk Subgroup.coe_set_mk
#align add_subgroup.coe_set_mk AddSubgroup.coe_set_mk

/- warning: subgroup.mk_le_mk -> Subgroup.mk_le_mk is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G} {t : Set.{u1} G} (h_one : forall {a : G} {b : G}, (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) a s) -> (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) b s) -> (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) a b) s)) (h_mul : Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) s) (h_inv : forall {x : G}, (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) x s) -> (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) x) s)) (h_one' : forall {a : G} {b : G}, (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) a t) -> (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) b t) -> (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) a b) t)) (h_mul' : Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) t) (h_inv' : forall {x : G}, (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) x t) -> (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) x) t)), Iff (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.mk.{u1} G _inst_1 s h_one h_mul h_inv) (Subgroup.mk.{u1} G _inst_1 t h_one' h_mul' h_inv')) (HasSubset.Subset.{u1} (Set.{u1} G) (Set.hasSubset.{u1} G) s t)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G} {t : Set.{u1} G} (h_one : forall {a : G} {b : G}, (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) a s) -> (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) b s) -> (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) a b) s)) (h_mul : s (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (MulOneClass.toOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) (h_inv : forall {x : G}, (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (Subsemigroup.carrier.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Submonoid.toSubsemigroup.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Submonoid.mk.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subsemigroup.mk.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) s h_one) h_mul)))) -> (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) x) (Subsemigroup.carrier.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Submonoid.toSubsemigroup.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Submonoid.mk.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subsemigroup.mk.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) s h_one) h_mul))))) (h_one' : forall {a : G} {b : G}, (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) a t) -> (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) b t) -> (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) a b) t)) (h_mul' : t (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (MulOneClass.toOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) (h_inv' : forall {x : G}, (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (Subsemigroup.carrier.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Submonoid.toSubsemigroup.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Submonoid.mk.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subsemigroup.mk.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) t h_one') h_mul')))) -> (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) x) (Subsemigroup.carrier.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Submonoid.toSubsemigroup.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Submonoid.mk.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subsemigroup.mk.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) t h_one') h_mul'))))), Iff (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.instPartialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)))) (Subgroup.mk.{u1} G _inst_1 (Submonoid.mk.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subsemigroup.mk.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) s h_one) h_mul) h_inv) (Subgroup.mk.{u1} G _inst_1 (Submonoid.mk.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subsemigroup.mk.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) t h_one') h_mul') h_inv')) (HasSubset.Subset.{u1} (Set.{u1} G) (Set.instHasSubsetSet.{u1} G) s t)
Case conversion may be inaccurate. Consider using '#align subgroup.mk_le_mk Subgroup.mk_le_mkₓ'. -/
@[simp, to_additive]
theorem mk_le_mk {s t : Set G} (h_one) (h_mul) (h_inv) (h_one') (h_mul') (h_inv') :
    mk s h_one h_mul h_inv ≤ mk t h_one' h_mul' h_inv' ↔ s ⊆ t :=
  Iff.rfl
#align subgroup.mk_le_mk Subgroup.mk_le_mk
#align add_subgroup.mk_le_mk AddSubgroup.mk_le_mk

#print Subgroup.Simps.coe /-
/-- See Note [custom simps projection] -/
@[to_additive "See Note [custom simps projection]"]
def Simps.coe (S : Subgroup G) : Set G :=
  S
#align subgroup.simps.coe Subgroup.Simps.coe
#align add_subgroup.simps.coe AddSubgroup.Simps.coe
-/

initialize_simps_projections Subgroup (carrier → coe)

initialize_simps_projections AddSubgroup (carrier → coe)

/- warning: subgroup.coe_to_submonoid -> Subgroup.coe_toSubmonoid is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (K : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Set.{u1} G) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) G (Submonoid.setLike.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) (Subgroup.toSubmonoid.{u1} G _inst_1 K)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) K)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (K : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Set.{u1} G) (SetLike.coe.{u1, u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) G (Submonoid.instSetLikeSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.toSubmonoid.{u1} G _inst_1 K)) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) K)
Case conversion may be inaccurate. Consider using '#align subgroup.coe_to_submonoid Subgroup.coe_toSubmonoidₓ'. -/
@[simp, to_additive]
theorem coe_toSubmonoid (K : Subgroup G) : (K.toSubmonoid : Set G) = K :=
  rfl
#align subgroup.coe_to_submonoid Subgroup.coe_toSubmonoid
#align add_subgroup.coe_to_add_submonoid AddSubgroup.coe_toAddSubmonoid

/- warning: subgroup.mem_to_submonoid -> Subgroup.mem_toSubmonoid is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (K : Subgroup.{u1} G _inst_1) (x : G), Iff (Membership.Mem.{u1, u1} G (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) G (Submonoid.setLike.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x (Subgroup.toSubmonoid.{u1} G _inst_1 K)) (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x K)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (K : Subgroup.{u1} G _inst_1) (x : G), Iff (Membership.mem.{u1, u1} G (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) G (Submonoid.instSetLikeSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x (Subgroup.toSubmonoid.{u1} G _inst_1 K)) (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)
Case conversion may be inaccurate. Consider using '#align subgroup.mem_to_submonoid Subgroup.mem_toSubmonoidₓ'. -/
@[simp, to_additive]
theorem mem_toSubmonoid (K : Subgroup G) (x : G) : x ∈ K.toSubmonoid ↔ x ∈ K :=
  Iff.rfl
#align subgroup.mem_to_submonoid Subgroup.mem_toSubmonoid
#align add_subgroup.mem_to_add_submonoid AddSubgroup.mem_toAddSubmonoid

#print Subgroup.toSubmonoid_injective /-
@[to_additive]
theorem toSubmonoid_injective : Function.Injective (toSubmonoid : Subgroup G → Submonoid G) :=
  fun p q h => SetLike.ext'_iff.2 (show _ from SetLike.ext'_iff.1 h)
#align subgroup.to_submonoid_injective Subgroup.toSubmonoid_injective
#align add_subgroup.to_add_submonoid_injective AddSubgroup.toAddSubmonoid_injective
-/

#print Subgroup.toSubmonoid_eq /-
@[simp, to_additive]
theorem toSubmonoid_eq {p q : Subgroup G} : p.toSubmonoid = q.toSubmonoid ↔ p = q :=
  toSubmonoid_injective.eq_iff
#align subgroup.to_submonoid_eq Subgroup.toSubmonoid_eq
#align add_subgroup.to_add_submonoid_eq AddSubgroup.toAddSubmonoid_eq
-/

/- warning: subgroup.to_submonoid_strict_mono -> Subgroup.toSubmonoid_strictMono is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], StrictMono.{u1, u1} (Subgroup.{u1} G _inst_1) (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (SetLike.partialOrder.{u1, u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) G (Submonoid.setLike.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (Subgroup.toSubmonoid.{u1} G _inst_1)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], StrictMono.{u1, u1} (Subgroup.{u1} G _inst_1) (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.instPartialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Submonoid.instCompleteLatticeSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) (Subgroup.toSubmonoid.{u1} G _inst_1)
Case conversion may be inaccurate. Consider using '#align subgroup.to_submonoid_strict_mono Subgroup.toSubmonoid_strictMonoₓ'. -/
@[to_additive, mono]
theorem toSubmonoid_strictMono : StrictMono (toSubmonoid : Subgroup G → Submonoid G) := fun _ _ =>
  id
#align subgroup.to_submonoid_strict_mono Subgroup.toSubmonoid_strictMono
#align add_subgroup.to_add_submonoid_strict_mono AddSubgroup.toAddSubmonoid_strictMono

attribute [mono] AddSubgroup.toAddSubmonoid_strictMono

/- warning: subgroup.to_submonoid_mono -> Subgroup.toSubmonoid_mono is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Monotone.{u1, u1} (Subgroup.{u1} G _inst_1) (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (SetLike.partialOrder.{u1, u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) G (Submonoid.setLike.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (Subgroup.toSubmonoid.{u1} G _inst_1)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Monotone.{u1, u1} (Subgroup.{u1} G _inst_1) (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.instPartialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Submonoid.instCompleteLatticeSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) (Subgroup.toSubmonoid.{u1} G _inst_1)
Case conversion may be inaccurate. Consider using '#align subgroup.to_submonoid_mono Subgroup.toSubmonoid_monoₓ'. -/
@[to_additive, mono]
theorem toSubmonoid_mono : Monotone (toSubmonoid : Subgroup G → Submonoid G) :=
  toSubmonoid_strictMono.Monotone
#align subgroup.to_submonoid_mono Subgroup.toSubmonoid_mono
#align add_subgroup.to_add_submonoid_mono AddSubgroup.toAddSubmonoid_mono

attribute [mono] AddSubgroup.toAddSubmonoid_mono

/- warning: subgroup.to_submonoid_le -> Subgroup.toSubmonoid_le is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {p : Subgroup.{u1} G _inst_1} {q : Subgroup.{u1} G _inst_1}, Iff (LE.le.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Preorder.toLE.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (SetLike.partialOrder.{u1, u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) G (Submonoid.setLike.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) (Subgroup.toSubmonoid.{u1} G _inst_1 p) (Subgroup.toSubmonoid.{u1} G _inst_1 q)) (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) p q)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {p : Subgroup.{u1} G _inst_1} {q : Subgroup.{u1} G _inst_1}, Iff (LE.le.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Preorder.toLE.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Submonoid.instCompleteLatticeSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))) (Subgroup.toSubmonoid.{u1} G _inst_1 p) (Subgroup.toSubmonoid.{u1} G _inst_1 q)) (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.instPartialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)))) p q)
Case conversion may be inaccurate. Consider using '#align subgroup.to_submonoid_le Subgroup.toSubmonoid_leₓ'. -/
@[simp, to_additive]
theorem toSubmonoid_le {p q : Subgroup G} : p.toSubmonoid ≤ q.toSubmonoid ↔ p ≤ q :=
  Iff.rfl
#align subgroup.to_submonoid_le Subgroup.toSubmonoid_le
#align add_subgroup.to_add_submonoid_le AddSubgroup.toAddSubmonoid_le

end Subgroup

/-!
### Conversion to/from `additive`/`multiplicative`
-/


section mul_add

/- warning: subgroup.to_add_subgroup -> Subgroup.toAddSubgroup is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], OrderIso.{u1, u1} (Subgroup.{u1} G _inst_1) (AddSubgroup.{u1} (Additive.{u1} G) (Additive.addGroup.{u1} G _inst_1)) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Preorder.toLE.{u1} (AddSubgroup.{u1} (Additive.{u1} G) (Additive.addGroup.{u1} G _inst_1)) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} (Additive.{u1} G) (Additive.addGroup.{u1} G _inst_1)) (SetLike.partialOrder.{u1, u1} (AddSubgroup.{u1} (Additive.{u1} G) (Additive.addGroup.{u1} G _inst_1)) (Additive.{u1} G) (AddSubgroup.setLike.{u1} (Additive.{u1} G) (Additive.addGroup.{u1} G _inst_1)))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], OrderIso.{u1, u1} (Subgroup.{u1} G _inst_1) (AddSubgroup.{u1} (Additive.{u1} G) (Additive.addGroup.{u1} G _inst_1)) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.instPartialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)))) (Preorder.toLE.{u1} (AddSubgroup.{u1} (Additive.{u1} G) (Additive.addGroup.{u1} G _inst_1)) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} (Additive.{u1} G) (Additive.addGroup.{u1} G _inst_1)) (SetLike.instPartialOrder.{u1, u1} (AddSubgroup.{u1} (Additive.{u1} G) (Additive.addGroup.{u1} G _inst_1)) (Additive.{u1} G) (AddSubgroup.instSetLikeAddSubgroup.{u1} (Additive.{u1} G) (Additive.addGroup.{u1} G _inst_1)))))
Case conversion may be inaccurate. Consider using '#align subgroup.to_add_subgroup Subgroup.toAddSubgroupₓ'. -/
/-- Supgroups of a group `G` are isomorphic to additive subgroups of `additive G`. -/
@[simps]
def Subgroup.toAddSubgroup : Subgroup G ≃o AddSubgroup (Additive G)
    where
  toFun S := { S.toSubmonoid.toAddSubmonoid with neg_mem' := fun _ => S.inv_mem' }
  invFun S := { S.toAddSubmonoid.toSubmonoid' with inv_mem' := fun _ => S.neg_mem' }
  left_inv x := by cases x <;> rfl
  right_inv x := by cases x <;> rfl
  map_rel_iff' a b := Iff.rfl
#align subgroup.to_add_subgroup Subgroup.toAddSubgroup

/- warning: add_subgroup.to_subgroup' -> AddSubgroup.toSubgroup' is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], OrderIso.{u1, u1} (AddSubgroup.{u1} (Additive.{u1} G) (Additive.addGroup.{u1} G _inst_1)) (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (AddSubgroup.{u1} (Additive.{u1} G) (Additive.addGroup.{u1} G _inst_1)) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} (Additive.{u1} G) (Additive.addGroup.{u1} G _inst_1)) (SetLike.partialOrder.{u1, u1} (AddSubgroup.{u1} (Additive.{u1} G) (Additive.addGroup.{u1} G _inst_1)) (Additive.{u1} G) (AddSubgroup.setLike.{u1} (Additive.{u1} G) (Additive.addGroup.{u1} G _inst_1))))) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], OrderIso.{u1, u1} (AddSubgroup.{u1} (Additive.{u1} G) (Additive.addGroup.{u1} G _inst_1)) (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (AddSubgroup.{u1} (Additive.{u1} G) (Additive.addGroup.{u1} G _inst_1)) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} (Additive.{u1} G) (Additive.addGroup.{u1} G _inst_1)) (SetLike.instPartialOrder.{u1, u1} (AddSubgroup.{u1} (Additive.{u1} G) (Additive.addGroup.{u1} G _inst_1)) (Additive.{u1} G) (AddSubgroup.instSetLikeAddSubgroup.{u1} (Additive.{u1} G) (Additive.addGroup.{u1} G _inst_1))))) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.instPartialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1))))
Case conversion may be inaccurate. Consider using '#align add_subgroup.to_subgroup' AddSubgroup.toSubgroup'ₓ'. -/
/-- Additive subgroup of an additive group `additive G` are isomorphic to subgroup of `G`. -/
abbrev AddSubgroup.toSubgroup' : AddSubgroup (Additive G) ≃o Subgroup G :=
  Subgroup.toAddSubgroup.symm
#align add_subgroup.to_subgroup' AddSubgroup.toSubgroup'

/- warning: add_subgroup.to_subgroup -> AddSubgroup.toSubgroup is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} [_inst_3 : AddGroup.{u1} A], OrderIso.{u1, u1} (AddSubgroup.{u1} A _inst_3) (Subgroup.{u1} (Multiplicative.{u1} A) (Multiplicative.group.{u1} A _inst_3)) (Preorder.toLE.{u1} (AddSubgroup.{u1} A _inst_3) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} A _inst_3) (SetLike.partialOrder.{u1, u1} (AddSubgroup.{u1} A _inst_3) A (AddSubgroup.setLike.{u1} A _inst_3)))) (Preorder.toLE.{u1} (Subgroup.{u1} (Multiplicative.{u1} A) (Multiplicative.group.{u1} A _inst_3)) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} (Multiplicative.{u1} A) (Multiplicative.group.{u1} A _inst_3)) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} (Multiplicative.{u1} A) (Multiplicative.group.{u1} A _inst_3)) (Multiplicative.{u1} A) (Subgroup.setLike.{u1} (Multiplicative.{u1} A) (Multiplicative.group.{u1} A _inst_3)))))
but is expected to have type
  forall {A : Type.{u1}} [_inst_3 : AddGroup.{u1} A], OrderIso.{u1, u1} (AddSubgroup.{u1} A _inst_3) (Subgroup.{u1} (Multiplicative.{u1} A) (Multiplicative.group.{u1} A _inst_3)) (Preorder.toLE.{u1} (AddSubgroup.{u1} A _inst_3) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} A _inst_3) (SetLike.instPartialOrder.{u1, u1} (AddSubgroup.{u1} A _inst_3) A (AddSubgroup.instSetLikeAddSubgroup.{u1} A _inst_3)))) (Preorder.toLE.{u1} (Subgroup.{u1} (Multiplicative.{u1} A) (Multiplicative.group.{u1} A _inst_3)) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} (Multiplicative.{u1} A) (Multiplicative.group.{u1} A _inst_3)) (SetLike.instPartialOrder.{u1, u1} (Subgroup.{u1} (Multiplicative.{u1} A) (Multiplicative.group.{u1} A _inst_3)) (Multiplicative.{u1} A) (Subgroup.instSetLikeSubgroup.{u1} (Multiplicative.{u1} A) (Multiplicative.group.{u1} A _inst_3)))))
Case conversion may be inaccurate. Consider using '#align add_subgroup.to_subgroup AddSubgroup.toSubgroupₓ'. -/
/-- Additive supgroups of an additive group `A` are isomorphic to subgroups of `multiplicative A`.
-/
@[simps]
def AddSubgroup.toSubgroup : AddSubgroup A ≃o Subgroup (Multiplicative A)
    where
  toFun S := { S.toAddSubmonoid.toSubmonoid with inv_mem' := fun _ => S.neg_mem' }
  invFun S := { S.toSubmonoid.toAddSubmonoid' with neg_mem' := fun _ => S.inv_mem' }
  left_inv x := by cases x <;> rfl
  right_inv x := by cases x <;> rfl
  map_rel_iff' a b := Iff.rfl
#align add_subgroup.to_subgroup AddSubgroup.toSubgroup

/- warning: subgroup.to_add_subgroup' -> Subgroup.toAddSubgroup' is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} [_inst_3 : AddGroup.{u1} A], OrderIso.{u1, u1} (Subgroup.{u1} (Multiplicative.{u1} A) (Multiplicative.group.{u1} A _inst_3)) (AddSubgroup.{u1} A _inst_3) (Preorder.toLE.{u1} (Subgroup.{u1} (Multiplicative.{u1} A) (Multiplicative.group.{u1} A _inst_3)) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} (Multiplicative.{u1} A) (Multiplicative.group.{u1} A _inst_3)) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} (Multiplicative.{u1} A) (Multiplicative.group.{u1} A _inst_3)) (Multiplicative.{u1} A) (Subgroup.setLike.{u1} (Multiplicative.{u1} A) (Multiplicative.group.{u1} A _inst_3))))) (Preorder.toLE.{u1} (AddSubgroup.{u1} A _inst_3) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} A _inst_3) (SetLike.partialOrder.{u1, u1} (AddSubgroup.{u1} A _inst_3) A (AddSubgroup.setLike.{u1} A _inst_3))))
but is expected to have type
  forall {A : Type.{u1}} [_inst_3 : AddGroup.{u1} A], OrderIso.{u1, u1} (Subgroup.{u1} (Multiplicative.{u1} A) (Multiplicative.group.{u1} A _inst_3)) (AddSubgroup.{u1} A _inst_3) (Preorder.toLE.{u1} (Subgroup.{u1} (Multiplicative.{u1} A) (Multiplicative.group.{u1} A _inst_3)) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} (Multiplicative.{u1} A) (Multiplicative.group.{u1} A _inst_3)) (SetLike.instPartialOrder.{u1, u1} (Subgroup.{u1} (Multiplicative.{u1} A) (Multiplicative.group.{u1} A _inst_3)) (Multiplicative.{u1} A) (Subgroup.instSetLikeSubgroup.{u1} (Multiplicative.{u1} A) (Multiplicative.group.{u1} A _inst_3))))) (Preorder.toLE.{u1} (AddSubgroup.{u1} A _inst_3) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} A _inst_3) (SetLike.instPartialOrder.{u1, u1} (AddSubgroup.{u1} A _inst_3) A (AddSubgroup.instSetLikeAddSubgroup.{u1} A _inst_3))))
Case conversion may be inaccurate. Consider using '#align subgroup.to_add_subgroup' Subgroup.toAddSubgroup'ₓ'. -/
/-- Subgroups of an additive group `multiplicative A` are isomorphic to additive subgroups of `A`.
-/
abbrev Subgroup.toAddSubgroup' : Subgroup (Multiplicative A) ≃o AddSubgroup A :=
  AddSubgroup.toSubgroup.symm
#align subgroup.to_add_subgroup' Subgroup.toAddSubgroup'

end mul_add

namespace Subgroup

variable (H K : Subgroup G)

/- warning: subgroup.copy -> Subgroup.copy is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (K : Subgroup.{u1} G _inst_1) (s : Set.{u1} G), (Eq.{succ u1} (Set.{u1} G) s ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) K)) -> (Subgroup.{u1} G _inst_1)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (K : Subgroup.{u1} G _inst_1) (s : Set.{u1} G), (Eq.{succ u1} (Set.{u1} G) s (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) K)) -> (Subgroup.{u1} G _inst_1)
Case conversion may be inaccurate. Consider using '#align subgroup.copy Subgroup.copyₓ'. -/
/-- Copy of a subgroup with a new `carrier` equal to the old one. Useful to fix definitional
equalities.-/
@[to_additive
      "Copy of an additive subgroup with a new `carrier` equal to the old one.\nUseful to fix definitional equalities"]
protected def copy (K : Subgroup G) (s : Set G) (hs : s = K) : Subgroup G
    where
  carrier := s
  one_mem' := hs.symm ▸ K.one_mem'
  mul_mem' _ _ := hs.symm ▸ K.mul_mem'
  inv_mem' _ := hs.symm ▸ K.inv_mem'
#align subgroup.copy Subgroup.copy
#align add_subgroup.copy AddSubgroup.copy

/- warning: subgroup.coe_copy -> Subgroup.coe_copy is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (K : Subgroup.{u1} G _inst_1) (s : Set.{u1} G) (hs : Eq.{succ u1} (Set.{u1} G) s ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) K)), Eq.{succ u1} (Set.{u1} G) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.copy.{u1} G _inst_1 K s hs)) s
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (K : Subgroup.{u1} G _inst_1) (s : Set.{u1} G) (hs : Eq.{succ u1} (Set.{u1} G) s (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) K)), Eq.{succ u1} (Set.{u1} G) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (Subgroup.copy.{u1} G _inst_1 K s hs)) s
Case conversion may be inaccurate. Consider using '#align subgroup.coe_copy Subgroup.coe_copyₓ'. -/
@[simp, to_additive]
theorem coe_copy (K : Subgroup G) (s : Set G) (hs : s = ↑K) : (K.copy s hs : Set G) = s :=
  rfl
#align subgroup.coe_copy Subgroup.coe_copy
#align add_subgroup.coe_copy AddSubgroup.coe_copy

/- warning: subgroup.copy_eq -> Subgroup.copy_eq is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (K : Subgroup.{u1} G _inst_1) (s : Set.{u1} G) (hs : Eq.{succ u1} (Set.{u1} G) s ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) K)), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.copy.{u1} G _inst_1 K s hs) K
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (K : Subgroup.{u1} G _inst_1) (s : Set.{u1} G) (hs : Eq.{succ u1} (Set.{u1} G) s (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) K)), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.copy.{u1} G _inst_1 K s hs) K
Case conversion may be inaccurate. Consider using '#align subgroup.copy_eq Subgroup.copy_eqₓ'. -/
@[to_additive]
theorem copy_eq (K : Subgroup G) (s : Set G) (hs : s = ↑K) : K.copy s hs = K :=
  SetLike.coe_injective hs
#align subgroup.copy_eq Subgroup.copy_eq
#align add_subgroup.copy_eq AddSubgroup.copy_eq

/- warning: subgroup.ext -> Subgroup.ext is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1}, (forall (x : G), Iff (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H) (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x K)) -> (Eq.{succ u1} (Subgroup.{u1} G _inst_1) H K)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1}, (forall (x : G), Iff (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H) (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) -> (Eq.{succ u1} (Subgroup.{u1} G _inst_1) H K)
Case conversion may be inaccurate. Consider using '#align subgroup.ext Subgroup.extₓ'. -/
/-- Two subgroups are equal if they have the same elements. -/
@[ext, to_additive "Two `add_subgroup`s are equal if they have the same elements."]
theorem ext {H K : Subgroup G} (h : ∀ x, x ∈ H ↔ x ∈ K) : H = K :=
  SetLike.ext h
#align subgroup.ext Subgroup.ext
#align add_subgroup.ext AddSubgroup.ext

/- warning: subgroup.one_mem -> Subgroup.one_mem is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) H
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))))) H
Case conversion may be inaccurate. Consider using '#align subgroup.one_mem Subgroup.one_memₓ'. -/
/-- A subgroup contains the group's 1. -/
@[to_additive "An `add_subgroup` contains the group's 0."]
protected theorem one_mem : (1 : G) ∈ H :=
  one_mem _
#align subgroup.one_mem Subgroup.one_mem
#align add_subgroup.zero_mem AddSubgroup.zero_mem

/- warning: subgroup.mul_mem -> Subgroup.mul_mem is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) {x : G} {y : G}, (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) y H) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x y) H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) {x : G} {y : G}, (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) y H) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x y) H)
Case conversion may be inaccurate. Consider using '#align subgroup.mul_mem Subgroup.mul_memₓ'. -/
/-- A subgroup is closed under multiplication. -/
@[to_additive "An `add_subgroup` is closed under addition."]
protected theorem mul_mem {x y : G} : x ∈ H → y ∈ H → x * y ∈ H :=
  mul_mem
#align subgroup.mul_mem Subgroup.mul_mem
#align add_subgroup.add_mem AddSubgroup.add_mem

/- warning: subgroup.inv_mem -> Subgroup.inv_mem is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) {x : G}, (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) x) H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) {x : G}, (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) x) H)
Case conversion may be inaccurate. Consider using '#align subgroup.inv_mem Subgroup.inv_memₓ'. -/
/-- A subgroup is closed under inverse. -/
@[to_additive "An `add_subgroup` is closed under inverse."]
protected theorem inv_mem {x : G} : x ∈ H → x⁻¹ ∈ H :=
  inv_mem
#align subgroup.inv_mem Subgroup.inv_mem
#align add_subgroup.neg_mem AddSubgroup.neg_mem

/- warning: subgroup.div_mem -> Subgroup.div_mem is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) {x : G} {y : G}, (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) y H) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (HDiv.hDiv.{u1, u1, u1} G G G (instHDiv.{u1} G (DivInvMonoid.toHasDiv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) x y) H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) {x : G} {y : G}, (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) y H) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (HDiv.hDiv.{u1, u1, u1} G G G (instHDiv.{u1} G (DivInvMonoid.toDiv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) x y) H)
Case conversion may be inaccurate. Consider using '#align subgroup.div_mem Subgroup.div_memₓ'. -/
/-- A subgroup is closed under division. -/
@[to_additive "An `add_subgroup` is closed under subtraction."]
protected theorem div_mem {x y : G} (hx : x ∈ H) (hy : y ∈ H) : x / y ∈ H :=
  div_mem hx hy
#align subgroup.div_mem Subgroup.div_mem
#align add_subgroup.sub_mem AddSubgroup.sub_mem

/- warning: subgroup.inv_mem_iff -> Subgroup.inv_mem_iff is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) {x : G}, Iff (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) x) H) (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) {x : G}, Iff (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) x) H) (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)
Case conversion may be inaccurate. Consider using '#align subgroup.inv_mem_iff Subgroup.inv_mem_iffₓ'. -/
@[to_additive]
protected theorem inv_mem_iff {x : G} : x⁻¹ ∈ H ↔ x ∈ H :=
  inv_mem_iff
#align subgroup.inv_mem_iff Subgroup.inv_mem_iff
#align add_subgroup.neg_mem_iff AddSubgroup.neg_mem_iff

/- warning: subgroup.div_mem_comm_iff -> Subgroup.div_mem_comm_iff is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) {a : G} {b : G}, Iff (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (HDiv.hDiv.{u1, u1, u1} G G G (instHDiv.{u1} G (DivInvMonoid.toHasDiv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a b) H) (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (HDiv.hDiv.{u1, u1, u1} G G G (instHDiv.{u1} G (DivInvMonoid.toHasDiv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) b a) H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) {a : G} {b : G}, Iff (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (HDiv.hDiv.{u1, u1, u1} G G G (instHDiv.{u1} G (DivInvMonoid.toDiv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a b) H) (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (HDiv.hDiv.{u1, u1, u1} G G G (instHDiv.{u1} G (DivInvMonoid.toDiv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) b a) H)
Case conversion may be inaccurate. Consider using '#align subgroup.div_mem_comm_iff Subgroup.div_mem_comm_iffₓ'. -/
@[to_additive]
protected theorem div_mem_comm_iff {a b : G} : a / b ∈ H ↔ b / a ∈ H :=
  div_mem_comm_iff
#align subgroup.div_mem_comm_iff Subgroup.div_mem_comm_iff
#align add_subgroup.sub_mem_comm_iff AddSubgroup.sub_mem_comm_iff

/- warning: subgroup.exists_inv_mem_iff_exists_mem -> Subgroup.exists_inv_mem_iff_exists_mem is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (K : Subgroup.{u1} G _inst_1) {P : G -> Prop}, Iff (Exists.{succ u1} G (fun (x : G) => And (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x K) (P (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) x)))) (Exists.{succ u1} G (fun (x : G) => Exists.{0} (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x K) (fun (H : Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x K) => P x)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (K : Subgroup.{u1} G _inst_1) {P : G -> Prop}, Iff (Exists.{succ u1} G (fun (x : G) => And (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K) (P (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) x)))) (Exists.{succ u1} G (fun (x : G) => And (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K) (P x)))
Case conversion may be inaccurate. Consider using '#align subgroup.exists_inv_mem_iff_exists_mem Subgroup.exists_inv_mem_iff_exists_memₓ'. -/
@[to_additive]
protected theorem exists_inv_mem_iff_exists_mem (K : Subgroup G) {P : G → Prop} :
    (∃ x : G, x ∈ K ∧ P x⁻¹) ↔ ∃ x ∈ K, P x :=
  exists_inv_mem_iff_exists_mem
#align subgroup.exists_inv_mem_iff_exists_mem Subgroup.exists_inv_mem_iff_exists_mem
#align add_subgroup.exists_neg_mem_iff_exists_mem AddSubgroup.exists_neg_mem_iff_exists_mem

/- warning: subgroup.mul_mem_cancel_right -> Subgroup.mul_mem_cancel_right is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) {x : G} {y : G}, (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H) -> (Iff (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) y x) H) (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) y H))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) {x : G} {y : G}, (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H) -> (Iff (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) y x) H) (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) y H))
Case conversion may be inaccurate. Consider using '#align subgroup.mul_mem_cancel_right Subgroup.mul_mem_cancel_rightₓ'. -/
@[to_additive]
protected theorem mul_mem_cancel_right {x y : G} (h : x ∈ H) : y * x ∈ H ↔ y ∈ H :=
  mul_mem_cancel_right h
#align subgroup.mul_mem_cancel_right Subgroup.mul_mem_cancel_right
#align add_subgroup.add_mem_cancel_right AddSubgroup.add_mem_cancel_right

/- warning: subgroup.mul_mem_cancel_left -> Subgroup.mul_mem_cancel_left is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) {x : G} {y : G}, (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H) -> (Iff (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x y) H) (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) y H))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) {x : G} {y : G}, (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H) -> (Iff (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x y) H) (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) y H))
Case conversion may be inaccurate. Consider using '#align subgroup.mul_mem_cancel_left Subgroup.mul_mem_cancel_leftₓ'. -/
@[to_additive]
protected theorem mul_mem_cancel_left {x y : G} (h : x ∈ H) : x * y ∈ H ↔ y ∈ H :=
  mul_mem_cancel_left h
#align subgroup.mul_mem_cancel_left Subgroup.mul_mem_cancel_left
#align add_subgroup.add_mem_cancel_left AddSubgroup.add_mem_cancel_left

/- warning: subgroup.pow_mem -> Subgroup.pow_mem is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (K : Subgroup.{u1} G _inst_1) {x : G}, (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x K) -> (forall (n : Nat), Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (HPow.hPow.{u1, 0, u1} G Nat G (instHPow.{u1, 0} G Nat (Monoid.Pow.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) x n) K)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (K : Subgroup.{u1} G _inst_1) {x : G}, (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K) -> (forall (n : Nat), Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (HPow.hPow.{u1, 0, u1} G Nat G (instHPow.{u1, 0} G Nat (Monoid.Pow.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) x n) K)
Case conversion may be inaccurate. Consider using '#align subgroup.pow_mem Subgroup.pow_memₓ'. -/
@[to_additive AddSubgroup.nsmul_mem]
protected theorem pow_mem {x : G} (hx : x ∈ K) : ∀ n : ℕ, x ^ n ∈ K :=
  pow_mem hx
#align subgroup.pow_mem Subgroup.pow_mem
#align add_subgroup.nsmul_mem AddSubgroup.nsmul_mem

/- warning: subgroup.zpow_mem -> Subgroup.zpow_mem is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (K : Subgroup.{u1} G _inst_1) {x : G}, (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x K) -> (forall (n : Int), Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) x n) K)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (K : Subgroup.{u1} G _inst_1) {x : G}, (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K) -> (forall (n : Int), Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) x n) K)
Case conversion may be inaccurate. Consider using '#align subgroup.zpow_mem Subgroup.zpow_memₓ'. -/
@[to_additive]
protected theorem zpow_mem {x : G} (hx : x ∈ K) : ∀ n : ℤ, x ^ n ∈ K :=
  zpow_mem hx
#align subgroup.zpow_mem Subgroup.zpow_mem
#align add_subgroup.zsmul_mem AddSubgroup.zsmul_mem

/- warning: subgroup.of_div -> Subgroup.ofDiv is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (s : Set.{u1} G), (Set.Nonempty.{u1} G s) -> (forall (x : G), (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) x s) -> (forall (y : G), (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) y s) -> (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) y)) s))) -> (Subgroup.{u1} G _inst_1)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (s : Set.{u1} G), (Set.Nonempty.{u1} G s) -> (forall (x : G), (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x s) -> (forall (y : G), (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) y s) -> (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) y)) s))) -> (Subgroup.{u1} G _inst_1)
Case conversion may be inaccurate. Consider using '#align subgroup.of_div Subgroup.ofDivₓ'. -/
/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x y «expr ∈ » s) -/
/-- Construct a subgroup from a nonempty set that is closed under division. -/
@[to_additive "Construct a subgroup from a nonempty set that is closed under subtraction"]
def ofDiv (s : Set G) (hsn : s.Nonempty) (hs : ∀ (x) (_ : x ∈ s) (y) (_ : y ∈ s), x * y⁻¹ ∈ s) :
    Subgroup G :=
  have one_mem : (1 : G) ∈ s := by
    let ⟨x, hx⟩ := hsn
    simpa using hs x hx x hx
  have inv_mem : ∀ x, x ∈ s → x⁻¹ ∈ s := fun x hx => by simpa using hs 1 one_mem x hx
  { carrier := s
    one_mem' := one_mem
    inv_mem' := inv_mem
    mul_mem' := fun x y hx hy => by simpa using hs x hx y⁻¹ (inv_mem y hy) }
#align subgroup.of_div Subgroup.ofDiv
#align add_subgroup.of_sub AddSubgroup.ofSub

/- warning: subgroup.has_mul -> Subgroup.mul is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Mul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Mul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H))
Case conversion may be inaccurate. Consider using '#align subgroup.has_mul Subgroup.mulₓ'. -/
/-- A subgroup of a group inherits a multiplication. -/
@[to_additive "An `add_subgroup` of an `add_group` inherits an addition."]
instance mul : Mul H :=
  H.toSubmonoid.Mul
#align subgroup.has_mul Subgroup.mul
#align add_subgroup.has_add AddSubgroup.add

/- warning: subgroup.has_one -> Subgroup.one is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), One.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), One.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H))
Case conversion may be inaccurate. Consider using '#align subgroup.has_one Subgroup.oneₓ'. -/
/-- A subgroup of a group inherits a 1. -/
@[to_additive "An `add_subgroup` of an `add_group` inherits a zero."]
instance one : One H :=
  H.toSubmonoid.One
#align subgroup.has_one Subgroup.one
#align add_subgroup.has_zero AddSubgroup.zero

/- warning: subgroup.has_inv -> Subgroup.inv is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Inv.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Inv.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H))
Case conversion may be inaccurate. Consider using '#align subgroup.has_inv Subgroup.invₓ'. -/
/-- A subgroup of a group inherits an inverse. -/
@[to_additive "A `add_subgroup` of a `add_group` inherits an inverse."]
instance inv : Inv H :=
  ⟨fun a => ⟨a⁻¹, H.inv_mem a.2⟩⟩
#align subgroup.has_inv Subgroup.inv
#align add_subgroup.has_neg AddSubgroup.neg

/- warning: subgroup.has_div -> Subgroup.div is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Div.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Div.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H))
Case conversion may be inaccurate. Consider using '#align subgroup.has_div Subgroup.divₓ'. -/
/-- A subgroup of a group inherits a division -/
@[to_additive "An `add_subgroup` of an `add_group` inherits a subtraction."]
instance div : Div H :=
  ⟨fun a b => ⟨a / b, H.div_mem a.2 b.2⟩⟩
#align subgroup.has_div Subgroup.div
#align add_subgroup.has_sub AddSubgroup.sub

/- warning: add_subgroup.has_nsmul -> AddSubgroup.nsmul is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_4 : AddGroup.{u1} G] {H : AddSubgroup.{u1} G _inst_4}, SMul.{0, u1} Nat (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} G _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} G _inst_4) G (AddSubgroup.setLike.{u1} G _inst_4)) H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_4 : AddGroup.{u1} G] {H : AddSubgroup.{u1} G _inst_4}, SMul.{0, u1} Nat (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (AddSubgroup.{u1} G _inst_4) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} G _inst_4) G (AddSubgroup.instSetLikeAddSubgroup.{u1} G _inst_4)) x H))
Case conversion may be inaccurate. Consider using '#align add_subgroup.has_nsmul AddSubgroup.nsmulₓ'. -/
/-- An `add_subgroup` of an `add_group` inherits a natural scaling. -/
instance AddSubgroup.nsmul {G} [AddGroup G] {H : AddSubgroup G} : SMul ℕ H :=
  ⟨fun n a => ⟨n • a, H.nsmul_mem a.2 n⟩⟩
#align add_subgroup.has_nsmul AddSubgroup.nsmul

/- warning: subgroup.has_npow -> Subgroup.npow is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Pow.{u1, 0} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) Nat
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Pow.{u1, 0} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) Nat
Case conversion may be inaccurate. Consider using '#align subgroup.has_npow Subgroup.npowₓ'. -/
/-- A subgroup of a group inherits a natural power -/
@[to_additive]
instance npow : Pow H ℕ :=
  ⟨fun a n => ⟨a ^ n, H.pow_mem a.2 n⟩⟩
#align subgroup.has_npow Subgroup.npow
#align add_subgroup.has_nsmul AddSubgroup.nsmul

/- warning: add_subgroup.has_zsmul -> AddSubgroup.zsmul is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_4 : AddGroup.{u1} G] {H : AddSubgroup.{u1} G _inst_4}, SMul.{0, u1} Int (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} G _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} G _inst_4) G (AddSubgroup.setLike.{u1} G _inst_4)) H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_4 : AddGroup.{u1} G] {H : AddSubgroup.{u1} G _inst_4}, SMul.{0, u1} Int (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (AddSubgroup.{u1} G _inst_4) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} G _inst_4) G (AddSubgroup.instSetLikeAddSubgroup.{u1} G _inst_4)) x H))
Case conversion may be inaccurate. Consider using '#align add_subgroup.has_zsmul AddSubgroup.zsmulₓ'. -/
/-- An `add_subgroup` of an `add_group` inherits an integer scaling. -/
instance AddSubgroup.zsmul {G} [AddGroup G] {H : AddSubgroup G} : SMul ℤ H :=
  ⟨fun n a => ⟨n • a, H.zsmul_mem a.2 n⟩⟩
#align add_subgroup.has_zsmul AddSubgroup.zsmul

/- warning: subgroup.has_zpow -> Subgroup.zpow is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Pow.{u1, 0} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) Int
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Pow.{u1, 0} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) Int
Case conversion may be inaccurate. Consider using '#align subgroup.has_zpow Subgroup.zpowₓ'. -/
/-- A subgroup of a group inherits an integer power -/
@[to_additive]
instance zpow : Pow H ℤ :=
  ⟨fun a n => ⟨a ^ n, H.zpow_mem a.2 n⟩⟩
#align subgroup.has_zpow Subgroup.zpow
#align add_subgroup.has_zsmul AddSubgroup.zsmul

/- warning: subgroup.coe_mul -> Subgroup.coe_mul is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (x : coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (y : coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H), Eq.{succ u1} G ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H))))) (HMul.hMul.{u1, u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (instHMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.mul.{u1} G _inst_1 H)) x y)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H))))) x) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H))))) y))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (x : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (y : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)), Eq.{succ u1} G (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) (HMul.hMul.{u1, u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (instHMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.mul.{u1} G _inst_1 H)) x y)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) x) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) y))
Case conversion may be inaccurate. Consider using '#align subgroup.coe_mul Subgroup.coe_mulₓ'. -/
@[simp, norm_cast, to_additive]
theorem coe_mul (x y : H) : (↑(x * y) : G) = ↑x * ↑y :=
  rfl
#align subgroup.coe_mul Subgroup.coe_mul
#align add_subgroup.coe_add AddSubgroup.coe_add

/- warning: subgroup.coe_one -> Subgroup.coe_one is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Eq.{succ u1} G ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H))))) (OfNat.ofNat.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) 1 (OfNat.mk.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) 1 (One.one.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.one.{u1} G _inst_1 H))))) (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Eq.{succ u1} G (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) (OfNat.ofNat.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) 1 (One.toOfNat1.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.one.{u1} G _inst_1 H)))) (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))))
Case conversion may be inaccurate. Consider using '#align subgroup.coe_one Subgroup.coe_oneₓ'. -/
@[simp, norm_cast, to_additive]
theorem coe_one : ((1 : H) : G) = 1 :=
  rfl
#align subgroup.coe_one Subgroup.coe_one
#align add_subgroup.coe_zero AddSubgroup.coe_zero

/- warning: subgroup.coe_inv -> Subgroup.coe_inv is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (x : coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H), Eq.{succ u1} G ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H))))) (Inv.inv.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.inv.{u1} G _inst_1 H) x)) (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H))))) x))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (x : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)), Eq.{succ u1} G (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) (Inv.inv.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.inv.{u1} G _inst_1 H) x)) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) x))
Case conversion may be inaccurate. Consider using '#align subgroup.coe_inv Subgroup.coe_invₓ'. -/
@[simp, norm_cast, to_additive]
theorem coe_inv (x : H) : ↑(x⁻¹ : H) = (x⁻¹ : G) :=
  rfl
#align subgroup.coe_inv Subgroup.coe_inv
#align add_subgroup.coe_neg AddSubgroup.coe_neg

/- warning: subgroup.coe_div -> Subgroup.coe_div is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (x : coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (y : coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H), Eq.{succ u1} G ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H))))) (HDiv.hDiv.{u1, u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (instHDiv.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.div.{u1} G _inst_1 H)) x y)) (HDiv.hDiv.{u1, u1, u1} G G G (instHDiv.{u1} G (DivInvMonoid.toHasDiv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H))))) x) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H))))) y))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (x : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (y : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)), Eq.{succ u1} G (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) (HDiv.hDiv.{u1, u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (instHDiv.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.div.{u1} G _inst_1 H)) x y)) (HDiv.hDiv.{u1, u1, u1} G G G (instHDiv.{u1} G (DivInvMonoid.toDiv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) x) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) y))
Case conversion may be inaccurate. Consider using '#align subgroup.coe_div Subgroup.coe_divₓ'. -/
@[simp, norm_cast, to_additive]
theorem coe_div (x y : H) : (↑(x / y) : G) = ↑x / ↑y :=
  rfl
#align subgroup.coe_div Subgroup.coe_div
#align add_subgroup.coe_sub AddSubgroup.coe_sub

/- warning: subgroup.coe_mk -> Subgroup.coe_mk is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (x : G) (hx : Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H), Eq.{succ u1} G ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H)) G (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H)) G (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H)) G (coeBase.{succ u1, succ u1} (Subtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H)) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H))))) (Subtype.mk.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H) x hx)) x
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (x : G) (hx : Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H), Eq.{succ u1} G (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) (Subtype.mk.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H) x hx)) x
Case conversion may be inaccurate. Consider using '#align subgroup.coe_mk Subgroup.coe_mkₓ'. -/
@[simp, norm_cast, to_additive]
theorem coe_mk (x : G) (hx : x ∈ H) : ((⟨x, hx⟩ : H) : G) = x :=
  rfl
#align subgroup.coe_mk Subgroup.coe_mk
#align add_subgroup.coe_mk AddSubgroup.coe_mk

/- warning: subgroup.coe_pow -> Subgroup.coe_pow is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (x : coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (n : Nat), Eq.{succ u1} G ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H))))) (HPow.hPow.{u1, 0, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) Nat (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (instHPow.{u1, 0} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) Nat (Subgroup.npow.{u1} G _inst_1 H)) x n)) (HPow.hPow.{u1, 0, u1} G Nat G (instHPow.{u1, 0} G Nat (Monoid.Pow.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H))))) x) n)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (x : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (n : Nat), Eq.{succ u1} G (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) (HPow.hPow.{u1, 0, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) Nat (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (instHPow.{u1, 0} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) Nat (Subgroup.npow.{u1} G _inst_1 H)) x n)) (HPow.hPow.{u1, 0, u1} G Nat G (instHPow.{u1, 0} G Nat (Monoid.Pow.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) x) n)
Case conversion may be inaccurate. Consider using '#align subgroup.coe_pow Subgroup.coe_powₓ'. -/
@[simp, norm_cast, to_additive]
theorem coe_pow (x : H) (n : ℕ) : ((x ^ n : H) : G) = x ^ n :=
  rfl
#align subgroup.coe_pow Subgroup.coe_pow
#align add_subgroup.coe_nsmul AddSubgroup.coe_nsmul

/- warning: subgroup.coe_zpow -> Subgroup.coe_zpow is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (x : coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (n : Int), Eq.{succ u1} G ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H))))) (HPow.hPow.{u1, 0, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) Int (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (instHPow.{u1, 0} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) Int (Subgroup.zpow.{u1} G _inst_1 H)) x n)) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H))))) x) n)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (x : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (n : Int), Eq.{succ u1} G (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) (HPow.hPow.{u1, 0, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) Int (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (instHPow.{u1, 0} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) Int (Subgroup.zpow.{u1} G _inst_1 H)) x n)) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) x) n)
Case conversion may be inaccurate. Consider using '#align subgroup.coe_zpow Subgroup.coe_zpowₓ'. -/
@[simp, norm_cast, to_additive]
theorem coe_zpow (x : H) (n : ℤ) : ((x ^ n : H) : G) = x ^ n :=
  rfl
#align subgroup.coe_zpow Subgroup.coe_zpow
#align add_subgroup.coe_zsmul AddSubgroup.coe_zsmul

/- warning: subgroup.mk_eq_one_iff -> Subgroup.mk_eq_one_iff is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) {g : G} {h : Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) g H}, Iff (Eq.{succ u1} (Subtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H)) (Subtype.mk.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H) g h) (OfNat.ofNat.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H)) 1 (OfNat.mk.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H)) 1 (One.one.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H)) (Subgroup.one.{u1} G _inst_1 H))))) (Eq.{succ u1} G g (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) {g : G} {h : Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) g H}, Iff (Eq.{succ u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subtype.mk.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H) g h) (OfNat.ofNat.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) 1 (One.toOfNat1.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.one.{u1} G _inst_1 H)))) (Eq.{succ u1} G g (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align subgroup.mk_eq_one_iff Subgroup.mk_eq_one_iffₓ'. -/
@[simp, to_additive]
theorem mk_eq_one_iff {g : G} {h} : (⟨g, h⟩ : H) = 1 ↔ g = 1 :=
  show (⟨g, h⟩ : H) = (⟨1, H.one_mem⟩ : H) ↔ g = 1 by simp
#align subgroup.mk_eq_one_iff Subgroup.mk_eq_one_iff
#align add_subgroup.mk_eq_zero_iff AddSubgroup.mk_eq_zero_iff

/- warning: subgroup.to_group -> Subgroup.toGroup is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_4 : Group.{u1} G] (H : Subgroup.{u1} G _inst_4), Group.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_4) G (Subgroup.setLike.{u1} G _inst_4)) H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_4 : Group.{u1} G] (H : Subgroup.{u1} G _inst_4), Group.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_4) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_4)) x H))
Case conversion may be inaccurate. Consider using '#align subgroup.to_group Subgroup.toGroupₓ'. -/
/-- A subgroup of a group inherits a group structure. -/
@[to_additive "An `add_subgroup` of an `add_group` inherits an `add_group` structure."]
instance toGroup {G : Type _} [Group G] (H : Subgroup G) : Group H :=
  Subtype.coe_injective.Group _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)
    (fun _ _ => rfl) fun _ _ => rfl
#align subgroup.to_group Subgroup.toGroup
#align add_subgroup.to_add_group AddSubgroup.toAddGroup

/- warning: subgroup.to_comm_group -> Subgroup.toCommGroup is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_4 : CommGroup.{u1} G] (H : Subgroup.{u1} G (CommGroup.toGroup.{u1} G _inst_4)), CommGroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G (CommGroup.toGroup.{u1} G _inst_4)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G (CommGroup.toGroup.{u1} G _inst_4)) G (Subgroup.setLike.{u1} G (CommGroup.toGroup.{u1} G _inst_4))) H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_4 : CommGroup.{u1} G] (H : Subgroup.{u1} G (CommGroup.toGroup.{u1} G _inst_4)), CommGroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G (CommGroup.toGroup.{u1} G _inst_4)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G (CommGroup.toGroup.{u1} G _inst_4)) G (Subgroup.instSetLikeSubgroup.{u1} G (CommGroup.toGroup.{u1} G _inst_4))) x H))
Case conversion may be inaccurate. Consider using '#align subgroup.to_comm_group Subgroup.toCommGroupₓ'. -/
/-- A subgroup of a `comm_group` is a `comm_group`. -/
@[to_additive "An `add_subgroup` of an `add_comm_group` is an `add_comm_group`."]
instance toCommGroup {G : Type _} [CommGroup G] (H : Subgroup G) : CommGroup H :=
  Subtype.coe_injective.CommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)
    (fun _ _ => rfl) fun _ _ => rfl
#align subgroup.to_comm_group Subgroup.toCommGroup
#align add_subgroup.to_add_comm_group AddSubgroup.toAddCommGroup

/- warning: subgroup.to_ordered_comm_group -> Subgroup.toOrderedCommGroup is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_4 : OrderedCommGroup.{u1} G] (H : Subgroup.{u1} G (CommGroup.toGroup.{u1} G (OrderedCommGroup.toCommGroup.{u1} G _inst_4))), OrderedCommGroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G (CommGroup.toGroup.{u1} G (OrderedCommGroup.toCommGroup.{u1} G _inst_4))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G (CommGroup.toGroup.{u1} G (OrderedCommGroup.toCommGroup.{u1} G _inst_4))) G (Subgroup.setLike.{u1} G (CommGroup.toGroup.{u1} G (OrderedCommGroup.toCommGroup.{u1} G _inst_4)))) H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_4 : OrderedCommGroup.{u1} G] (H : Subgroup.{u1} G (CommGroup.toGroup.{u1} G (OrderedCommGroup.toCommGroup.{u1} G _inst_4))), OrderedCommGroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G (CommGroup.toGroup.{u1} G (OrderedCommGroup.toCommGroup.{u1} G _inst_4))) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G (CommGroup.toGroup.{u1} G (OrderedCommGroup.toCommGroup.{u1} G _inst_4))) G (Subgroup.instSetLikeSubgroup.{u1} G (CommGroup.toGroup.{u1} G (OrderedCommGroup.toCommGroup.{u1} G _inst_4)))) x H))
Case conversion may be inaccurate. Consider using '#align subgroup.to_ordered_comm_group Subgroup.toOrderedCommGroupₓ'. -/
/-- A subgroup of an `ordered_comm_group` is an `ordered_comm_group`. -/
@[to_additive "An `add_subgroup` of an `add_ordered_comm_group` is an `add_ordered_comm_group`."]
instance toOrderedCommGroup {G : Type _} [OrderedCommGroup G] (H : Subgroup G) :
    OrderedCommGroup H :=
  Subtype.coe_injective.OrderedCommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)
    (fun _ _ => rfl) fun _ _ => rfl
#align subgroup.to_ordered_comm_group Subgroup.toOrderedCommGroup
#align add_subgroup.to_ordered_add_comm_group AddSubgroup.toOrderedAddCommGroup

/- warning: subgroup.to_linear_ordered_comm_group -> Subgroup.toLinearOrderedCommGroup is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_4 : LinearOrderedCommGroup.{u1} G] (H : Subgroup.{u1} G (CommGroup.toGroup.{u1} G (OrderedCommGroup.toCommGroup.{u1} G (LinearOrderedCommGroup.toOrderedCommGroup.{u1} G _inst_4)))), LinearOrderedCommGroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G (CommGroup.toGroup.{u1} G (OrderedCommGroup.toCommGroup.{u1} G (LinearOrderedCommGroup.toOrderedCommGroup.{u1} G _inst_4)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G (CommGroup.toGroup.{u1} G (OrderedCommGroup.toCommGroup.{u1} G (LinearOrderedCommGroup.toOrderedCommGroup.{u1} G _inst_4)))) G (Subgroup.setLike.{u1} G (CommGroup.toGroup.{u1} G (OrderedCommGroup.toCommGroup.{u1} G (LinearOrderedCommGroup.toOrderedCommGroup.{u1} G _inst_4))))) H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_4 : LinearOrderedCommGroup.{u1} G] (H : Subgroup.{u1} G (CommGroup.toGroup.{u1} G (OrderedCommGroup.toCommGroup.{u1} G (LinearOrderedCommGroup.toOrderedCommGroup.{u1} G _inst_4)))), LinearOrderedCommGroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G (CommGroup.toGroup.{u1} G (OrderedCommGroup.toCommGroup.{u1} G (LinearOrderedCommGroup.toOrderedCommGroup.{u1} G _inst_4)))) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G (CommGroup.toGroup.{u1} G (OrderedCommGroup.toCommGroup.{u1} G (LinearOrderedCommGroup.toOrderedCommGroup.{u1} G _inst_4)))) G (Subgroup.instSetLikeSubgroup.{u1} G (CommGroup.toGroup.{u1} G (OrderedCommGroup.toCommGroup.{u1} G (LinearOrderedCommGroup.toOrderedCommGroup.{u1} G _inst_4))))) x H))
Case conversion may be inaccurate. Consider using '#align subgroup.to_linear_ordered_comm_group Subgroup.toLinearOrderedCommGroupₓ'. -/
/-- A subgroup of a `linear_ordered_comm_group` is a `linear_ordered_comm_group`. -/
@[to_additive
      "An `add_subgroup` of a `linear_ordered_add_comm_group` is a\n  `linear_ordered_add_comm_group`."]
instance toLinearOrderedCommGroup {G : Type _} [LinearOrderedCommGroup G] (H : Subgroup G) :
    LinearOrderedCommGroup H :=
  Subtype.coe_injective.LinearOrderedCommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl)
    (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) fun _ _ => rfl
#align subgroup.to_linear_ordered_comm_group Subgroup.toLinearOrderedCommGroup
#align add_subgroup.to_linear_ordered_add_comm_group AddSubgroup.toLinearOrderedAddCommGroup

/- warning: subgroup.subtype -> Subgroup.subtype is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), MonoidHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 H)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))
Case conversion may be inaccurate. Consider using '#align subgroup.subtype Subgroup.subtypeₓ'. -/
/-- The natural group hom from a subgroup of group `G` to `G`. -/
@[to_additive "The natural group hom from an `add_subgroup` of `add_group` `G` to `G`."]
def subtype : H →* G :=
  ⟨coe, rfl, fun _ _ => rfl⟩
#align subgroup.subtype Subgroup.subtype
#align add_subgroup.subtype AddSubgroup.subtype

/- warning: subgroup.coe_subtype -> Subgroup.coeSubtype is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Eq.{succ u1} ((coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) -> G) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) -> G) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.subtype.{u1} G _inst_1 H)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H))))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Eq.{succ u1} (forall (ᾰ : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) => G) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 H)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (fun (_x : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) => G) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 H)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) G (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 H))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 H)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 H)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (MonoidHom.monoidHomClass.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 H)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (Subgroup.subtype.{u1} G _inst_1 H)) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)))
Case conversion may be inaccurate. Consider using '#align subgroup.coe_subtype Subgroup.coeSubtypeₓ'. -/
@[simp, to_additive]
theorem coeSubtype : ⇑H.Subtype = coe :=
  rfl
#align subgroup.coe_subtype Subgroup.coeSubtype
#align add_subgroup.coe_subtype AddSubgroup.coeSubtype

/- warning: subgroup.subtype_injective -> Subgroup.subtype_injective is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Function.Injective.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) -> G) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.subtype.{u1} G _inst_1 H))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Function.Injective.{succ u1, succ u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) G (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 H)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (fun (_x : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) => G) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 H)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) G (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 H))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 H)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 H)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (MonoidHom.monoidHomClass.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 H)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (Subgroup.subtype.{u1} G _inst_1 H))
Case conversion may be inaccurate. Consider using '#align subgroup.subtype_injective Subgroup.subtype_injectiveₓ'. -/
@[to_additive]
theorem subtype_injective : Function.Injective (subtype H) :=
  Subtype.coe_injective
#align subgroup.subtype_injective Subgroup.subtype_injective
#align add_subgroup.subtype_injective AddSubgroup.subtype_injective

/- warning: subgroup.inclusion -> Subgroup.inclusion is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1}, (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H K) -> (MonoidHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K)))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1}, (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.instPartialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)))) H K) -> (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 H)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 K)))
Case conversion may be inaccurate. Consider using '#align subgroup.inclusion Subgroup.inclusionₓ'. -/
/-- The inclusion homomorphism from a subgroup `H` contained in `K` to `K`. -/
@[to_additive "The inclusion homomorphism from a additive subgroup `H` contained in `K` to `K`."]
def inclusion {H K : Subgroup G} (h : H ≤ K) : H →* K :=
  MonoidHom.mk' (fun x => ⟨x, h x.Prop⟩) fun ⟨a, ha⟩ ⟨b, hb⟩ => rfl
#align subgroup.inclusion Subgroup.inclusion
#align add_subgroup.inclusion AddSubgroup.inclusion

/- warning: subgroup.coe_inclusion -> Subgroup.coe_inclusion is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1} {h : LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H K} (a : coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H), Eq.{succ u1} G ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) G (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x K))))) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K))))) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K))))) => (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) -> (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K)) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K))))) (Subgroup.inclusion.{u1} G _inst_1 H K h) a)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H))))) a)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1} {h : LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.instPartialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)))) H K} (a : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)), Eq.{succ u1} G (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) K)) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 H)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 K))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (fun (_x : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) => Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 H)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 K))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 H))) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 K))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 H)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 K))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 H)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 K)) (MonoidHom.monoidHomClass.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 H)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 K))))) (Subgroup.inclusion.{u1} G _inst_1 H K h) a)) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) a)
Case conversion may be inaccurate. Consider using '#align subgroup.coe_inclusion Subgroup.coe_inclusionₓ'. -/
@[simp, to_additive]
theorem coe_inclusion {H K : Subgroup G} {h : H ≤ K} (a : H) : (inclusion h a : G) = a :=
  by
  cases a
  simp only [inclusion, coe_mk, MonoidHom.mk'_apply]
#align subgroup.coe_inclusion Subgroup.coe_inclusion
#align add_subgroup.coe_inclusion AddSubgroup.coe_inclusion

/- warning: subgroup.inclusion_injective -> Subgroup.inclusion_injective is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1} (h : LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H K), Function.Injective.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K))))) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K))))) => (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) -> (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K)) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K))))) (Subgroup.inclusion.{u1} G _inst_1 H K h))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1} (h : LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.instPartialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)))) H K), Function.Injective.{succ u1, succ u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 H)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 K))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (fun (_x : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) => Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 H)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 K))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 H))) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 K))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 H)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 K))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 H)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 K)) (MonoidHom.monoidHomClass.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 H)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 K))))) (Subgroup.inclusion.{u1} G _inst_1 H K h))
Case conversion may be inaccurate. Consider using '#align subgroup.inclusion_injective Subgroup.inclusion_injectiveₓ'. -/
@[to_additive]
theorem inclusion_injective {H K : Subgroup G} (h : H ≤ K) : Function.Injective <| inclusion h :=
  Set.inclusion_injective h
#align subgroup.inclusion_injective Subgroup.inclusion_injective
#align add_subgroup.inclusion_injective AddSubgroup.inclusion_injective

/- warning: subgroup.subtype_comp_inclusion -> Subgroup.subtype_comp_inclusion is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1} (hH : LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H K), Eq.{succ u1} (MonoidHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MonoidHom.comp.{u1, u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.subtype.{u1} G _inst_1 K) (Subgroup.inclusion.{u1} G _inst_1 H K hH)) (Subgroup.subtype.{u1} G _inst_1 H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1} (hH : LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.instPartialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)))) H K), Eq.{succ u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 H)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MonoidHom.comp.{u1, u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 H)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 K)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.subtype.{u1} G _inst_1 K) (Subgroup.inclusion.{u1} G _inst_1 H K hH)) (Subgroup.subtype.{u1} G _inst_1 H)
Case conversion may be inaccurate. Consider using '#align subgroup.subtype_comp_inclusion Subgroup.subtype_comp_inclusionₓ'. -/
@[simp, to_additive]
theorem subtype_comp_inclusion {H K : Subgroup G} (hH : H ≤ K) :
    K.Subtype.comp (inclusion hH) = H.Subtype :=
  rfl
#align subgroup.subtype_comp_inclusion Subgroup.subtype_comp_inclusion
#align add_subgroup.subtype_comp_inclusion AddSubgroup.subtype_comp_inclusion

/-- The subgroup `G` of the group `G`. -/
@[to_additive "The `add_subgroup G` of the `add_group G`."]
instance : Top (Subgroup G) :=
  ⟨{ (⊤ : Submonoid G) with inv_mem' := fun _ _ => Set.mem_univ _ }⟩

/- warning: subgroup.top_equiv -> Subgroup.topEquiv is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], MulEquiv.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasTop.{u1} G _inst_1))) G (Subgroup.mul.{u1} G _inst_1 (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasTop.{u1} G _inst_1))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], MulEquiv.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instTopSubgroup.{u1} G _inst_1)))) G (Subgroup.mul.{u1} G _inst_1 (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instTopSubgroup.{u1} G _inst_1))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))
Case conversion may be inaccurate. Consider using '#align subgroup.top_equiv Subgroup.topEquivₓ'. -/
/-- The top subgroup is isomorphic to the group.

This is the group version of `submonoid.top_equiv`. -/
@[to_additive
      "The top additive subgroup is isomorphic to the additive group.\n\nThis is the additive group version of `add_submonoid.top_equiv`.",
  simps]
def topEquiv : (⊤ : Subgroup G) ≃* G :=
  Submonoid.topEquiv
#align subgroup.top_equiv Subgroup.topEquiv
#align add_subgroup.top_equiv AddSubgroup.topEquiv

/-- The trivial subgroup `{1}` of an group `G`. -/
@[to_additive "The trivial `add_subgroup` `{0}` of an `add_group` `G`."]
instance : Bot (Subgroup G) :=
  ⟨{ (⊥ : Submonoid G) with inv_mem' := fun _ => by simp [*] }⟩

@[to_additive]
instance : Inhabited (Subgroup G) :=
  ⟨⊥⟩

/- warning: subgroup.mem_bot -> Subgroup.mem_bot is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {x : G}, Iff (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1))) (Eq.{succ u1} G x (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {x : G}, Iff (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1))) (Eq.{succ u1} G x (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_bot Subgroup.mem_botₓ'. -/
@[simp, to_additive]
theorem mem_bot {x : G} : x ∈ (⊥ : Subgroup G) ↔ x = 1 :=
  Iff.rfl
#align subgroup.mem_bot Subgroup.mem_bot
#align add_subgroup.mem_bot AddSubgroup.mem_bot

/- warning: subgroup.mem_top -> Subgroup.mem_top is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (x : G), Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasTop.{u1} G _inst_1))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (x : G), Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instTopSubgroup.{u1} G _inst_1))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_top Subgroup.mem_topₓ'. -/
@[simp, to_additive]
theorem mem_top (x : G) : x ∈ (⊤ : Subgroup G) :=
  Set.mem_univ x
#align subgroup.mem_top Subgroup.mem_top
#align add_subgroup.mem_top AddSubgroup.mem_top

/- warning: subgroup.coe_top -> Subgroup.coe_top is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Eq.{succ u1} (Set.{u1} G) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasTop.{u1} G _inst_1))) (Set.univ.{u1} G)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Eq.{succ u1} (Set.{u1} G) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instTopSubgroup.{u1} G _inst_1))) (Set.univ.{u1} G)
Case conversion may be inaccurate. Consider using '#align subgroup.coe_top Subgroup.coe_topₓ'. -/
@[simp, to_additive]
theorem coe_top : ((⊤ : Subgroup G) : Set G) = Set.univ :=
  rfl
#align subgroup.coe_top Subgroup.coe_top
#align add_subgroup.coe_top AddSubgroup.coe_top

/- warning: subgroup.coe_bot -> Subgroup.coe_bot is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Eq.{succ u1} (Set.{u1} G) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1))) (Singleton.singleton.{u1, u1} G (Set.{u1} G) (Set.hasSingleton.{u1} G) (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Eq.{succ u1} (Set.{u1} G) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1))) (Singleton.singleton.{u1, u1} G (Set.{u1} G) (Set.instSingletonSet.{u1} G) (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align subgroup.coe_bot Subgroup.coe_botₓ'. -/
@[simp, to_additive]
theorem coe_bot : ((⊥ : Subgroup G) : Set G) = {1} :=
  rfl
#align subgroup.coe_bot Subgroup.coe_bot
#align add_subgroup.coe_bot AddSubgroup.coe_bot

@[to_additive]
instance : Unique (⊥ : Subgroup G) :=
  ⟨⟨1⟩, fun g => Subtype.ext g.2⟩

/- warning: subgroup.top_to_submonoid -> Subgroup.top_toSubmonoid is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Eq.{succ u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.toSubmonoid.{u1} G _inst_1 (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasTop.{u1} G _inst_1))) (Top.top.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Submonoid.hasTop.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Eq.{succ u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.toSubmonoid.{u1} G _inst_1 (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instTopSubgroup.{u1} G _inst_1))) (Top.top.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Submonoid.instTopSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))
Case conversion may be inaccurate. Consider using '#align subgroup.top_to_submonoid Subgroup.top_toSubmonoidₓ'. -/
@[simp, to_additive]
theorem top_toSubmonoid : (⊤ : Subgroup G).toSubmonoid = ⊤ :=
  rfl
#align subgroup.top_to_submonoid Subgroup.top_toSubmonoid
#align add_subgroup.top_to_add_submonoid AddSubgroup.top_toAddSubmonoid

/- warning: subgroup.bot_to_submonoid -> Subgroup.bot_toSubmonoid is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Eq.{succ u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.toSubmonoid.{u1} G _inst_1 (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1))) (Bot.bot.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Submonoid.hasBot.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Eq.{succ u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.toSubmonoid.{u1} G _inst_1 (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1))) (Bot.bot.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Submonoid.instBotSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))
Case conversion may be inaccurate. Consider using '#align subgroup.bot_to_submonoid Subgroup.bot_toSubmonoidₓ'. -/
@[simp, to_additive]
theorem bot_toSubmonoid : (⊥ : Subgroup G).toSubmonoid = ⊥ :=
  rfl
#align subgroup.bot_to_submonoid Subgroup.bot_toSubmonoid
#align add_subgroup.bot_to_add_submonoid AddSubgroup.bot_toAddSubmonoid

/- warning: subgroup.eq_bot_iff_forall -> Subgroup.eq_bot_iff_forall is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Iff (Eq.{succ u1} (Subgroup.{u1} G _inst_1) H (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1))) (forall (x : G), (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H) -> (Eq.{succ u1} G x (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Iff (Eq.{succ u1} (Subgroup.{u1} G _inst_1) H (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1))) (forall (x : G), (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H) -> (Eq.{succ u1} G x (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align subgroup.eq_bot_iff_forall Subgroup.eq_bot_iff_forallₓ'. -/
@[to_additive]
theorem eq_bot_iff_forall : H = ⊥ ↔ ∀ x ∈ H, x = (1 : G) :=
  toSubmonoid_injective.eq_iff.symm.trans <| Submonoid.eq_bot_iff_forall _
#align subgroup.eq_bot_iff_forall Subgroup.eq_bot_iff_forall
#align add_subgroup.eq_bot_iff_forall AddSubgroup.eq_bot_iff_forall

/- warning: subgroup.eq_bot_of_subsingleton -> Subgroup.eq_bot_of_subsingleton is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) [_inst_4 : Subsingleton.{succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H)], Eq.{succ u1} (Subgroup.{u1} G _inst_1) H (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) [_inst_4 : Subsingleton.{succ u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H))], Eq.{succ u1} (Subgroup.{u1} G _inst_1) H (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1))
Case conversion may be inaccurate. Consider using '#align subgroup.eq_bot_of_subsingleton Subgroup.eq_bot_of_subsingletonₓ'. -/
@[to_additive]
theorem eq_bot_of_subsingleton [Subsingleton H] : H = ⊥ :=
  by
  rw [Subgroup.eq_bot_iff_forall]
  intro y hy
  rw [← Subgroup.coe_mk H y hy, Subsingleton.elim (⟨y, hy⟩ : H) 1, Subgroup.coe_one]
#align subgroup.eq_bot_of_subsingleton Subgroup.eq_bot_of_subsingleton
#align add_subgroup.eq_bot_of_subsingleton AddSubgroup.eq_bot_of_subsingleton

/- warning: subgroup.coe_eq_univ -> Subgroup.coe_eq_univ is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, Iff (Eq.{succ u1} (Set.{u1} G) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H) (Set.univ.{u1} G)) (Eq.{succ u1} (Subgroup.{u1} G _inst_1) H (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasTop.{u1} G _inst_1)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, Iff (Eq.{succ u1} (Set.{u1} G) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H) (Set.univ.{u1} G)) (Eq.{succ u1} (Subgroup.{u1} G _inst_1) H (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instTopSubgroup.{u1} G _inst_1)))
Case conversion may be inaccurate. Consider using '#align subgroup.coe_eq_univ Subgroup.coe_eq_univₓ'. -/
@[to_additive]
theorem coe_eq_univ {H : Subgroup G} : (H : Set G) = Set.univ ↔ H = ⊤ :=
  (SetLike.ext'_iff.trans (by rfl)).symm
#align subgroup.coe_eq_univ Subgroup.coe_eq_univ
#align add_subgroup.coe_eq_univ AddSubgroup.coe_eq_univ

/- warning: subgroup.coe_eq_singleton -> Subgroup.coe_eq_singleton is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, Iff (Exists.{succ u1} G (fun (g : G) => Eq.{succ u1} (Set.{u1} G) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H) (Singleton.singleton.{u1, u1} G (Set.{u1} G) (Set.hasSingleton.{u1} G) g))) (Eq.{succ u1} (Subgroup.{u1} G _inst_1) H (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, Iff (Exists.{succ u1} G (fun (g : G) => Eq.{succ u1} (Set.{u1} G) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H) (Singleton.singleton.{u1, u1} G (Set.{u1} G) (Set.instSingletonSet.{u1} G) g))) (Eq.{succ u1} (Subgroup.{u1} G _inst_1) H (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1)))
Case conversion may be inaccurate. Consider using '#align subgroup.coe_eq_singleton Subgroup.coe_eq_singletonₓ'. -/
@[to_additive]
theorem coe_eq_singleton {H : Subgroup G} : (∃ g : G, (H : Set G) = {g}) ↔ H = ⊥ :=
  ⟨fun ⟨g, hg⟩ =>
    haveI : Subsingleton (H : Set G) := by
      rw [hg]
      infer_instance
    H.eq_bot_of_subsingleton,
    fun h => ⟨1, SetLike.ext'_iff.mp h⟩⟩
#align subgroup.coe_eq_singleton Subgroup.coe_eq_singleton
#align add_subgroup.coe_eq_singleton AddSubgroup.coe_eq_singleton

/- warning: subgroup.nontrivial_iff_exists_ne_one -> Subgroup.nontrivial_iff_exists_ne_one is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Iff (Nontrivial.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H)) (Exists.{succ u1} G (fun (x : G) => Exists.{0} (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H) (fun (H : Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H) => Ne.{succ u1} G x (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Iff (Nontrivial.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H))) (Exists.{succ u1} G (fun (x : G) => And (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H) (Ne.{succ u1} G x (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))))))))
Case conversion may be inaccurate. Consider using '#align subgroup.nontrivial_iff_exists_ne_one Subgroup.nontrivial_iff_exists_ne_oneₓ'. -/
@[to_additive]
theorem nontrivial_iff_exists_ne_one (H : Subgroup G) : Nontrivial H ↔ ∃ x ∈ H, x ≠ (1 : G) :=
  Subtype.nontrivial_iff_exists_ne (fun x => x ∈ H) (1 : H)
#align subgroup.nontrivial_iff_exists_ne_one Subgroup.nontrivial_iff_exists_ne_one
#align add_subgroup.nontrivial_iff_exists_ne_zero AddSubgroup.nontrivial_iff_exists_ne_zero

/- warning: subgroup.bot_or_nontrivial -> Subgroup.bot_or_nontrivial is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Or (Eq.{succ u1} (Subgroup.{u1} G _inst_1) H (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1))) (Nontrivial.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Or (Eq.{succ u1} (Subgroup.{u1} G _inst_1) H (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1))) (Nontrivial.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)))
Case conversion may be inaccurate. Consider using '#align subgroup.bot_or_nontrivial Subgroup.bot_or_nontrivialₓ'. -/
/-- A subgroup is either the trivial subgroup or nontrivial. -/
@[to_additive "A subgroup is either the trivial subgroup or nontrivial."]
theorem bot_or_nontrivial (H : Subgroup G) : H = ⊥ ∨ Nontrivial H := by
  classical
    by_cases h : ∀ x ∈ H, x = (1 : G)
    · left
      exact H.eq_bot_iff_forall.mpr h
    · right
      simp only [not_forall] at h
      simpa only [nontrivial_iff_exists_ne_one]
#align subgroup.bot_or_nontrivial Subgroup.bot_or_nontrivial
#align add_subgroup.bot_or_nontrivial AddSubgroup.bot_or_nontrivial

/- warning: subgroup.bot_or_exists_ne_one -> Subgroup.bot_or_exists_ne_one is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Or (Eq.{succ u1} (Subgroup.{u1} G _inst_1) H (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1))) (Exists.{succ u1} G (fun (x : G) => Exists.{0} (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H) (fun (H : Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H) => Ne.{succ u1} G x (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Or (Eq.{succ u1} (Subgroup.{u1} G _inst_1) H (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1))) (Exists.{succ u1} G (fun (x : G) => And (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H) (Ne.{succ u1} G x (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))))))))
Case conversion may be inaccurate. Consider using '#align subgroup.bot_or_exists_ne_one Subgroup.bot_or_exists_ne_oneₓ'. -/
/-- A subgroup is either the trivial subgroup or contains a non-identity element. -/
@[to_additive "A subgroup is either the trivial subgroup or contains a nonzero element."]
theorem bot_or_exists_ne_one (H : Subgroup G) : H = ⊥ ∨ ∃ x ∈ H, x ≠ (1 : G) :=
  by
  convert H.bot_or_nontrivial
  rw [nontrivial_iff_exists_ne_one]
#align subgroup.bot_or_exists_ne_one Subgroup.bot_or_exists_ne_one
#align add_subgroup.bot_or_exists_ne_zero AddSubgroup.bot_or_exists_ne_zero

/-- The inf of two subgroups is their intersection. -/
@[to_additive "The inf of two `add_subgroups`s is their intersection."]
instance : Inf (Subgroup G) :=
  ⟨fun H₁ H₂ =>
    { H₁.toSubmonoid ⊓ H₂.toSubmonoid with
      inv_mem' := fun _ ⟨hx, hx'⟩ => ⟨H₁.inv_mem hx, H₂.inv_mem hx'⟩ }⟩

/- warning: subgroup.coe_inf -> Subgroup.coe_inf is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (p : Subgroup.{u1} G _inst_1) (p' : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Set.{u1} G) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasInf.{u1} G _inst_1) p p')) (Inter.inter.{u1} (Set.{u1} G) (Set.hasInter.{u1} G) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) p) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) p'))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (p : Subgroup.{u1} G _inst_1) (p' : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Set.{u1} G) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instInfSubgroup.{u1} G _inst_1) p p')) (Inter.inter.{u1} (Set.{u1} G) (Set.instInterSet.{u1} G) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) p) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) p'))
Case conversion may be inaccurate. Consider using '#align subgroup.coe_inf Subgroup.coe_infₓ'. -/
@[simp, to_additive]
theorem coe_inf (p p' : Subgroup G) : ((p ⊓ p' : Subgroup G) : Set G) = p ∩ p' :=
  rfl
#align subgroup.coe_inf Subgroup.coe_inf
#align add_subgroup.coe_inf AddSubgroup.coe_inf

/- warning: subgroup.mem_inf -> Subgroup.mem_inf is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {p : Subgroup.{u1} G _inst_1} {p' : Subgroup.{u1} G _inst_1} {x : G}, Iff (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasInf.{u1} G _inst_1) p p')) (And (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x p) (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x p'))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {p : Subgroup.{u1} G _inst_1} {p' : Subgroup.{u1} G _inst_1} {x : G}, Iff (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instInfSubgroup.{u1} G _inst_1) p p')) (And (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x p) (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x p'))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_inf Subgroup.mem_infₓ'. -/
@[simp, to_additive]
theorem mem_inf {p p' : Subgroup G} {x : G} : x ∈ p ⊓ p' ↔ x ∈ p ∧ x ∈ p' :=
  Iff.rfl
#align subgroup.mem_inf Subgroup.mem_inf
#align add_subgroup.mem_inf AddSubgroup.mem_inf

@[to_additive]
instance : InfSet (Subgroup G) :=
  ⟨fun s =>
    { (⨅ S ∈ s, Subgroup.toSubmonoid S).copy (⋂ S ∈ s, ↑S) (by simp) with
      inv_mem' := fun x hx =>
        Set.mem_binterᵢ fun i h => i.inv_mem (by apply Set.mem_interᵢ₂.1 hx i h) }⟩

/- warning: subgroup.coe_Inf -> Subgroup.coe_infₛ is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Set.{u1} (Subgroup.{u1} G _inst_1)), Eq.{succ u1} (Set.{u1} G) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (InfSet.infₛ.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasInf.{u1} G _inst_1) H)) (Set.interᵢ.{u1, succ u1} G (Subgroup.{u1} G _inst_1) (fun (s : Subgroup.{u1} G _inst_1) => Set.interᵢ.{u1, 0} G (Membership.Mem.{u1, u1} (Subgroup.{u1} G _inst_1) (Set.{u1} (Subgroup.{u1} G _inst_1)) (Set.hasMem.{u1} (Subgroup.{u1} G _inst_1)) s H) (fun (H : Membership.Mem.{u1, u1} (Subgroup.{u1} G _inst_1) (Set.{u1} (Subgroup.{u1} G _inst_1)) (Set.hasMem.{u1} (Subgroup.{u1} G _inst_1)) s H) => (fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) s)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Set.{u1} (Subgroup.{u1} G _inst_1)), Eq.{succ u1} (Set.{u1} G) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (InfSet.infₛ.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instInfSetSubgroup.{u1} G _inst_1) H)) (Set.interᵢ.{u1, succ u1} G (Subgroup.{u1} G _inst_1) (fun (s : Subgroup.{u1} G _inst_1) => Set.interᵢ.{u1, 0} G (Membership.mem.{u1, u1} (Subgroup.{u1} G _inst_1) (Set.{u1} (Subgroup.{u1} G _inst_1)) (Set.instMembershipSet.{u1} (Subgroup.{u1} G _inst_1)) s H) (fun (H : Membership.mem.{u1, u1} (Subgroup.{u1} G _inst_1) (Set.{u1} (Subgroup.{u1} G _inst_1)) (Set.instMembershipSet.{u1} (Subgroup.{u1} G _inst_1)) s H) => SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) s)))
Case conversion may be inaccurate. Consider using '#align subgroup.coe_Inf Subgroup.coe_infₛₓ'. -/
@[simp, norm_cast, to_additive]
theorem coe_infₛ (H : Set (Subgroup G)) : ((infₛ H : Subgroup G) : Set G) = ⋂ s ∈ H, ↑s :=
  rfl
#align subgroup.coe_Inf Subgroup.coe_infₛ
#align add_subgroup.coe_Inf AddSubgroup.coe_infₛ

/- warning: subgroup.mem_Inf -> Subgroup.mem_infₛ is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Set.{u1} (Subgroup.{u1} G _inst_1)} {x : G}, Iff (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (InfSet.infₛ.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasInf.{u1} G _inst_1) S)) (forall (p : Subgroup.{u1} G _inst_1), (Membership.Mem.{u1, u1} (Subgroup.{u1} G _inst_1) (Set.{u1} (Subgroup.{u1} G _inst_1)) (Set.hasMem.{u1} (Subgroup.{u1} G _inst_1)) p S) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x p))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Set.{u1} (Subgroup.{u1} G _inst_1)} {x : G}, Iff (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (InfSet.infₛ.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instInfSetSubgroup.{u1} G _inst_1) S)) (forall (p : Subgroup.{u1} G _inst_1), (Membership.mem.{u1, u1} (Subgroup.{u1} G _inst_1) (Set.{u1} (Subgroup.{u1} G _inst_1)) (Set.instMembershipSet.{u1} (Subgroup.{u1} G _inst_1)) p S) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x p))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_Inf Subgroup.mem_infₛₓ'. -/
@[simp, to_additive]
theorem mem_infₛ {S : Set (Subgroup G)} {x : G} : x ∈ infₛ S ↔ ∀ p ∈ S, x ∈ p :=
  Set.mem_interᵢ₂
#align subgroup.mem_Inf Subgroup.mem_infₛ
#align add_subgroup.mem_Inf AddSubgroup.mem_infₛ

/- warning: subgroup.mem_infi -> Subgroup.mem_infᵢ is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Sort.{u2}} {S : ι -> (Subgroup.{u1} G _inst_1)} {x : G}, Iff (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (infᵢ.{u1, u2} (Subgroup.{u1} G _inst_1) (Subgroup.hasInf.{u1} G _inst_1) ι (fun (i : ι) => S i))) (forall (i : ι), Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (S i))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Sort.{u2}} {S : ι -> (Subgroup.{u1} G _inst_1)} {x : G}, Iff (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (infᵢ.{u1, u2} (Subgroup.{u1} G _inst_1) (Subgroup.instInfSetSubgroup.{u1} G _inst_1) ι (fun (i : ι) => S i))) (forall (i : ι), Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (S i))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_infi Subgroup.mem_infᵢₓ'. -/
@[to_additive]
theorem mem_infᵢ {ι : Sort _} {S : ι → Subgroup G} {x : G} : (x ∈ ⨅ i, S i) ↔ ∀ i, x ∈ S i := by
  simp only [infᵢ, mem_Inf, Set.forall_range_iff]
#align subgroup.mem_infi Subgroup.mem_infᵢ
#align add_subgroup.mem_infi AddSubgroup.mem_infᵢ

/- warning: subgroup.coe_infi -> Subgroup.coe_infᵢ is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Sort.{u2}} {S : ι -> (Subgroup.{u1} G _inst_1)}, Eq.{succ u1} (Set.{u1} G) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (infᵢ.{u1, u2} (Subgroup.{u1} G _inst_1) (Subgroup.hasInf.{u1} G _inst_1) ι (fun (i : ι) => S i))) (Set.interᵢ.{u1, u2} G ι (fun (i : ι) => (fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (S i)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Sort.{u2}} {S : ι -> (Subgroup.{u1} G _inst_1)}, Eq.{succ u1} (Set.{u1} G) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (infᵢ.{u1, u2} (Subgroup.{u1} G _inst_1) (Subgroup.instInfSetSubgroup.{u1} G _inst_1) ι (fun (i : ι) => S i))) (Set.interᵢ.{u1, u2} G ι (fun (i : ι) => SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (S i)))
Case conversion may be inaccurate. Consider using '#align subgroup.coe_infi Subgroup.coe_infᵢₓ'. -/
@[simp, norm_cast, to_additive]
theorem coe_infᵢ {ι : Sort _} {S : ι → Subgroup G} : (↑(⨅ i, S i) : Set G) = ⋂ i, S i := by
  simp only [infᵢ, coe_Inf, Set.binterᵢ_range]
#align subgroup.coe_infi Subgroup.coe_infᵢ
#align add_subgroup.coe_infi AddSubgroup.coe_infᵢ

/-- Subgroups of a group form a complete lattice. -/
@[to_additive "The `add_subgroup`s of an `add_group` form a complete lattice."]
instance : CompleteLattice (Subgroup G) :=
  {
    completeLatticeOfInf (Subgroup G) fun s =>
      IsGLB.of_image (fun H K => show (H : Set G) ≤ K ↔ H ≤ K from SetLike.coe_subset_coe)
        isGLB_binfᵢ with
    bot := ⊥
    bot_le := fun S x hx => (mem_bot.1 hx).symm ▸ S.one_mem
    top := ⊤
    le_top := fun S x hx => mem_top x
    inf := (· ⊓ ·)
    le_inf := fun a b c ha hb x hx => ⟨ha hx, hb hx⟩
    inf_le_left := fun a b x => And.left
    inf_le_right := fun a b x => And.right }

/- warning: subgroup.mem_sup_left -> Subgroup.mem_sup_left is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Subgroup.{u1} G _inst_1} {T : Subgroup.{u1} G _inst_1} {x : G}, (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x S) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) S T))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Subgroup.{u1} G _inst_1} {T : Subgroup.{u1} G _inst_1} {x : G}, (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x S) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) S T))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_sup_left Subgroup.mem_sup_leftₓ'. -/
@[to_additive]
theorem mem_sup_left {S T : Subgroup G} : ∀ {x : G}, x ∈ S → x ∈ S ⊔ T :=
  show S ≤ S ⊔ T from le_sup_left
#align subgroup.mem_sup_left Subgroup.mem_sup_left
#align add_subgroup.mem_sup_left AddSubgroup.mem_sup_left

/- warning: subgroup.mem_sup_right -> Subgroup.mem_sup_right is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Subgroup.{u1} G _inst_1} {T : Subgroup.{u1} G _inst_1} {x : G}, (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x T) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) S T))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Subgroup.{u1} G _inst_1} {T : Subgroup.{u1} G _inst_1} {x : G}, (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x T) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) S T))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_sup_right Subgroup.mem_sup_rightₓ'. -/
@[to_additive]
theorem mem_sup_right {S T : Subgroup G} : ∀ {x : G}, x ∈ T → x ∈ S ⊔ T :=
  show T ≤ S ⊔ T from le_sup_right
#align subgroup.mem_sup_right Subgroup.mem_sup_right
#align add_subgroup.mem_sup_right AddSubgroup.mem_sup_right

/- warning: subgroup.mul_mem_sup -> Subgroup.mul_mem_sup is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Subgroup.{u1} G _inst_1} {T : Subgroup.{u1} G _inst_1} {x : G} {y : G}, (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x S) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) y T) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x y) (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) S T))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Subgroup.{u1} G _inst_1} {T : Subgroup.{u1} G _inst_1} {x : G} {y : G}, (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x S) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) y T) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x y) (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) S T))
Case conversion may be inaccurate. Consider using '#align subgroup.mul_mem_sup Subgroup.mul_mem_supₓ'. -/
@[to_additive]
theorem mul_mem_sup {S T : Subgroup G} {x y : G} (hx : x ∈ S) (hy : y ∈ T) : x * y ∈ S ⊔ T :=
  (S ⊔ T).mul_mem (mem_sup_left hx) (mem_sup_right hy)
#align subgroup.mul_mem_sup Subgroup.mul_mem_sup
#align add_subgroup.add_mem_sup AddSubgroup.add_mem_sup

/- warning: subgroup.mem_supr_of_mem -> Subgroup.mem_supᵢ_of_mem is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Sort.{u2}} {S : ι -> (Subgroup.{u1} G _inst_1)} (i : ι) {x : G}, (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (S i)) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (supᵢ.{u1, u2} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))) ι S))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Sort.{u2}} {S : ι -> (Subgroup.{u1} G _inst_1)} (i : ι) {x : G}, (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (S i)) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (supᵢ.{u1, u2} (Subgroup.{u1} G _inst_1) (CompleteLattice.toSupSet.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)) ι S))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_supr_of_mem Subgroup.mem_supᵢ_of_memₓ'. -/
@[to_additive]
theorem mem_supᵢ_of_mem {ι : Sort _} {S : ι → Subgroup G} (i : ι) :
    ∀ {x : G}, x ∈ S i → x ∈ supᵢ S :=
  show S i ≤ supᵢ S from le_supᵢ _ _
#align subgroup.mem_supr_of_mem Subgroup.mem_supᵢ_of_mem
#align add_subgroup.mem_supr_of_mem AddSubgroup.mem_supᵢ_of_mem

/- warning: subgroup.mem_Sup_of_mem -> Subgroup.mem_supₛ_of_mem is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Set.{u1} (Subgroup.{u1} G _inst_1)} {s : Subgroup.{u1} G _inst_1}, (Membership.Mem.{u1, u1} (Subgroup.{u1} G _inst_1) (Set.{u1} (Subgroup.{u1} G _inst_1)) (Set.hasMem.{u1} (Subgroup.{u1} G _inst_1)) s S) -> (forall {x : G}, (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x s) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (SupSet.supₛ.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))) S)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Set.{u1} (Subgroup.{u1} G _inst_1)} {s : Subgroup.{u1} G _inst_1}, (Membership.mem.{u1, u1} (Subgroup.{u1} G _inst_1) (Set.{u1} (Subgroup.{u1} G _inst_1)) (Set.instMembershipSet.{u1} (Subgroup.{u1} G _inst_1)) s S) -> (forall {x : G}, (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x s) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (SupSet.supₛ.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toSupSet.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)) S)))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_Sup_of_mem Subgroup.mem_supₛ_of_memₓ'. -/
@[to_additive]
theorem mem_supₛ_of_mem {S : Set (Subgroup G)} {s : Subgroup G} (hs : s ∈ S) :
    ∀ {x : G}, x ∈ s → x ∈ supₛ S :=
  show s ≤ supₛ S from le_supₛ hs
#align subgroup.mem_Sup_of_mem Subgroup.mem_supₛ_of_mem
#align add_subgroup.mem_Sup_of_mem AddSubgroup.mem_supₛ_of_mem

#print Subgroup.subsingleton_iff /-
@[simp, to_additive]
theorem subsingleton_iff : Subsingleton (Subgroup G) ↔ Subsingleton G :=
  ⟨fun h =>
    ⟨fun x y =>
      have : ∀ i : G, i = 1 := fun i =>
        mem_bot.mp <| Subsingleton.elim (⊤ : Subgroup G) ⊥ ▸ mem_top i
      (this x).trans (this y).symm⟩,
    fun h => ⟨fun x y => Subgroup.ext fun i => Subsingleton.elim 1 i ▸ by simp [Subgroup.one_mem]⟩⟩
#align subgroup.subsingleton_iff Subgroup.subsingleton_iff
#align add_subgroup.subsingleton_iff AddSubgroup.subsingleton_iff
-/

#print Subgroup.nontrivial_iff /-
@[simp, to_additive]
theorem nontrivial_iff : Nontrivial (Subgroup G) ↔ Nontrivial G :=
  not_iff_not.mp
    ((not_nontrivial_iff_subsingleton.trans subsingleton_iff).trans
      not_nontrivial_iff_subsingleton.symm)
#align subgroup.nontrivial_iff Subgroup.nontrivial_iff
#align add_subgroup.nontrivial_iff AddSubgroup.nontrivial_iff
-/

@[to_additive]
instance [Subsingleton G] : Unique (Subgroup G) :=
  ⟨⟨⊥⟩, fun a => @Subsingleton.elim _ (subsingleton_iff.mpr ‹_›) a _⟩

@[to_additive]
instance [Nontrivial G] : Nontrivial (Subgroup G) :=
  nontrivial_iff.mpr ‹_›

/- warning: subgroup.eq_top_iff' -> Subgroup.eq_top_iff' is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Iff (Eq.{succ u1} (Subgroup.{u1} G _inst_1) H (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasTop.{u1} G _inst_1))) (forall (x : G), Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Iff (Eq.{succ u1} (Subgroup.{u1} G _inst_1) H (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instTopSubgroup.{u1} G _inst_1))) (forall (x : G), Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)
Case conversion may be inaccurate. Consider using '#align subgroup.eq_top_iff' Subgroup.eq_top_iff'ₓ'. -/
@[to_additive]
theorem eq_top_iff' : H = ⊤ ↔ ∀ x : G, x ∈ H :=
  eq_top_iff.trans ⟨fun h m => h <| mem_top m, fun h m _ => h m⟩
#align subgroup.eq_top_iff' Subgroup.eq_top_iff'
#align add_subgroup.eq_top_iff' AddSubgroup.eq_top_iff'

#print Subgroup.closure /-
/-- The `subgroup` generated by a set. -/
@[to_additive "The `add_subgroup` generated by a set"]
def closure (k : Set G) : Subgroup G :=
  infₛ { K | k ⊆ K }
#align subgroup.closure Subgroup.closure
#align add_subgroup.closure AddSubgroup.closure
-/

variable {k : Set G}

/- warning: subgroup.mem_closure -> Subgroup.mem_closure is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {k : Set.{u1} G} {x : G}, Iff (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 k)) (forall (K : Subgroup.{u1} G _inst_1), (HasSubset.Subset.{u1} (Set.{u1} G) (Set.hasSubset.{u1} G) k ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) K)) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x K))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {k : Set.{u1} G} {x : G}, Iff (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 k)) (forall (K : Subgroup.{u1} G _inst_1), (HasSubset.Subset.{u1} (Set.{u1} G) (Set.instHasSubsetSet.{u1} G) k (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) K)) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_closure Subgroup.mem_closureₓ'. -/
@[to_additive]
theorem mem_closure {x : G} : x ∈ closure k ↔ ∀ K : Subgroup G, k ⊆ K → x ∈ K :=
  mem_infₛ
#align subgroup.mem_closure Subgroup.mem_closure
#align add_subgroup.mem_closure AddSubgroup.mem_closure

/- warning: subgroup.subset_closure -> Subgroup.subset_closure is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {k : Set.{u1} G}, HasSubset.Subset.{u1} (Set.{u1} G) (Set.hasSubset.{u1} G) k ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.closure.{u1} G _inst_1 k))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {k : Set.{u1} G}, HasSubset.Subset.{u1} (Set.{u1} G) (Set.instHasSubsetSet.{u1} G) k (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (Subgroup.closure.{u1} G _inst_1 k))
Case conversion may be inaccurate. Consider using '#align subgroup.subset_closure Subgroup.subset_closureₓ'. -/
/-- The subgroup generated by a set includes the set. -/
@[simp, to_additive "The `add_subgroup` generated by a set includes the set."]
theorem subset_closure : k ⊆ closure k := fun x hx => mem_closure.2 fun K hK => hK hx
#align subgroup.subset_closure Subgroup.subset_closure
#align add_subgroup.subset_closure AddSubgroup.subset_closure

/- warning: subgroup.not_mem_of_not_mem_closure -> Subgroup.not_mem_of_not_mem_closure is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {k : Set.{u1} G} {P : G}, (Not (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) P (Subgroup.closure.{u1} G _inst_1 k))) -> (Not (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) P k))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {k : Set.{u1} G} {P : G}, (Not (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) P (Subgroup.closure.{u1} G _inst_1 k))) -> (Not (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) P k))
Case conversion may be inaccurate. Consider using '#align subgroup.not_mem_of_not_mem_closure Subgroup.not_mem_of_not_mem_closureₓ'. -/
@[to_additive]
theorem not_mem_of_not_mem_closure {P : G} (hP : P ∉ closure k) : P ∉ k := fun h =>
  hP (subset_closure h)
#align subgroup.not_mem_of_not_mem_closure Subgroup.not_mem_of_not_mem_closure
#align add_subgroup.not_mem_of_not_mem_closure AddSubgroup.not_mem_of_not_mem_closure

open Set

/- warning: subgroup.closure_le -> Subgroup.closure_le is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (K : Subgroup.{u1} G _inst_1) {k : Set.{u1} G}, Iff (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.closure.{u1} G _inst_1 k) K) (HasSubset.Subset.{u1} (Set.{u1} G) (Set.hasSubset.{u1} G) k ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) K))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (K : Subgroup.{u1} G _inst_1) {k : Set.{u1} G}, Iff (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (Subgroup.closure.{u1} G _inst_1 k) K) (HasSubset.Subset.{u1} (Set.{u1} G) (Set.instHasSubsetSet.{u1} G) k (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) K))
Case conversion may be inaccurate. Consider using '#align subgroup.closure_le Subgroup.closure_leₓ'. -/
/-- A subgroup `K` includes `closure k` if and only if it includes `k`. -/
@[simp, to_additive "An additive subgroup `K` includes `closure k` if and only if it includes `k`"]
theorem closure_le : closure k ≤ K ↔ k ⊆ K :=
  ⟨Subset.trans subset_closure, fun h => infₛ_le h⟩
#align subgroup.closure_le Subgroup.closure_le
#align add_subgroup.closure_le AddSubgroup.closure_le

/- warning: subgroup.closure_eq_of_le -> Subgroup.closure_eq_of_le is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (K : Subgroup.{u1} G _inst_1) {k : Set.{u1} G}, (HasSubset.Subset.{u1} (Set.{u1} G) (Set.hasSubset.{u1} G) k ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) K)) -> (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) K (Subgroup.closure.{u1} G _inst_1 k)) -> (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.closure.{u1} G _inst_1 k) K)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (K : Subgroup.{u1} G _inst_1) {k : Set.{u1} G}, (HasSubset.Subset.{u1} (Set.{u1} G) (Set.instHasSubsetSet.{u1} G) k (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) K)) -> (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) K (Subgroup.closure.{u1} G _inst_1 k)) -> (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.closure.{u1} G _inst_1 k) K)
Case conversion may be inaccurate. Consider using '#align subgroup.closure_eq_of_le Subgroup.closure_eq_of_leₓ'. -/
@[to_additive]
theorem closure_eq_of_le (h₁ : k ⊆ K) (h₂ : K ≤ closure k) : closure k = K :=
  le_antisymm ((closure_le <| K).2 h₁) h₂
#align subgroup.closure_eq_of_le Subgroup.closure_eq_of_le
#align add_subgroup.closure_eq_of_le AddSubgroup.closure_eq_of_le

/- warning: subgroup.closure_induction -> Subgroup.closure_induction is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {k : Set.{u1} G} {p : G -> Prop} {x : G}, (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 k)) -> (forall (x : G), (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) x k) -> (p x)) -> (p (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))) -> (forall (x : G) (y : G), (p x) -> (p y) -> (p (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x y))) -> (forall (x : G), (p x) -> (p (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) x))) -> (p x)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {k : Set.{u1} G} {p : G -> Prop} {x : G}, (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 k)) -> (forall (x : G), (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x k) -> (p x)) -> (p (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))))) -> (forall (x : G) (y : G), (p x) -> (p y) -> (p (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x y))) -> (forall (x : G), (p x) -> (p (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) x))) -> (p x)
Case conversion may be inaccurate. Consider using '#align subgroup.closure_induction Subgroup.closure_inductionₓ'. -/
/-- An induction principle for closure membership. If `p` holds for `1` and all elements of `k`, and
is preserved under multiplication and inverse, then `p` holds for all elements of the closure
of `k`. -/
@[elab_as_elim,
  to_additive
      "An induction principle for additive closure membership. If `p`\nholds for `0` and all elements of `k`, and is preserved under addition and inverses, then `p` holds\nfor all elements of the additive closure of `k`."]
theorem closure_induction {p : G → Prop} {x} (h : x ∈ closure k) (Hk : ∀ x ∈ k, p x) (H1 : p 1)
    (Hmul : ∀ x y, p x → p y → p (x * y)) (Hinv : ∀ x, p x → p x⁻¹) : p x :=
  (@closure_le _ _ ⟨p, Hmul, H1, Hinv⟩ _).2 Hk h
#align subgroup.closure_induction Subgroup.closure_induction
#align add_subgroup.closure_induction AddSubgroup.closure_induction

/- warning: subgroup.closure_induction' -> Subgroup.closure_induction' is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {k : Set.{u1} G} {p : forall (x : G), (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 k)) -> Prop}, (forall (x : G) (h : Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) x k), p x (Subgroup.subset_closure.{u1} G _inst_1 k x h)) -> (p (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) (OneMemClass.one_mem.{u1, u1} (Subgroup.{u1} G _inst_1) G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.setLike.{u1} G _inst_1) (SubmonoidClass.to_oneMemClass.{u1, u1} (Subgroup.{u1} G _inst_1) G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.setLike.{u1} G _inst_1) (SubgroupClass.to_submonoidClass.{u1, u1} (Subgroup.{u1} G _inst_1) G (Group.toDivInvMonoid.{u1} G _inst_1) (Subgroup.setLike.{u1} G _inst_1) (Subgroup.subgroupClass.{u1} G _inst_1))) (Subgroup.closure.{u1} G _inst_1 k))) -> (forall (x : G) (hx : Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 k)) (y : G) (hy : Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) y (Subgroup.closure.{u1} G _inst_1 k)), (p x hx) -> (p y hy) -> (p (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x y) (MulMemClass.mul_mem.{u1, u1} (Subgroup.{u1} G _inst_1) G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.setLike.{u1} G _inst_1) (SubmonoidClass.to_mulMemClass.{u1, u1} (Subgroup.{u1} G _inst_1) G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.setLike.{u1} G _inst_1) (SubgroupClass.to_submonoidClass.{u1, u1} (Subgroup.{u1} G _inst_1) G (Group.toDivInvMonoid.{u1} G _inst_1) (Subgroup.setLike.{u1} G _inst_1) (Subgroup.subgroupClass.{u1} G _inst_1))) (Subgroup.closure.{u1} G _inst_1 k) x y hx hy))) -> (forall (x : G) (hx : Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 k)), (p x hx) -> (p (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) x) (InvMemClass.inv_mem.{u1, u1} (Subgroup.{u1} G _inst_1) G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) (Subgroup.setLike.{u1} G _inst_1) (SubgroupClass.to_invMemClass.{u1, u1} (Subgroup.{u1} G _inst_1) G (Group.toDivInvMonoid.{u1} G _inst_1) (Subgroup.setLike.{u1} G _inst_1) (Subgroup.subgroupClass.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 k) x hx))) -> (forall {x : G} (hx : Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 k)), p x hx)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {k : Set.{u1} G} {p : forall (x : G), (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 k)) -> Prop}, (forall (x : G) (h : Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x k), p x (Subgroup.subset_closure.{u1} G _inst_1 k x h)) -> (p (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))))) (OneMemClass.one_mem.{u1, u1} (Subgroup.{u1} G _inst_1) G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (SubmonoidClass.toOneMemClass.{u1, u1} (Subgroup.{u1} G _inst_1) G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (SubgroupClass.toSubmonoidClass.{u1, u1} (Subgroup.{u1} G _inst_1) G (Group.toDivInvMonoid.{u1} G _inst_1) (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (Subgroup.instSubgroupClassSubgroupToDivInvMonoidInstSetLikeSubgroup.{u1} G _inst_1))) (Subgroup.closure.{u1} G _inst_1 k))) -> (forall (x : G) (hx : Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 k)) (y : G) (hy : Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) y (Subgroup.closure.{u1} G _inst_1 k)), (p x hx) -> (p y hy) -> (p (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x y) (MulMemClass.mul_mem.{u1, u1} (Subgroup.{u1} G _inst_1) G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (SubmonoidClass.toMulMemClass.{u1, u1} (Subgroup.{u1} G _inst_1) G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (SubgroupClass.toSubmonoidClass.{u1, u1} (Subgroup.{u1} G _inst_1) G (Group.toDivInvMonoid.{u1} G _inst_1) (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (Subgroup.instSubgroupClassSubgroupToDivInvMonoidInstSetLikeSubgroup.{u1} G _inst_1))) (Subgroup.closure.{u1} G _inst_1 k) x y hx hy))) -> (forall (x : G) (hx : Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 k)), (p x hx) -> (p (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) x) (InvMemClass.inv_mem.{u1, u1} (Subgroup.{u1} G _inst_1) G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (SubgroupClass.toInvMemClass.{u1, u1} (Subgroup.{u1} G _inst_1) G (Group.toDivInvMonoid.{u1} G _inst_1) (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (Subgroup.instSubgroupClassSubgroupToDivInvMonoidInstSetLikeSubgroup.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 k) x hx))) -> (forall {x : G} (hx : Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 k)), p x hx)
Case conversion may be inaccurate. Consider using '#align subgroup.closure_induction' Subgroup.closure_induction'ₓ'. -/
/-- A dependent version of `subgroup.closure_induction`.  -/
@[elab_as_elim, to_additive "A dependent version of `add_subgroup.closure_induction`. "]
theorem closure_induction' {p : ∀ x, x ∈ closure k → Prop}
    (Hs : ∀ (x) (h : x ∈ k), p x (subset_closure h)) (H1 : p 1 (one_mem _))
    (Hmul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy))
    (Hinv : ∀ x hx, p x hx → p x⁻¹ (inv_mem hx)) {x} (hx : x ∈ closure k) : p x hx :=
  by
  refine' Exists.elim _ fun (hx : x ∈ closure k) (hc : p x hx) => hc
  exact
    closure_induction hx (fun x hx => ⟨_, Hs x hx⟩) ⟨_, H1⟩
      (fun x y ⟨hx', hx⟩ ⟨hy', hy⟩ => ⟨_, Hmul _ _ _ _ hx hy⟩) fun x ⟨hx', hx⟩ => ⟨_, Hinv _ _ hx⟩
#align subgroup.closure_induction' Subgroup.closure_induction'
#align add_subgroup.closure_induction' AddSubgroup.closure_induction'

/- warning: subgroup.closure_induction₂ -> Subgroup.closure_induction₂ is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {k : Set.{u1} G} {p : G -> G -> Prop} {x : G} {y : G}, (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 k)) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) y (Subgroup.closure.{u1} G _inst_1 k)) -> (forall (x : G), (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) x k) -> (forall (y : G), (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) y k) -> (p x y))) -> (forall (x : G), p (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) x) -> (forall (x : G), p x (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))) -> (forall (x₁ : G) (x₂ : G) (y : G), (p x₁ y) -> (p x₂ y) -> (p (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x₁ x₂) y)) -> (forall (x : G) (y₁ : G) (y₂ : G), (p x y₁) -> (p x y₂) -> (p x (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) y₁ y₂))) -> (forall (x : G) (y : G), (p x y) -> (p (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) x) y)) -> (forall (x : G) (y : G), (p x y) -> (p x (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) y))) -> (p x y)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {k : Set.{u1} G} {p : G -> G -> Prop} {x : G} {y : G}, (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 k)) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) y (Subgroup.closure.{u1} G _inst_1 k)) -> (forall (x : G), (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x k) -> (forall (y : G), (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) y k) -> (p x y))) -> (forall (x : G), p (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))))) x) -> (forall (x : G), p x (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))))) -> (forall (x₁ : G) (x₂ : G) (y : G), (p x₁ y) -> (p x₂ y) -> (p (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x₁ x₂) y)) -> (forall (x : G) (y₁ : G) (y₂ : G), (p x y₁) -> (p x y₂) -> (p x (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) y₁ y₂))) -> (forall (x : G) (y : G), (p x y) -> (p (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) x) y)) -> (forall (x : G) (y : G), (p x y) -> (p x (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) y))) -> (p x y)
Case conversion may be inaccurate. Consider using '#align subgroup.closure_induction₂ Subgroup.closure_induction₂ₓ'. -/
/-- An induction principle for closure membership for predicates with two arguments. -/
@[elab_as_elim,
  to_additive
      "An induction principle for additive closure membership, for\npredicates with two arguments."]
theorem closure_induction₂ {p : G → G → Prop} {x} {y : G} (hx : x ∈ closure k) (hy : y ∈ closure k)
    (Hk : ∀ x ∈ k, ∀ y ∈ k, p x y) (H1_left : ∀ x, p 1 x) (H1_right : ∀ x, p x 1)
    (Hmul_left : ∀ x₁ x₂ y, p x₁ y → p x₂ y → p (x₁ * x₂) y)
    (Hmul_right : ∀ x y₁ y₂, p x y₁ → p x y₂ → p x (y₁ * y₂)) (Hinv_left : ∀ x y, p x y → p x⁻¹ y)
    (Hinv_right : ∀ x y, p x y → p x y⁻¹) : p x y :=
  closure_induction hx
    (fun x xk => closure_induction hy (Hk x xk) (H1_right x) (Hmul_right x) (Hinv_right x))
    (H1_left y) (fun z z' => Hmul_left z z' y) fun z => Hinv_left z y
#align subgroup.closure_induction₂ Subgroup.closure_induction₂
#align add_subgroup.closure_induction₂ AddSubgroup.closure_induction₂

/- warning: subgroup.closure_closure_coe_preimage -> Subgroup.closure_closure_coe_preimage is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {k : Set.{u1} G}, Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 k)) (Subgroup.toGroup.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 k))) (Subgroup.closure.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 k)) (Subgroup.toGroup.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 k)) (Set.preimage.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 k)) G ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 k)) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 k)) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 k)) G (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 k)) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 k))))))) k)) (Top.top.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 k)) (Subgroup.toGroup.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 k))) (Subgroup.hasTop.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 k)) (Subgroup.toGroup.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 k))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {k : Set.{u1} G}, Eq.{succ u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (Subgroup.closure.{u1} G _inst_1 k)))) (Subgroup.toGroup.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 k))) (Subgroup.closure.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (Subgroup.closure.{u1} G _inst_1 k)))) (Subgroup.toGroup.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 k)) (Set.preimage.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (Subgroup.closure.{u1} G _inst_1 k)))) G (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (Subgroup.closure.{u1} G _inst_1 k)))) k)) (Top.top.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (Subgroup.closure.{u1} G _inst_1 k)))) (Subgroup.toGroup.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 k))) (Subgroup.instTopSubgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (Subgroup.closure.{u1} G _inst_1 k)))) (Subgroup.toGroup.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 k))))
Case conversion may be inaccurate. Consider using '#align subgroup.closure_closure_coe_preimage Subgroup.closure_closure_coe_preimageₓ'. -/
@[simp, to_additive]
theorem closure_closure_coe_preimage {k : Set G} : closure ((coe : closure k → G) ⁻¹' k) = ⊤ :=
  eq_top_iff.2 fun x =>
    Subtype.recOn x fun x hx _ =>
      by
      refine' closure_induction' (fun g hg => _) _ (fun g₁ g₂ hg₁ hg₂ => _) (fun g hg => _) hx
      · exact subset_closure hg
      · exact one_mem _
      · exact mul_mem
      · exact inv_mem
#align subgroup.closure_closure_coe_preimage Subgroup.closure_closure_coe_preimage
#align add_subgroup.closure_closure_coe_preimage AddSubgroup.closure_closure_coe_preimage

/- warning: subgroup.closure_comm_group_of_comm -> Subgroup.closureCommGroupOfComm is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {k : Set.{u1} G}, (forall (x : G), (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) x k) -> (forall (y : G), (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) y k) -> (Eq.{succ u1} G (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x y) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) y x)))) -> (CommGroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 k)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {k : Set.{u1} G}, (forall (x : G), (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x k) -> (forall (y : G), (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) y k) -> (Eq.{succ u1} G (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x y) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) y x)))) -> (CommGroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 k))))
Case conversion may be inaccurate. Consider using '#align subgroup.closure_comm_group_of_comm Subgroup.closureCommGroupOfCommₓ'. -/
/-- If all the elements of a set `s` commute, then `closure s` is a commutative group. -/
@[to_additive
      "If all the elements of a set `s` commute, then `closure s` is an additive\ncommutative group."]
def closureCommGroupOfComm {k : Set G} (hcomm : ∀ x ∈ k, ∀ y ∈ k, x * y = y * x) :
    CommGroup (closure k) :=
  { (closure k).toGroup with
    mul_comm := fun x y => by
      ext
      simp only [Subgroup.coe_mul]
      refine'
        closure_induction₂ x.prop y.prop hcomm (fun x => by simp only [mul_one, one_mul])
          (fun x => by simp only [mul_one, one_mul])
          (fun x y z h₁ h₂ => by rw [mul_assoc, h₂, ← mul_assoc, h₁, mul_assoc])
          (fun x y z h₁ h₂ => by rw [← mul_assoc, h₁, mul_assoc, h₂, ← mul_assoc])
          (fun x y h => by
            rw [inv_mul_eq_iff_eq_mul, ← mul_assoc, h, mul_assoc, mul_inv_self, mul_one])
          fun x y h => by
          rw [mul_inv_eq_iff_eq_mul, mul_assoc, h, ← mul_assoc, inv_mul_self, one_mul] }
#align subgroup.closure_comm_group_of_comm Subgroup.closureCommGroupOfComm
#align add_subgroup.closure_add_comm_group_of_comm AddSubgroup.closureAddCommGroupOfComm

variable (G)

/- warning: subgroup.gi -> Subgroup.gi is a dubious translation:
lean 3 declaration is
  forall (G : Type.{u1}) [_inst_1 : Group.{u1} G], GaloisInsertion.{u1, u1} (Set.{u1} G) (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Set.{u1} G) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} G) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} G) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} G) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} G) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} G) (Set.completeBooleanAlgebra.{u1} G))))))) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1))) (Subgroup.closure.{u1} G _inst_1) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))))
but is expected to have type
  forall (G : Type.{u1}) [_inst_1 : Group.{u1} G], GaloisInsertion.{u1, u1} (Set.{u1} G) (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Set.{u1} G) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} G) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} G) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} G) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} G) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} G) (Set.instCompleteBooleanAlgebraSet.{u1} G))))))) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) (Subgroup.closure.{u1} G _inst_1) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1))
Case conversion may be inaccurate. Consider using '#align subgroup.gi Subgroup.giₓ'. -/
/-- `closure` forms a Galois insertion with the coercion to set. -/
@[to_additive "`closure` forms a Galois insertion with the coercion to set."]
protected def gi : GaloisInsertion (@closure G _) coe
    where
  choice s _ := closure s
  gc s t := @closure_le _ _ t s
  le_l_u s := subset_closure
  choice_eq s h := rfl
#align subgroup.gi Subgroup.gi
#align add_subgroup.gi AddSubgroup.gi

variable {G}

/- warning: subgroup.closure_mono -> Subgroup.closure_mono is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {{h : Set.{u1} G}} {{k : Set.{u1} G}}, (HasSubset.Subset.{u1} (Set.{u1} G) (Set.hasSubset.{u1} G) h k) -> (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.closure.{u1} G _inst_1 h) (Subgroup.closure.{u1} G _inst_1 k))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {{h : Set.{u1} G}} {{k : Set.{u1} G}}, (HasSubset.Subset.{u1} (Set.{u1} G) (Set.instHasSubsetSet.{u1} G) h k) -> (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (Subgroup.closure.{u1} G _inst_1 h) (Subgroup.closure.{u1} G _inst_1 k))
Case conversion may be inaccurate. Consider using '#align subgroup.closure_mono Subgroup.closure_monoₓ'. -/
/-- Subgroup closure of a set is monotone in its argument: if `h ⊆ k`,
then `closure h ≤ closure k`. -/
@[to_additive
      "Additive subgroup closure of a set is monotone in its argument: if `h ⊆ k`,\nthen `closure h ≤ closure k`"]
theorem closure_mono ⦃h k : Set G⦄ (h' : h ⊆ k) : closure h ≤ closure k :=
  (Subgroup.gi G).gc.monotone_l h'
#align subgroup.closure_mono Subgroup.closure_mono
#align add_subgroup.closure_mono AddSubgroup.closure_mono

/- warning: subgroup.closure_eq -> Subgroup.closure_eq is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (K : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.closure.{u1} G _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) K)) K
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (K : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.closure.{u1} G _inst_1 (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) K)) K
Case conversion may be inaccurate. Consider using '#align subgroup.closure_eq Subgroup.closure_eqₓ'. -/
/-- Closure of a subgroup `K` equals `K`. -/
@[simp, to_additive "Additive closure of an additive subgroup `K` equals `K`"]
theorem closure_eq : closure (K : Set G) = K :=
  (Subgroup.gi G).l_u_eq K
#align subgroup.closure_eq Subgroup.closure_eq
#align add_subgroup.closure_eq AddSubgroup.closure_eq

/- warning: subgroup.closure_empty -> Subgroup.closure_empty is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.closure.{u1} G _inst_1 (EmptyCollection.emptyCollection.{u1} (Set.{u1} G) (Set.hasEmptyc.{u1} G))) (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.closure.{u1} G _inst_1 (EmptyCollection.emptyCollection.{u1} (Set.{u1} G) (Set.instEmptyCollectionSet.{u1} G))) (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1))
Case conversion may be inaccurate. Consider using '#align subgroup.closure_empty Subgroup.closure_emptyₓ'. -/
@[simp, to_additive]
theorem closure_empty : closure (∅ : Set G) = ⊥ :=
  (Subgroup.gi G).gc.l_bot
#align subgroup.closure_empty Subgroup.closure_empty
#align add_subgroup.closure_empty AddSubgroup.closure_empty

/- warning: subgroup.closure_univ -> Subgroup.closure_univ is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.closure.{u1} G _inst_1 (Set.univ.{u1} G)) (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasTop.{u1} G _inst_1))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.closure.{u1} G _inst_1 (Set.univ.{u1} G)) (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instTopSubgroup.{u1} G _inst_1))
Case conversion may be inaccurate. Consider using '#align subgroup.closure_univ Subgroup.closure_univₓ'. -/
@[simp, to_additive]
theorem closure_univ : closure (univ : Set G) = ⊤ :=
  @coe_top G _ ▸ closure_eq ⊤
#align subgroup.closure_univ Subgroup.closure_univ
#align add_subgroup.closure_univ AddSubgroup.closure_univ

/- warning: subgroup.closure_union -> Subgroup.closure_union is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (s : Set.{u1} G) (t : Set.{u1} G), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.closure.{u1} G _inst_1 (Union.union.{u1} (Set.{u1} G) (Set.hasUnion.{u1} G) s t)) (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) (Subgroup.closure.{u1} G _inst_1 s) (Subgroup.closure.{u1} G _inst_1 t))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (s : Set.{u1} G) (t : Set.{u1} G), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.closure.{u1} G _inst_1 (Union.union.{u1} (Set.{u1} G) (Set.instUnionSet.{u1} G) s t)) (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) (Subgroup.closure.{u1} G _inst_1 s) (Subgroup.closure.{u1} G _inst_1 t))
Case conversion may be inaccurate. Consider using '#align subgroup.closure_union Subgroup.closure_unionₓ'. -/
@[to_additive]
theorem closure_union (s t : Set G) : closure (s ∪ t) = closure s ⊔ closure t :=
  (Subgroup.gi G).gc.l_sup
#align subgroup.closure_union Subgroup.closure_union
#align add_subgroup.closure_union AddSubgroup.closure_union

/- warning: subgroup.closure_Union -> Subgroup.closure_unionᵢ is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Sort.{u2}} (s : ι -> (Set.{u1} G)), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.closure.{u1} G _inst_1 (Set.unionᵢ.{u1, u2} G ι (fun (i : ι) => s i))) (supᵢ.{u1, u2} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))) ι (fun (i : ι) => Subgroup.closure.{u1} G _inst_1 (s i)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Sort.{u2}} (s : ι -> (Set.{u1} G)), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.closure.{u1} G _inst_1 (Set.unionᵢ.{u1, u2} G ι (fun (i : ι) => s i))) (supᵢ.{u1, u2} (Subgroup.{u1} G _inst_1) (CompleteLattice.toSupSet.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)) ι (fun (i : ι) => Subgroup.closure.{u1} G _inst_1 (s i)))
Case conversion may be inaccurate. Consider using '#align subgroup.closure_Union Subgroup.closure_unionᵢₓ'. -/
@[to_additive]
theorem closure_unionᵢ {ι} (s : ι → Set G) : closure (⋃ i, s i) = ⨆ i, closure (s i) :=
  (Subgroup.gi G).gc.l_supᵢ
#align subgroup.closure_Union Subgroup.closure_unionᵢ
#align add_subgroup.closure_Union AddSubgroup.closure_unionᵢ

/- warning: subgroup.closure_eq_bot_iff -> Subgroup.closure_eq_bot_iff is a dubious translation:
lean 3 declaration is
  forall (G : Type.{u1}) [_inst_4 : Group.{u1} G] (S : Set.{u1} G), Iff (Eq.{succ u1} (Subgroup.{u1} G _inst_4) (Subgroup.closure.{u1} G _inst_4 S) (Bot.bot.{u1} (Subgroup.{u1} G _inst_4) (Subgroup.hasBot.{u1} G _inst_4))) (HasSubset.Subset.{u1} (Set.{u1} G) (Set.hasSubset.{u1} G) S (Singleton.singleton.{u1, u1} G (Set.{u1} G) (Set.hasSingleton.{u1} G) (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_4)))))))))
but is expected to have type
  forall (G : Type.{u1}) [_inst_4 : Group.{u1} G] (S : Set.{u1} G), Iff (Eq.{succ u1} (Subgroup.{u1} G _inst_4) (Subgroup.closure.{u1} G _inst_4 S) (Bot.bot.{u1} (Subgroup.{u1} G _inst_4) (Subgroup.instBotSubgroup.{u1} G _inst_4))) (HasSubset.Subset.{u1} (Set.{u1} G) (Set.instHasSubsetSet.{u1} G) S (Singleton.singleton.{u1, u1} G (Set.{u1} G) (Set.instSingletonSet.{u1} G) (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_4))))))))
Case conversion may be inaccurate. Consider using '#align subgroup.closure_eq_bot_iff Subgroup.closure_eq_bot_iffₓ'. -/
@[to_additive]
theorem closure_eq_bot_iff (G : Type _) [Group G] (S : Set G) : closure S = ⊥ ↔ S ⊆ {1} :=
  by
  rw [← le_bot_iff]
  exact closure_le _
#align subgroup.closure_eq_bot_iff Subgroup.closure_eq_bot_iff
#align add_subgroup.closure_eq_bot_iff AddSubgroup.closure_eq_bot_iff

/- warning: subgroup.supr_eq_closure -> Subgroup.supᵢ_eq_closure is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Sort.{u2}} (p : ι -> (Subgroup.{u1} G _inst_1)), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (supᵢ.{u1, u2} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))) ι (fun (i : ι) => p i)) (Subgroup.closure.{u1} G _inst_1 (Set.unionᵢ.{u1, u2} G ι (fun (i : ι) => (fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (p i))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Sort.{u2}} (p : ι -> (Subgroup.{u1} G _inst_1)), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (supᵢ.{u1, u2} (Subgroup.{u1} G _inst_1) (CompleteLattice.toSupSet.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)) ι (fun (i : ι) => p i)) (Subgroup.closure.{u1} G _inst_1 (Set.unionᵢ.{u1, u2} G ι (fun (i : ι) => SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (p i))))
Case conversion may be inaccurate. Consider using '#align subgroup.supr_eq_closure Subgroup.supᵢ_eq_closureₓ'. -/
@[to_additive]
theorem supᵢ_eq_closure {ι : Sort _} (p : ι → Subgroup G) :
    (⨆ i, p i) = closure (⋃ i, (p i : Set G)) := by simp_rw [closure_unionᵢ, closure_eq]
#align subgroup.supr_eq_closure Subgroup.supᵢ_eq_closure
#align add_subgroup.supr_eq_closure AddSubgroup.supᵢ_eq_closure

/- warning: subgroup.mem_closure_singleton -> Subgroup.mem_closure_singleton is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {x : G} {y : G}, Iff (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) y (Subgroup.closure.{u1} G _inst_1 (Singleton.singleton.{u1, u1} G (Set.{u1} G) (Set.hasSingleton.{u1} G) x))) (Exists.{1} Int (fun (n : Int) => Eq.{succ u1} G (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) x n) y))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {x : G} {y : G}, Iff (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) y (Subgroup.closure.{u1} G _inst_1 (Singleton.singleton.{u1, u1} G (Set.{u1} G) (Set.instSingletonSet.{u1} G) x))) (Exists.{1} Int (fun (n : Int) => Eq.{succ u1} G (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) x n) y))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_closure_singleton Subgroup.mem_closure_singletonₓ'. -/
/-- The subgroup generated by an element of a group equals the set of integer number powers of
    the element. -/
@[to_additive
      "The `add_subgroup` generated by an element of an `add_group` equals the set of\nnatural number multiples of the element."]
theorem mem_closure_singleton {x y : G} : y ∈ closure ({x} : Set G) ↔ ∃ n : ℤ, x ^ n = y :=
  by
  refine'
    ⟨fun hy => closure_induction hy _ _ _ _, fun ⟨n, hn⟩ =>
      hn ▸ zpow_mem (subset_closure <| mem_singleton x) n⟩
  · intro y hy
    rw [eq_of_mem_singleton hy]
    exact ⟨1, zpow_one x⟩
  · exact ⟨0, zpow_zero x⟩
  · rintro _ _ ⟨n, rfl⟩ ⟨m, rfl⟩
    exact ⟨n + m, zpow_add x n m⟩
  rintro _ ⟨n, rfl⟩
  exact ⟨-n, zpow_neg x n⟩
#align subgroup.mem_closure_singleton Subgroup.mem_closure_singleton
#align add_subgroup.mem_closure_singleton AddSubgroup.mem_closure_singleton

/- warning: subgroup.closure_singleton_one -> Subgroup.closure_singleton_one is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.closure.{u1} G _inst_1 (Singleton.singleton.{u1, u1} G (Set.{u1} G) (Set.hasSingleton.{u1} G) (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))) (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.closure.{u1} G _inst_1 (Singleton.singleton.{u1, u1} G (Set.{u1} G) (Set.instSingletonSet.{u1} G) (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))))))) (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1))
Case conversion may be inaccurate. Consider using '#align subgroup.closure_singleton_one Subgroup.closure_singleton_oneₓ'. -/
@[to_additive]
theorem closure_singleton_one : closure ({1} : Set G) = ⊥ := by
  simp [eq_bot_iff_forall, mem_closure_singleton]
#align subgroup.closure_singleton_one Subgroup.closure_singleton_one
#align add_subgroup.closure_singleton_zero AddSubgroup.closure_singleton_zero

/- warning: subgroup.le_closure_to_submonoid -> Subgroup.le_closure_toSubmonoid is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (S : Set.{u1} G), LE.le.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Preorder.toLE.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (SetLike.partialOrder.{u1, u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) G (Submonoid.setLike.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) (Submonoid.closure.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) S) (Subgroup.toSubmonoid.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 S))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (S : Set.{u1} G), LE.le.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Preorder.toLE.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Submonoid.instCompleteLatticeSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))) (Submonoid.closure.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) S) (Subgroup.toSubmonoid.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 S))
Case conversion may be inaccurate. Consider using '#align subgroup.le_closure_to_submonoid Subgroup.le_closure_toSubmonoidₓ'. -/
@[to_additive]
theorem le_closure_toSubmonoid (S : Set G) : Submonoid.closure S ≤ (closure S).toSubmonoid :=
  Submonoid.closure_le.2 subset_closure
#align subgroup.le_closure_to_submonoid Subgroup.le_closure_toSubmonoid
#align add_subgroup.le_closure_to_add_submonoid AddSubgroup.le_closure_toAddSubmonoid

/- warning: subgroup.closure_eq_top_of_mclosure_eq_top -> Subgroup.closure_eq_top_of_mclosure_eq_top is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Set.{u1} G}, (Eq.{succ u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Submonoid.closure.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) S) (Top.top.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Submonoid.hasTop.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) -> (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.closure.{u1} G _inst_1 S) (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasTop.{u1} G _inst_1)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {S : Set.{u1} G}, (Eq.{succ u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Submonoid.closure.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) S) (Top.top.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Submonoid.instTopSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) -> (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.closure.{u1} G _inst_1 S) (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instTopSubgroup.{u1} G _inst_1)))
Case conversion may be inaccurate. Consider using '#align subgroup.closure_eq_top_of_mclosure_eq_top Subgroup.closure_eq_top_of_mclosure_eq_topₓ'. -/
@[to_additive]
theorem closure_eq_top_of_mclosure_eq_top {S : Set G} (h : Submonoid.closure S = ⊤) :
    closure S = ⊤ :=
  (eq_top_iff' _).2 fun x => le_closure_toSubmonoid _ <| h.symm ▸ trivial
#align subgroup.closure_eq_top_of_mclosure_eq_top Subgroup.closure_eq_top_of_mclosure_eq_top
#align add_subgroup.closure_eq_top_of_mclosure_eq_top AddSubgroup.closure_eq_top_of_mclosure_eq_top

/- warning: subgroup.mem_supr_of_directed -> Subgroup.mem_supᵢ_of_directed is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Sort.{u2}} [hι : Nonempty.{u2} ι] {K : ι -> (Subgroup.{u1} G _inst_1)}, (Directed.{u1, u2} (Subgroup.{u1} G _inst_1) ι (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1))))) K) -> (forall {x : G}, Iff (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (supᵢ.{u1, u2} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))) ι K)) (Exists.{u2} ι (fun (i : ι) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (K i))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Sort.{u2}} [hι : Nonempty.{u2} ι] {K : ι -> (Subgroup.{u1} G _inst_1)}, (Directed.{u1, u2} (Subgroup.{u1} G _inst_1) ι (fun (x._@.Mathlib.GroupTheory.Subgroup.Basic._hyg.10292 : Subgroup.{u1} G _inst_1) (x._@.Mathlib.GroupTheory.Subgroup.Basic._hyg.10294 : Subgroup.{u1} G _inst_1) => LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) x._@.Mathlib.GroupTheory.Subgroup.Basic._hyg.10292 x._@.Mathlib.GroupTheory.Subgroup.Basic._hyg.10294) K) -> (forall {x : G}, Iff (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (supᵢ.{u1, u2} (Subgroup.{u1} G _inst_1) (CompleteLattice.toSupSet.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)) ι K)) (Exists.{u2} ι (fun (i : ι) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (K i))))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_supr_of_directed Subgroup.mem_supᵢ_of_directedₓ'. -/
@[to_additive]
theorem mem_supᵢ_of_directed {ι} [hι : Nonempty ι] {K : ι → Subgroup G} (hK : Directed (· ≤ ·) K)
    {x : G} : x ∈ (supᵢ K : Subgroup G) ↔ ∃ i, x ∈ K i :=
  by
  refine' ⟨_, fun ⟨i, hi⟩ => (SetLike.le_def.1 <| le_supᵢ K i) hi⟩
  suffices x ∈ closure (⋃ i, (K i : Set G)) → ∃ i, x ∈ K i by
    simpa only [closure_unionᵢ, closure_eq (K _)] using this
  refine' fun hx => closure_induction hx (fun _ => mem_Union.1) _ _ _
  · exact hι.elim fun i => ⟨i, (K i).one_mem⟩
  · rintro x y ⟨i, hi⟩ ⟨j, hj⟩
    rcases hK i j with ⟨k, hki, hkj⟩
    exact ⟨k, mul_mem (hki hi) (hkj hj)⟩
  rintro _ ⟨i, hi⟩
  exact ⟨i, inv_mem hi⟩
#align subgroup.mem_supr_of_directed Subgroup.mem_supᵢ_of_directed
#align add_subgroup.mem_supr_of_directed AddSubgroup.mem_supᵢ_of_directed

/- warning: subgroup.coe_supr_of_directed -> Subgroup.coe_supᵢ_of_directed is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Sort.{u2}} [_inst_4 : Nonempty.{u2} ι] {S : ι -> (Subgroup.{u1} G _inst_1)}, (Directed.{u1, u2} (Subgroup.{u1} G _inst_1) ι (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1))))) S) -> (Eq.{succ u1} (Set.{u1} G) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (supᵢ.{u1, u2} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))) ι (fun (i : ι) => S i))) (Set.unionᵢ.{u1, u2} G ι (fun (i : ι) => (fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (S i))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Sort.{u2}} [_inst_4 : Nonempty.{u2} ι] {S : ι -> (Subgroup.{u1} G _inst_1)}, (Directed.{u1, u2} (Subgroup.{u1} G _inst_1) ι (fun (x._@.Mathlib.GroupTheory.Subgroup.Basic._hyg.10541 : Subgroup.{u1} G _inst_1) (x._@.Mathlib.GroupTheory.Subgroup.Basic._hyg.10543 : Subgroup.{u1} G _inst_1) => LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) x._@.Mathlib.GroupTheory.Subgroup.Basic._hyg.10541 x._@.Mathlib.GroupTheory.Subgroup.Basic._hyg.10543) S) -> (Eq.{succ u1} (Set.{u1} G) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (supᵢ.{u1, u2} (Subgroup.{u1} G _inst_1) (CompleteLattice.toSupSet.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)) ι (fun (i : ι) => S i))) (Set.unionᵢ.{u1, u2} G ι (fun (i : ι) => SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (S i))))
Case conversion may be inaccurate. Consider using '#align subgroup.coe_supr_of_directed Subgroup.coe_supᵢ_of_directedₓ'. -/
@[to_additive]
theorem coe_supᵢ_of_directed {ι} [Nonempty ι] {S : ι → Subgroup G} (hS : Directed (· ≤ ·) S) :
    ((⨆ i, S i : Subgroup G) : Set G) = ⋃ i, ↑(S i) :=
  Set.ext fun x => by simp [mem_supr_of_directed hS]
#align subgroup.coe_supr_of_directed Subgroup.coe_supᵢ_of_directed
#align add_subgroup.coe_supr_of_directed AddSubgroup.coe_supᵢ_of_directed

/- warning: subgroup.mem_Sup_of_directed_on -> Subgroup.mem_supₛ_of_directedOn is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {K : Set.{u1} (Subgroup.{u1} G _inst_1)}, (Set.Nonempty.{u1} (Subgroup.{u1} G _inst_1) K) -> (DirectedOn.{u1} (Subgroup.{u1} G _inst_1) (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1))))) K) -> (forall {x : G}, Iff (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (SupSet.supₛ.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))) K)) (Exists.{succ u1} (Subgroup.{u1} G _inst_1) (fun (s : Subgroup.{u1} G _inst_1) => Exists.{0} (Membership.Mem.{u1, u1} (Subgroup.{u1} G _inst_1) (Set.{u1} (Subgroup.{u1} G _inst_1)) (Set.hasMem.{u1} (Subgroup.{u1} G _inst_1)) s K) (fun (H : Membership.Mem.{u1, u1} (Subgroup.{u1} G _inst_1) (Set.{u1} (Subgroup.{u1} G _inst_1)) (Set.hasMem.{u1} (Subgroup.{u1} G _inst_1)) s K) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x s))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {K : Set.{u1} (Subgroup.{u1} G _inst_1)}, (Set.Nonempty.{u1} (Subgroup.{u1} G _inst_1) K) -> (DirectedOn.{u1} (Subgroup.{u1} G _inst_1) (fun (x._@.Mathlib.GroupTheory.Subgroup.Basic._hyg.10643 : Subgroup.{u1} G _inst_1) (x._@.Mathlib.GroupTheory.Subgroup.Basic._hyg.10645 : Subgroup.{u1} G _inst_1) => LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) x._@.Mathlib.GroupTheory.Subgroup.Basic._hyg.10643 x._@.Mathlib.GroupTheory.Subgroup.Basic._hyg.10645) K) -> (forall {x : G}, Iff (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (SupSet.supₛ.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toSupSet.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)) K)) (Exists.{succ u1} (Subgroup.{u1} G _inst_1) (fun (s : Subgroup.{u1} G _inst_1) => And (Membership.mem.{u1, u1} (Subgroup.{u1} G _inst_1) (Set.{u1} (Subgroup.{u1} G _inst_1)) (Set.instMembershipSet.{u1} (Subgroup.{u1} G _inst_1)) s K) (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x s))))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_Sup_of_directed_on Subgroup.mem_supₛ_of_directedOnₓ'. -/
@[to_additive]
theorem mem_supₛ_of_directedOn {K : Set (Subgroup G)} (Kne : K.Nonempty) (hK : DirectedOn (· ≤ ·) K)
    {x : G} : x ∈ supₛ K ↔ ∃ s ∈ K, x ∈ s :=
  by
  haveI : Nonempty K := Kne.to_subtype
  simp only [supₛ_eq_supᵢ', mem_supr_of_directed hK.directed_coe, SetCoe.exists, Subtype.coe_mk]
#align subgroup.mem_Sup_of_directed_on Subgroup.mem_supₛ_of_directedOn
#align add_subgroup.mem_Sup_of_directed_on AddSubgroup.mem_supₛ_of_directedOn

variable {N : Type _} [Group N] {P : Type _} [Group P]

#print Subgroup.comap /-
/-- The preimage of a subgroup along a monoid homomorphism is a subgroup. -/
@[to_additive
      "The preimage of an `add_subgroup` along an `add_monoid` homomorphism\nis an `add_subgroup`."]
def comap {N : Type _} [Group N] (f : G →* N) (H : Subgroup N) : Subgroup G :=
  { H.toSubmonoid.comap f with
    carrier := f ⁻¹' H
    inv_mem' := fun a ha => show f a⁻¹ ∈ H by rw [f.map_inv] <;> exact H.inv_mem ha }
#align subgroup.comap Subgroup.comap
#align add_subgroup.comap AddSubgroup.comap
-/

/- warning: subgroup.coe_comap -> Subgroup.coe_comap is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (K : Subgroup.{u2} N _inst_4) (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), Eq.{succ u1} (Set.{u1} G) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f K)) (Set.preimage.{u1, u2} G N (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Subgroup.{u2} N _inst_4) (Set.{u2} N) (HasLiftT.mk.{succ u2, succ u2} (Subgroup.{u2} N _inst_4) (Set.{u2} N) (CoeTCₓ.coe.{succ u2, succ u2} (Subgroup.{u2} N _inst_4) (Set.{u2} N) (SetLike.Set.hasCoeT.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)))) K))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (K : Subgroup.{u2} N _inst_4) (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), Eq.{succ u1} (Set.{u1} G) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f K)) (Set.preimage.{u1, u2} G N (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) G N (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (MonoidHom.monoidHomClass.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))))) f) (SetLike.coe.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u2} N _inst_4) K))
Case conversion may be inaccurate. Consider using '#align subgroup.coe_comap Subgroup.coe_comapₓ'. -/
@[simp, to_additive]
theorem coe_comap (K : Subgroup N) (f : G →* N) : (K.comap f : Set G) = f ⁻¹' K :=
  rfl
#align subgroup.coe_comap Subgroup.coe_comap
#align add_subgroup.coe_comap AddSubgroup.coe_comap

/- warning: subgroup.mem_comap -> Subgroup.mem_comap is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {K : Subgroup.{u2} N _inst_4} {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))} {x : G}, Iff (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f K)) (Membership.Mem.{u2, u2} N (Subgroup.{u2} N _inst_4) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f x) K)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {K : Subgroup.{u2} N _inst_4} {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))} {x : G}, Iff (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f K)) (Membership.mem.{u2, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) x) (Subgroup.{u2} N _inst_4) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u2} N _inst_4)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) G N (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (MonoidHom.monoidHomClass.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))))) f x) K)
Case conversion may be inaccurate. Consider using '#align subgroup.mem_comap Subgroup.mem_comapₓ'. -/
@[simp, to_additive]
theorem mem_comap {K : Subgroup N} {f : G →* N} {x : G} : x ∈ K.comap f ↔ f x ∈ K :=
  Iff.rfl
#align subgroup.mem_comap Subgroup.mem_comap
#align add_subgroup.mem_comap AddSubgroup.mem_comap

/- warning: subgroup.comap_mono -> Subgroup.comap_mono is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))} {K : Subgroup.{u2} N _inst_4} {K' : Subgroup.{u2} N _inst_4}, (LE.le.{u2} (Subgroup.{u2} N _inst_4) (Preorder.toLE.{u2} (Subgroup.{u2} N _inst_4) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} N _inst_4) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)))) K K') -> (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f K) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f K'))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))} {K : Subgroup.{u1} N _inst_4} {K' : Subgroup.{u1} N _inst_4}, (LE.le.{u1} (Subgroup.{u1} N _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} N _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} N _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} N _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u1} N _inst_4))))) K K') -> (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))))) (Subgroup.comap.{u2, u1} G _inst_1 N _inst_4 f K) (Subgroup.comap.{u2, u1} G _inst_1 N _inst_4 f K'))
Case conversion may be inaccurate. Consider using '#align subgroup.comap_mono Subgroup.comap_monoₓ'. -/
@[to_additive]
theorem comap_mono {f : G →* N} {K K' : Subgroup N} : K ≤ K' → comap f K ≤ comap f K' :=
  preimage_mono
#align subgroup.comap_mono Subgroup.comap_mono
#align add_subgroup.comap_mono AddSubgroup.comap_mono

#print Subgroup.comap_comap /-
@[to_additive]
theorem comap_comap (K : Subgroup P) (g : N →* P) (f : G →* N) :
    (K.comap g).comap f = K.comap (g.comp f) :=
  rfl
#align subgroup.comap_comap Subgroup.comap_comap
#align add_subgroup.comap_comap AddSubgroup.comap_comap
-/

#print Subgroup.comap_id /-
@[simp, to_additive]
theorem comap_id (K : Subgroup N) : K.comap (MonoidHom.id _) = K :=
  by
  ext
  rfl
#align subgroup.comap_id Subgroup.comap_id
#align add_subgroup.comap_id AddSubgroup.comap_id
-/

#print Subgroup.map /-
/-- The image of a subgroup along a monoid homomorphism is a subgroup. -/
@[to_additive
      "The image of an `add_subgroup` along an `add_monoid` homomorphism\nis an `add_subgroup`."]
def map (f : G →* N) (H : Subgroup G) : Subgroup N :=
  { H.toSubmonoid.map f with
    carrier := f '' H
    inv_mem' := by
      rintro _ ⟨x, hx, rfl⟩
      exact ⟨x⁻¹, H.inv_mem hx, f.map_inv x⟩ }
#align subgroup.map Subgroup.map
#align add_subgroup.map AddSubgroup.map
-/

/- warning: subgroup.coe_map -> Subgroup.coe_map is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (K : Subgroup.{u1} G _inst_1), Eq.{succ u2} (Set.{u2} N) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Subgroup.{u2} N _inst_4) (Set.{u2} N) (HasLiftT.mk.{succ u2, succ u2} (Subgroup.{u2} N _inst_4) (Set.{u2} N) (CoeTCₓ.coe.{succ u2, succ u2} (Subgroup.{u2} N _inst_4) (Set.{u2} N) (SetLike.Set.hasCoeT.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)))) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f K)) (Set.image.{u1, u2} G N (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) K))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (K : Subgroup.{u2} G _inst_1), Eq.{succ u1} (Set.{u1} N) (SetLike.coe.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f K)) (Set.image.{u2, u1} G N (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f) (SetLike.coe.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1) K))
Case conversion may be inaccurate. Consider using '#align subgroup.coe_map Subgroup.coe_mapₓ'. -/
@[simp, to_additive]
theorem coe_map (f : G →* N) (K : Subgroup G) : (K.map f : Set N) = f '' K :=
  rfl
#align subgroup.coe_map Subgroup.coe_map
#align add_subgroup.coe_map AddSubgroup.coe_map

/- warning: subgroup.mem_map -> Subgroup.mem_map is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))} {K : Subgroup.{u1} G _inst_1} {y : N}, Iff (Membership.Mem.{u2, u2} N (Subgroup.{u2} N _inst_4) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) y (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f K)) (Exists.{succ u1} G (fun (x : G) => Exists.{0} (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x K) (fun (H : Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x K) => Eq.{succ u2} N (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f x) y)))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))} {K : Subgroup.{u2} G _inst_1} {y : N}, Iff (Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) y (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f K)) (Exists.{succ u2} G (fun (x : G) => And (Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x K) (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (a : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f x) y)))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_map Subgroup.mem_mapₓ'. -/
@[simp, to_additive]
theorem mem_map {f : G →* N} {K : Subgroup G} {y : N} : y ∈ K.map f ↔ ∃ x ∈ K, f x = y :=
  mem_image_iff_bex
#align subgroup.mem_map Subgroup.mem_map
#align add_subgroup.mem_map AddSubgroup.mem_map

/- warning: subgroup.mem_map_of_mem -> Subgroup.mem_map_of_mem is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) {K : Subgroup.{u1} G _inst_1} {x : G}, (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x K) -> (Membership.Mem.{u2, u2} N (Subgroup.{u2} N _inst_4) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f x) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f K))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) {K : Subgroup.{u2} G _inst_1} {x : G}, (Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x K) -> (Membership.mem.{u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) x) (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f x) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f K))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_map_of_mem Subgroup.mem_map_of_memₓ'. -/
@[to_additive]
theorem mem_map_of_mem (f : G →* N) {K : Subgroup G} {x : G} (hx : x ∈ K) : f x ∈ K.map f :=
  mem_image_of_mem f hx
#align subgroup.mem_map_of_mem Subgroup.mem_map_of_mem
#align add_subgroup.mem_map_of_mem AddSubgroup.mem_map_of_mem

/- warning: subgroup.apply_coe_mem_map -> Subgroup.apply_coe_mem_map is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (K : Subgroup.{u1} G _inst_1) (x : coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K), Membership.Mem.{u2, u2} N (Subgroup.{u2} N _inst_4) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) G (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x K))))) x)) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f K)
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (K : Subgroup.{u2} G _inst_1) (x : Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x K)), Membership.mem.{u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) (Subtype.val.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Set.{u2} G) (Set.instMembershipSet.{u2} G) x (SetLike.coe.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1) K)) x)) (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f (Subtype.val.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Set.{u2} G) (Set.instMembershipSet.{u2} G) x (SetLike.coe.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1) K)) x)) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f K)
Case conversion may be inaccurate. Consider using '#align subgroup.apply_coe_mem_map Subgroup.apply_coe_mem_mapₓ'. -/
@[to_additive]
theorem apply_coe_mem_map (f : G →* N) (K : Subgroup G) (x : K) : f x ∈ K.map f :=
  mem_map_of_mem f x.Prop
#align subgroup.apply_coe_mem_map Subgroup.apply_coe_mem_map
#align add_subgroup.apply_coe_mem_map AddSubgroup.apply_coe_mem_map

/- warning: subgroup.map_mono -> Subgroup.map_mono is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))} {K : Subgroup.{u1} G _inst_1} {K' : Subgroup.{u1} G _inst_1}, (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) K K') -> (LE.le.{u2} (Subgroup.{u2} N _inst_4) (Preorder.toLE.{u2} (Subgroup.{u2} N _inst_4) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} N _inst_4) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)))) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f K) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f K'))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))} {K : Subgroup.{u2} G _inst_1} {K' : Subgroup.{u2} G _inst_1}, (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))))) K K') -> (LE.le.{u1} (Subgroup.{u1} N _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} N _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} N _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} N _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u1} N _inst_4))))) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f K) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f K'))
Case conversion may be inaccurate. Consider using '#align subgroup.map_mono Subgroup.map_monoₓ'. -/
@[to_additive]
theorem map_mono {f : G →* N} {K K' : Subgroup G} : K ≤ K' → map f K ≤ map f K' :=
  image_subset _
#align subgroup.map_mono Subgroup.map_mono
#align add_subgroup.map_mono AddSubgroup.map_mono

#print Subgroup.map_id /-
@[simp, to_additive]
theorem map_id : K.map (MonoidHom.id G) = K :=
  SetLike.coe_injective <| image_id _
#align subgroup.map_id Subgroup.map_id
#align add_subgroup.map_id AddSubgroup.map_id
-/

/- warning: subgroup.map_map -> Subgroup.map_map is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (K : Subgroup.{u1} G _inst_1) {N : Type.{u2}} [_inst_4 : Group.{u2} N] {P : Type.{u3}} [_inst_5 : Group.{u3} P] (g : MonoidHom.{u2, u3} N P (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u3} P (DivInvMonoid.toMonoid.{u3} P (Group.toDivInvMonoid.{u3} P _inst_5)))) (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), Eq.{succ u3} (Subgroup.{u3} P _inst_5) (Subgroup.map.{u2, u3} N _inst_4 P _inst_5 g (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f K)) (Subgroup.map.{u1, u3} G _inst_1 P _inst_5 (MonoidHom.comp.{u1, u2, u3} G N P (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u3} P (DivInvMonoid.toMonoid.{u3} P (Group.toDivInvMonoid.{u3} P _inst_5))) g f) K)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (K : Subgroup.{u1} G _inst_1) {N : Type.{u3}} [_inst_4 : Group.{u3} N] {P : Type.{u2}} [_inst_5 : Group.{u2} P] (g : MonoidHom.{u3, u2} N P (Monoid.toMulOneClass.{u3} N (DivInvMonoid.toMonoid.{u3} N (Group.toDivInvMonoid.{u3} N _inst_4))) (Monoid.toMulOneClass.{u2} P (DivInvMonoid.toMonoid.{u2} P (Group.toDivInvMonoid.{u2} P _inst_5)))) (f : MonoidHom.{u1, u3} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u3} N (DivInvMonoid.toMonoid.{u3} N (Group.toDivInvMonoid.{u3} N _inst_4)))), Eq.{succ u2} (Subgroup.{u2} P _inst_5) (Subgroup.map.{u3, u2} N _inst_4 P _inst_5 g (Subgroup.map.{u1, u3} G _inst_1 N _inst_4 f K)) (Subgroup.map.{u1, u2} G _inst_1 P _inst_5 (MonoidHom.comp.{u1, u3, u2} G N P (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u3} N (DivInvMonoid.toMonoid.{u3} N (Group.toDivInvMonoid.{u3} N _inst_4))) (Monoid.toMulOneClass.{u2} P (DivInvMonoid.toMonoid.{u2} P (Group.toDivInvMonoid.{u2} P _inst_5))) g f) K)
Case conversion may be inaccurate. Consider using '#align subgroup.map_map Subgroup.map_mapₓ'. -/
@[to_additive]
theorem map_map (g : N →* P) (f : G →* N) : (K.map f).map g = K.map (g.comp f) :=
  SetLike.coe_injective <| image_image _ _ _
#align subgroup.map_map Subgroup.map_map
#align add_subgroup.map_map AddSubgroup.map_map

/- warning: subgroup.map_one_eq_bot -> Subgroup.map_one_eq_bot is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (K : Subgroup.{u1} G _inst_1) {N : Type.{u2}} [_inst_4 : Group.{u2} N], Eq.{succ u2} (Subgroup.{u2} N _inst_4) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 (OfNat.ofNat.{max u2 u1} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) 1 (OfNat.mk.{max u2 u1} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) 1 (One.one.{max u2 u1} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (MonoidHom.hasOne.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))))))) K) (Bot.bot.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.hasBot.{u2} N _inst_4))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (K : Subgroup.{u1} G _inst_1) {N : Type.{u2}} [_inst_4 : Group.{u2} N], Eq.{succ u2} (Subgroup.{u2} N _inst_4) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 (OfNat.ofNat.{max u1 u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) 1 (One.toOfNat1.{max u1 u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (instOneMonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))))) K) (Bot.bot.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.instBotSubgroup.{u2} N _inst_4))
Case conversion may be inaccurate. Consider using '#align subgroup.map_one_eq_bot Subgroup.map_one_eq_botₓ'. -/
@[simp, to_additive]
theorem map_one_eq_bot : K.map (1 : G →* N) = ⊥ :=
  eq_bot_iff.mpr <| by
    rintro x ⟨y, _, rfl⟩
    simp
#align subgroup.map_one_eq_bot Subgroup.map_one_eq_bot
#align add_subgroup.map_zero_eq_bot AddSubgroup.map_zero_eq_bot

/- warning: subgroup.mem_map_equiv -> Subgroup.mem_map_equiv is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {f : MulEquiv.{u1, u2} G N (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))))} {K : Subgroup.{u1} G _inst_1} {x : N}, Iff (Membership.Mem.{u2, u2} N (Subgroup.{u2} N _inst_4) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) x (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 (MulEquiv.toMonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) f) K)) (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (MulEquiv.{u2, u1} N G (MulOneClass.toHasMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (fun (_x : MulEquiv.{u2, u1} N G (MulOneClass.toHasMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) => N -> G) (MulEquiv.hasCoeToFun.{u2, u1} N G (MulOneClass.toHasMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulEquiv.symm.{u1, u2} G N (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f) x) K)
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {f : MulEquiv.{u2, u1} G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))))} {K : Subgroup.{u2} G _inst_1} {x : N}, Iff (Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 (MulEquiv.toMonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) f) K)) (Membership.mem.{u2, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : N) => G) x) (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (MulEquiv.{u1, u2} N G (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) N (fun (_x : N) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : N) => G) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (MulEquiv.{u1, u2} N G (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) N G (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u1, u2} (MulEquiv.{u1, u2} N G (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u1, u2} (MulEquiv.{u1, u2} N G (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (MulEquiv.instMulEquivClassMulEquiv.{u1, u2} N G (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))))) (MulEquiv.symm.{u2, u1} G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) f) x) K)
Case conversion may be inaccurate. Consider using '#align subgroup.mem_map_equiv Subgroup.mem_map_equivₓ'. -/
@[to_additive]
theorem mem_map_equiv {f : G ≃* N} {K : Subgroup G} {x : N} :
    x ∈ K.map f.toMonoidHom ↔ f.symm x ∈ K :=
  @Set.mem_image_equiv _ _ (↑K) f.toEquiv x
#align subgroup.mem_map_equiv Subgroup.mem_map_equiv
#align add_subgroup.mem_map_equiv AddSubgroup.mem_map_equiv

/- warning: subgroup.mem_map_iff_mem -> Subgroup.mem_map_iff_mem is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))}, (Function.Injective.{succ u1, succ u2} G N (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f)) -> (forall {K : Subgroup.{u1} G _inst_1} {x : G}, Iff (Membership.Mem.{u2, u2} N (Subgroup.{u2} N _inst_4) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f x) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f K)) (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x K))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))}, (Function.Injective.{succ u2, succ u1} G N (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f)) -> (forall {K : Subgroup.{u2} G _inst_1} {x : G}, Iff (Membership.mem.{u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) x) (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f x) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f K)) (Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x K))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_map_iff_mem Subgroup.mem_map_iff_memₓ'. -/
@[to_additive]
theorem mem_map_iff_mem {f : G →* N} (hf : Function.Injective f) {K : Subgroup G} {x : G} :
    f x ∈ K.map f ↔ x ∈ K :=
  hf.mem_set_image
#align subgroup.mem_map_iff_mem Subgroup.mem_map_iff_mem
#align add_subgroup.mem_map_iff_mem AddSubgroup.mem_map_iff_mem

/- warning: subgroup.map_equiv_eq_comap_symm -> Subgroup.map_equiv_eq_comap_symm is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MulEquiv.{u1, u2} G N (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))))) (K : Subgroup.{u1} G _inst_1), Eq.{succ u2} (Subgroup.{u2} N _inst_4) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 (MulEquiv.toMonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) f) K) (Subgroup.comap.{u2, u1} N _inst_4 G _inst_1 (MulEquiv.toMonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (MulEquiv.symm.{u1, u2} G N (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f)) K)
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (f : MulEquiv.{u2, u1} G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))))) (K : Subgroup.{u2} G _inst_1), Eq.{succ u1} (Subgroup.{u1} N _inst_4) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 (MulEquiv.toMonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) f) K) (Subgroup.comap.{u1, u2} N _inst_4 G _inst_1 (MulEquiv.toMonoidHom.{u1, u2} N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (MulEquiv.symm.{u2, u1} G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) f)) K)
Case conversion may be inaccurate. Consider using '#align subgroup.map_equiv_eq_comap_symm Subgroup.map_equiv_eq_comap_symmₓ'. -/
@[to_additive]
theorem map_equiv_eq_comap_symm (f : G ≃* N) (K : Subgroup G) :
    K.map f.toMonoidHom = K.comap f.symm.toMonoidHom :=
  SetLike.coe_injective (f.toEquiv.image_eq_preimage K)
#align subgroup.map_equiv_eq_comap_symm Subgroup.map_equiv_eq_comap_symm
#align add_subgroup.map_equiv_eq_comap_symm AddSubgroup.map_equiv_eq_comap_symm

/- warning: subgroup.comap_equiv_eq_map_symm -> Subgroup.comap_equiv_eq_map_symm is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MulEquiv.{u2, u1} N G (MulOneClass.toHasMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (K : Subgroup.{u1} G _inst_1), Eq.{succ u2} (Subgroup.{u2} N _inst_4) (Subgroup.comap.{u2, u1} N _inst_4 G _inst_1 (MulEquiv.toMonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) f) K) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 (MulEquiv.toMonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (MulEquiv.symm.{u2, u1} N G (MulOneClass.toHasMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) f)) K)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MulEquiv.{u2, u1} N G (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (K : Subgroup.{u1} G _inst_1), Eq.{succ u2} (Subgroup.{u2} N _inst_4) (Subgroup.comap.{u2, u1} N _inst_4 G _inst_1 (MulEquiv.toMonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) f) K) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 (MulEquiv.toMonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (MulEquiv.symm.{u2, u1} N G (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) f)) K)
Case conversion may be inaccurate. Consider using '#align subgroup.comap_equiv_eq_map_symm Subgroup.comap_equiv_eq_map_symmₓ'. -/
@[to_additive]
theorem comap_equiv_eq_map_symm (f : N ≃* G) (K : Subgroup G) :
    K.comap f.toMonoidHom = K.map f.symm.toMonoidHom :=
  (map_equiv_eq_comap_symm f.symm K).symm
#align subgroup.comap_equiv_eq_map_symm Subgroup.comap_equiv_eq_map_symm
#align add_subgroup.comap_equiv_eq_map_symm AddSubgroup.comap_equiv_eq_map_symm

/- warning: subgroup.map_symm_eq_iff_map_eq -> Subgroup.map_symm_eq_iff_map_eq is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (K : Subgroup.{u1} G _inst_1) {N : Type.{u2}} [_inst_4 : Group.{u2} N] {H : Subgroup.{u2} N _inst_4} {e : MulEquiv.{u1, u2} G N (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))))}, Iff (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.map.{u2, u1} N _inst_4 G _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u2) (succ u1), max (succ u1) (succ u2)} a b] => self.0) (MulEquiv.{u2, u1} N G (MulOneClass.toHasMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (HasLiftT.mk.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MulEquiv.{u2, u1} N G (MulOneClass.toHasMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (CoeTCₓ.coe.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MulEquiv.{u2, u1} N G (MulOneClass.toHasMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MonoidHom.hasCoeT.{u2, u1, max u2 u1} N G (MulEquiv.{u2, u1} N G (MulOneClass.toHasMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (MulEquivClass.monoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} N G (MulOneClass.toHasMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (MulEquiv.mulEquivClass.{u2, u1} N G (MulOneClass.toHasMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))) (MulEquiv.symm.{u1, u2} G N (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) e)) H) K) (Eq.{succ u2} (Subgroup.{u2} N _inst_4) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G N (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))))) (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G N (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))))) (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G N (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))))) (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G N (MulEquiv.{u1, u2} G N (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G N (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))))) G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (MulEquiv.mulEquivClass.{u1, u2} G N (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))))))))) e) K) H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (K : Subgroup.{u1} G _inst_1) {N : Type.{u2}} [_inst_4 : Group.{u2} N] {H : Subgroup.{u2} N _inst_4} {e : MulEquiv.{u1, u2} G N (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))))}, Iff (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.map.{u2, u1} N _inst_4 G _inst_1 (MonoidHomClass.toMonoidHom.{u2, u1, max u1 u2} N G (MulEquiv.{u2, u1} N G (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (MulEquivClass.instMonoidHomClass.{max u1 u2, u2, u1} (MulEquiv.{u2, u1} N G (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} N G (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (MulEquiv.symm.{u1, u2} G N (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) e)) H) K) (Eq.{succ u2} (Subgroup.{u2} N _inst_4) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 (MonoidHomClass.toMonoidHom.{u1, u2, max u1 u2} G N (MulEquiv.{u1, u2} G N (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (MulEquivClass.instMonoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G N (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))))) G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (MulEquiv.instMulEquivClassMulEquiv.{u1, u2} G N (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))))) e) K) H)
Case conversion may be inaccurate. Consider using '#align subgroup.map_symm_eq_iff_map_eq Subgroup.map_symm_eq_iff_map_eqₓ'. -/
@[to_additive]
theorem map_symm_eq_iff_map_eq {H : Subgroup N} {e : G ≃* N} : H.map ↑e.symm = K ↔ K.map ↑e = H :=
  by
  constructor <;> rintro rfl
  ·
    rw [map_map, ← MulEquiv.coe_monoidHom_trans, MulEquiv.symm_trans_self,
      MulEquiv.coe_monoidHom_refl, map_id]
  ·
    rw [map_map, ← MulEquiv.coe_monoidHom_trans, MulEquiv.self_trans_symm,
      MulEquiv.coe_monoidHom_refl, map_id]
#align subgroup.map_symm_eq_iff_map_eq Subgroup.map_symm_eq_iff_map_eq
#align add_subgroup.map_symm_eq_iff_map_eq AddSubgroup.map_symm_eq_iff_map_eq

/- warning: subgroup.map_le_iff_le_comap -> Subgroup.map_le_iff_le_comap is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))} {K : Subgroup.{u1} G _inst_1} {H : Subgroup.{u2} N _inst_4}, Iff (LE.le.{u2} (Subgroup.{u2} N _inst_4) (Preorder.toLE.{u2} (Subgroup.{u2} N _inst_4) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} N _inst_4) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)))) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f K) H) (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) K (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f H))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))} {K : Subgroup.{u2} G _inst_1} {H : Subgroup.{u1} N _inst_4}, Iff (LE.le.{u1} (Subgroup.{u1} N _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} N _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} N _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} N _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u1} N _inst_4))))) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f K) H) (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))))) K (Subgroup.comap.{u2, u1} G _inst_1 N _inst_4 f H))
Case conversion may be inaccurate. Consider using '#align subgroup.map_le_iff_le_comap Subgroup.map_le_iff_le_comapₓ'. -/
@[to_additive]
theorem map_le_iff_le_comap {f : G →* N} {K : Subgroup G} {H : Subgroup N} :
    K.map f ≤ H ↔ K ≤ H.comap f :=
  image_subset_iff
#align subgroup.map_le_iff_le_comap Subgroup.map_le_iff_le_comap
#align add_subgroup.map_le_iff_le_comap AddSubgroup.map_le_iff_le_comap

/- warning: subgroup.gc_map_comap -> Subgroup.gc_map_comap is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), GaloisConnection.{u1, u2} (Subgroup.{u1} G _inst_1) (Subgroup.{u2} N _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1))) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} N _inst_4) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4))) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f)
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))), GaloisConnection.{u2, u1} (Subgroup.{u2} G _inst_1) (Subgroup.{u1} N _inst_4) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1)))) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} N _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} N _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u1} N _inst_4)))) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f) (Subgroup.comap.{u2, u1} G _inst_1 N _inst_4 f)
Case conversion may be inaccurate. Consider using '#align subgroup.gc_map_comap Subgroup.gc_map_comapₓ'. -/
@[to_additive]
theorem gc_map_comap (f : G →* N) : GaloisConnection (map f) (comap f) := fun _ _ =>
  map_le_iff_le_comap
#align subgroup.gc_map_comap Subgroup.gc_map_comap
#align add_subgroup.gc_map_comap AddSubgroup.gc_map_comap

/- warning: subgroup.map_sup -> Subgroup.map_sup is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (H : Subgroup.{u1} G _inst_1) (K : Subgroup.{u1} G _inst_1) (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), Eq.{succ u2} (Subgroup.{u2} N _inst_4) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) H K)) (Sup.sup.{u2} (Subgroup.{u2} N _inst_4) (SemilatticeSup.toHasSup.{u2} (Subgroup.{u2} N _inst_4) (Lattice.toSemilatticeSup.{u2} (Subgroup.{u2} N _inst_4) (CompleteLattice.toLattice.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.completeLattice.{u2} N _inst_4)))) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f K))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (H : Subgroup.{u2} G _inst_1) (K : Subgroup.{u2} G _inst_1) (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))), Eq.{succ u1} (Subgroup.{u1} N _inst_4) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f (Sup.sup.{u2} (Subgroup.{u2} G _inst_1) (SemilatticeSup.toSup.{u2} (Subgroup.{u2} G _inst_1) (Lattice.toSemilatticeSup.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toLattice.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1)))) H K)) (Sup.sup.{u1} (Subgroup.{u1} N _inst_4) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} N _inst_4) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} N _inst_4) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u1} N _inst_4)))) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f K))
Case conversion may be inaccurate. Consider using '#align subgroup.map_sup Subgroup.map_supₓ'. -/
@[to_additive]
theorem map_sup (H K : Subgroup G) (f : G →* N) : (H ⊔ K).map f = H.map f ⊔ K.map f :=
  (gc_map_comap f).l_sup
#align subgroup.map_sup Subgroup.map_sup
#align add_subgroup.map_sup AddSubgroup.map_sup

/- warning: subgroup.map_supr -> Subgroup.map_supᵢ is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {ι : Sort.{u3}} (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (s : ι -> (Subgroup.{u1} G _inst_1)), Eq.{succ u2} (Subgroup.{u2} N _inst_4) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f (supᵢ.{u1, u3} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))) ι s)) (supᵢ.{u2, u3} (Subgroup.{u2} N _inst_4) (CompleteSemilatticeSup.toHasSup.{u2} (Subgroup.{u2} N _inst_4) (CompleteLattice.toCompleteSemilatticeSup.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.completeLattice.{u2} N _inst_4))) ι (fun (i : ι) => Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f (s i)))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {ι : Sort.{u3}} (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (s : ι -> (Subgroup.{u2} G _inst_1)), Eq.{succ u1} (Subgroup.{u1} N _inst_4) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f (supᵢ.{u2, u3} (Subgroup.{u2} G _inst_1) (CompleteLattice.toSupSet.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1)) ι s)) (supᵢ.{u1, u3} (Subgroup.{u1} N _inst_4) (CompleteLattice.toSupSet.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u1} N _inst_4)) ι (fun (i : ι) => Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f (s i)))
Case conversion may be inaccurate. Consider using '#align subgroup.map_supr Subgroup.map_supᵢₓ'. -/
@[to_additive]
theorem map_supᵢ {ι : Sort _} (f : G →* N) (s : ι → Subgroup G) :
    (supᵢ s).map f = ⨆ i, (s i).map f :=
  (gc_map_comap f).l_supᵢ
#align subgroup.map_supr Subgroup.map_supᵢ
#align add_subgroup.map_supr AddSubgroup.map_supᵢ

/- warning: subgroup.comap_sup_comap_le -> Subgroup.comap_sup_comap_le is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (H : Subgroup.{u2} N _inst_4) (K : Subgroup.{u2} N _inst_4) (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f H) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f K)) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f (Sup.sup.{u2} (Subgroup.{u2} N _inst_4) (SemilatticeSup.toHasSup.{u2} (Subgroup.{u2} N _inst_4) (Lattice.toSemilatticeSup.{u2} (Subgroup.{u2} N _inst_4) (CompleteLattice.toLattice.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.completeLattice.{u2} N _inst_4)))) H K))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (H : Subgroup.{u2} N _inst_4) (K : Subgroup.{u2} N _inst_4) (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f H) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f K)) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f (Sup.sup.{u2} (Subgroup.{u2} N _inst_4) (SemilatticeSup.toSup.{u2} (Subgroup.{u2} N _inst_4) (Lattice.toSemilatticeSup.{u2} (Subgroup.{u2} N _inst_4) (CompleteLattice.toLattice.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u2} N _inst_4)))) H K))
Case conversion may be inaccurate. Consider using '#align subgroup.comap_sup_comap_le Subgroup.comap_sup_comap_leₓ'. -/
@[to_additive]
theorem comap_sup_comap_le (H K : Subgroup N) (f : G →* N) :
    comap f H ⊔ comap f K ≤ comap f (H ⊔ K) :=
  Monotone.le_map_sup (fun _ _ => comap_mono) H K
#align subgroup.comap_sup_comap_le Subgroup.comap_sup_comap_le
#align add_subgroup.comap_sup_comap_le AddSubgroup.comap_sup_comap_le

/- warning: subgroup.supr_comap_le -> Subgroup.supᵢ_comap_le is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {ι : Sort.{u3}} (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (s : ι -> (Subgroup.{u2} N _inst_4)), LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (supᵢ.{u1, u3} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))) ι (fun (i : ι) => Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f (s i))) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f (supᵢ.{u2, u3} (Subgroup.{u2} N _inst_4) (CompleteSemilatticeSup.toHasSup.{u2} (Subgroup.{u2} N _inst_4) (CompleteLattice.toCompleteSemilatticeSup.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.completeLattice.{u2} N _inst_4))) ι s))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {ι : Sort.{u3}} (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (s : ι -> (Subgroup.{u1} N _inst_4)), LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))))) (supᵢ.{u2, u3} (Subgroup.{u2} G _inst_1) (CompleteLattice.toSupSet.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1)) ι (fun (i : ι) => Subgroup.comap.{u2, u1} G _inst_1 N _inst_4 f (s i))) (Subgroup.comap.{u2, u1} G _inst_1 N _inst_4 f (supᵢ.{u1, u3} (Subgroup.{u1} N _inst_4) (CompleteLattice.toSupSet.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u1} N _inst_4)) ι s))
Case conversion may be inaccurate. Consider using '#align subgroup.supr_comap_le Subgroup.supᵢ_comap_leₓ'. -/
@[to_additive]
theorem supᵢ_comap_le {ι : Sort _} (f : G →* N) (s : ι → Subgroup N) :
    (⨆ i, (s i).comap f) ≤ (supᵢ s).comap f :=
  Monotone.le_map_supᵢ fun _ _ => comap_mono
#align subgroup.supr_comap_le Subgroup.supᵢ_comap_le
#align add_subgroup.supr_comap_le AddSubgroup.supᵢ_comap_le

/- warning: subgroup.comap_inf -> Subgroup.comap_inf is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (H : Subgroup.{u2} N _inst_4) (K : Subgroup.{u2} N _inst_4) (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f (Inf.inf.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.hasInf.{u2} N _inst_4) H K)) (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasInf.{u1} G _inst_1) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f H) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f K))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (H : Subgroup.{u2} N _inst_4) (K : Subgroup.{u2} N _inst_4) (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f (Inf.inf.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.instInfSubgroup.{u2} N _inst_4) H K)) (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instInfSubgroup.{u1} G _inst_1) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f H) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f K))
Case conversion may be inaccurate. Consider using '#align subgroup.comap_inf Subgroup.comap_infₓ'. -/
@[to_additive]
theorem comap_inf (H K : Subgroup N) (f : G →* N) : (H ⊓ K).comap f = H.comap f ⊓ K.comap f :=
  (gc_map_comap f).u_inf
#align subgroup.comap_inf Subgroup.comap_inf
#align add_subgroup.comap_inf AddSubgroup.comap_inf

/- warning: subgroup.comap_infi -> Subgroup.comap_infᵢ is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {ι : Sort.{u3}} (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (s : ι -> (Subgroup.{u2} N _inst_4)), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f (infᵢ.{u2, u3} (Subgroup.{u2} N _inst_4) (Subgroup.hasInf.{u2} N _inst_4) ι s)) (infᵢ.{u1, u3} (Subgroup.{u1} G _inst_1) (Subgroup.hasInf.{u1} G _inst_1) ι (fun (i : ι) => Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f (s i)))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {ι : Sort.{u3}} (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (s : ι -> (Subgroup.{u1} N _inst_4)), Eq.{succ u2} (Subgroup.{u2} G _inst_1) (Subgroup.comap.{u2, u1} G _inst_1 N _inst_4 f (infᵢ.{u1, u3} (Subgroup.{u1} N _inst_4) (Subgroup.instInfSetSubgroup.{u1} N _inst_4) ι s)) (infᵢ.{u2, u3} (Subgroup.{u2} G _inst_1) (Subgroup.instInfSetSubgroup.{u2} G _inst_1) ι (fun (i : ι) => Subgroup.comap.{u2, u1} G _inst_1 N _inst_4 f (s i)))
Case conversion may be inaccurate. Consider using '#align subgroup.comap_infi Subgroup.comap_infᵢₓ'. -/
@[to_additive]
theorem comap_infᵢ {ι : Sort _} (f : G →* N) (s : ι → Subgroup N) :
    (infᵢ s).comap f = ⨅ i, (s i).comap f :=
  (gc_map_comap f).u_infᵢ
#align subgroup.comap_infi Subgroup.comap_infᵢ
#align add_subgroup.comap_infi AddSubgroup.comap_infᵢ

/- warning: subgroup.map_inf_le -> Subgroup.map_inf_le is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (H : Subgroup.{u1} G _inst_1) (K : Subgroup.{u1} G _inst_1) (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), LE.le.{u2} (Subgroup.{u2} N _inst_4) (Preorder.toLE.{u2} (Subgroup.{u2} N _inst_4) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} N _inst_4) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)))) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasInf.{u1} G _inst_1) H K)) (Inf.inf.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.hasInf.{u2} N _inst_4) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f K))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (H : Subgroup.{u2} G _inst_1) (K : Subgroup.{u2} G _inst_1) (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))), LE.le.{u1} (Subgroup.{u1} N _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} N _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} N _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} N _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u1} N _inst_4))))) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f (Inf.inf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instInfSubgroup.{u2} G _inst_1) H K)) (Inf.inf.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instInfSubgroup.{u1} N _inst_4) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f K))
Case conversion may be inaccurate. Consider using '#align subgroup.map_inf_le Subgroup.map_inf_leₓ'. -/
@[to_additive]
theorem map_inf_le (H K : Subgroup G) (f : G →* N) : map f (H ⊓ K) ≤ map f H ⊓ map f K :=
  le_inf (map_mono inf_le_left) (map_mono inf_le_right)
#align subgroup.map_inf_le Subgroup.map_inf_le
#align add_subgroup.map_inf_le AddSubgroup.map_inf_le

/- warning: subgroup.map_inf_eq -> Subgroup.map_inf_eq is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (H : Subgroup.{u1} G _inst_1) (K : Subgroup.{u1} G _inst_1) (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), (Function.Injective.{succ u1, succ u2} G N (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f)) -> (Eq.{succ u2} (Subgroup.{u2} N _inst_4) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasInf.{u1} G _inst_1) H K)) (Inf.inf.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.hasInf.{u2} N _inst_4) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f K)))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (H : Subgroup.{u2} G _inst_1) (K : Subgroup.{u2} G _inst_1) (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))), (Function.Injective.{succ u2, succ u1} G N (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f)) -> (Eq.{succ u1} (Subgroup.{u1} N _inst_4) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f (Inf.inf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instInfSubgroup.{u2} G _inst_1) H K)) (Inf.inf.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instInfSubgroup.{u1} N _inst_4) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f K)))
Case conversion may be inaccurate. Consider using '#align subgroup.map_inf_eq Subgroup.map_inf_eqₓ'. -/
@[to_additive]
theorem map_inf_eq (H K : Subgroup G) (f : G →* N) (hf : Function.Injective f) :
    map f (H ⊓ K) = map f H ⊓ map f K :=
  by
  rw [← SetLike.coe_set_eq]
  simp [Set.image_inter hf]
#align subgroup.map_inf_eq Subgroup.map_inf_eq
#align add_subgroup.map_inf_eq AddSubgroup.map_inf_eq

/- warning: subgroup.map_bot -> Subgroup.map_bot is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), Eq.{succ u2} (Subgroup.{u2} N _inst_4) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1))) (Bot.bot.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.hasBot.{u2} N _inst_4))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))), Eq.{succ u1} (Subgroup.{u1} N _inst_4) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f (Bot.bot.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instBotSubgroup.{u2} G _inst_1))) (Bot.bot.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instBotSubgroup.{u1} N _inst_4))
Case conversion may be inaccurate. Consider using '#align subgroup.map_bot Subgroup.map_botₓ'. -/
@[simp, to_additive]
theorem map_bot (f : G →* N) : (⊥ : Subgroup G).map f = ⊥ :=
  (gc_map_comap f).l_bot
#align subgroup.map_bot Subgroup.map_bot
#align add_subgroup.map_bot AddSubgroup.map_bot

/- warning: subgroup.map_top_of_surjective -> Subgroup.map_top_of_surjective is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), (Function.Surjective.{succ u1, succ u2} G N (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f)) -> (Eq.{succ u2} (Subgroup.{u2} N _inst_4) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasTop.{u1} G _inst_1))) (Top.top.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.hasTop.{u2} N _inst_4)))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))), (Function.Surjective.{succ u2, succ u1} G N (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f)) -> (Eq.{succ u1} (Subgroup.{u1} N _inst_4) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f (Top.top.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instTopSubgroup.{u2} G _inst_1))) (Top.top.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instTopSubgroup.{u1} N _inst_4)))
Case conversion may be inaccurate. Consider using '#align subgroup.map_top_of_surjective Subgroup.map_top_of_surjectiveₓ'. -/
@[simp, to_additive]
theorem map_top_of_surjective (f : G →* N) (h : Function.Surjective f) : Subgroup.map f ⊤ = ⊤ :=
  by
  rw [eq_top_iff]
  intro x hx
  obtain ⟨y, hy⟩ := h x
  exact ⟨y, trivial, hy⟩
#align subgroup.map_top_of_surjective Subgroup.map_top_of_surjective
#align add_subgroup.map_top_of_surjective AddSubgroup.map_top_of_surjective

/- warning: subgroup.comap_top -> Subgroup.comap_top is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f (Top.top.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.hasTop.{u2} N _inst_4))) (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasTop.{u1} G _inst_1))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))), Eq.{succ u2} (Subgroup.{u2} G _inst_1) (Subgroup.comap.{u2, u1} G _inst_1 N _inst_4 f (Top.top.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instTopSubgroup.{u1} N _inst_4))) (Top.top.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instTopSubgroup.{u2} G _inst_1))
Case conversion may be inaccurate. Consider using '#align subgroup.comap_top Subgroup.comap_topₓ'. -/
@[simp, to_additive]
theorem comap_top (f : G →* N) : (⊤ : Subgroup N).comap f = ⊤ :=
  (gc_map_comap f).u_top
#align subgroup.comap_top Subgroup.comap_top
#align add_subgroup.comap_top AddSubgroup.comap_top

/- warning: subgroup.subgroup_of -> Subgroup.subgroupOf is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], (Subgroup.{u1} G _inst_1) -> (forall (K : Subgroup.{u1} G _inst_1), Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], (Subgroup.{u1} G _inst_1) -> (forall (K : Subgroup.{u1} G _inst_1), Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Subgroup.toGroup.{u1} G _inst_1 K))
Case conversion may be inaccurate. Consider using '#align subgroup.subgroup_of Subgroup.subgroupOfₓ'. -/
/-- For any subgroups `H` and `K`, view `H ⊓ K` as a subgroup of `K`. -/
@[to_additive "For any subgroups `H` and `K`, view `H ⊓ K` as a subgroup of `K`."]
def subgroupOf (H K : Subgroup G) : Subgroup K :=
  H.comap K.Subtype
#align subgroup.subgroup_of Subgroup.subgroupOf
#align add_subgroup.add_subgroup_of AddSubgroup.addSubgroupOf

/- warning: subgroup.subgroup_of_equiv_of_le -> Subgroup.subgroupOfEquivOfLe is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_6 : Group.{u1} G] {H : Subgroup.{u1} G _inst_6} {K : Subgroup.{u1} G _inst_6}, (LE.le.{u1} (Subgroup.{u1} G _inst_6) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_6) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_6) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_6) G (Subgroup.setLike.{u1} G _inst_6)))) H K) -> (MulEquiv.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_6) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_6) G (Subgroup.setLike.{u1} G _inst_6)) K) (Subgroup.toGroup.{u1} G _inst_6 K)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_6) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_6) G (Subgroup.setLike.{u1} G _inst_6)) K) (Subgroup.toGroup.{u1} G _inst_6 K)) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_6) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_6) G (Subgroup.setLike.{u1} G _inst_6)) K) (Subgroup.setLike.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_6) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_6) G (Subgroup.setLike.{u1} G _inst_6)) K) (Subgroup.toGroup.{u1} G _inst_6 K))) (Subgroup.subgroupOf.{u1} G _inst_6 H K)) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_6) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_6) G (Subgroup.setLike.{u1} G _inst_6)) H) (Subgroup.mul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_6) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_6) G (Subgroup.setLike.{u1} G _inst_6)) K) (Subgroup.toGroup.{u1} G _inst_6 K) (Subgroup.subgroupOf.{u1} G _inst_6 H K)) (Subgroup.mul.{u1} G _inst_6 H))
but is expected to have type
  forall {G : Type.{u1}} [_inst_6 : Group.{u1} G] {H : Subgroup.{u1} G _inst_6} {K : Subgroup.{u1} G _inst_6}, (LE.le.{u1} (Subgroup.{u1} G _inst_6) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_6) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_6) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_6) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_6) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_6))))) H K) -> (MulEquiv.{u1, u1} (Subtype.{succ u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_6) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_6) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_6)) x K)) (fun (x : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_6) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_6) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_6)) x K)) => Membership.mem.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_6) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_6) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_6)) x K)) (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_6) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_6) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_6)) x K)) (Subgroup.toGroup.{u1} G _inst_6 K)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_6) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_6) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_6)) x K)) (Subgroup.toGroup.{u1} G _inst_6 K)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_6) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_6) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_6)) x K)) (Subgroup.instSetLikeSubgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_6) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_6) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_6)) x K)) (Subgroup.toGroup.{u1} G _inst_6 K))) x (Subgroup.subgroupOf.{u1} G _inst_6 H K))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_6) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_6) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_6)) x H)) (Subgroup.mul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_6) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_6) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_6)) x K)) (Subgroup.toGroup.{u1} G _inst_6 K) (Subgroup.subgroupOf.{u1} G _inst_6 H K)) (Subgroup.mul.{u1} G _inst_6 H))
Case conversion may be inaccurate. Consider using '#align subgroup.subgroup_of_equiv_of_le Subgroup.subgroupOfEquivOfLeₓ'. -/
/-- If `H ≤ K`, then `H` as a subgroup of `K` is isomorphic to `H`. -/
@[to_additive "If `H ≤ K`, then `H` as a subgroup of `K` is isomorphic to `H`.", simps]
def subgroupOfEquivOfLe {G : Type _} [Group G] {H K : Subgroup G} (h : H ≤ K) : H.subgroupOf K ≃* H
    where
  toFun g := ⟨g.1, g.2⟩
  invFun g := ⟨⟨g.1, h g.2⟩, g.2⟩
  left_inv g := Subtype.ext (Subtype.ext rfl)
  right_inv g := Subtype.ext rfl
  map_mul' g h := rfl
#align subgroup.subgroup_of_equiv_of_le Subgroup.subgroupOfEquivOfLe
#align add_subgroup.add_subgroup_of_equiv_of_le AddSubgroup.addSubgroupOfEquivOfLe

/- warning: subgroup.comap_subtype -> Subgroup.comap_subtype is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (K : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K)) (Subgroup.comap.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K) G _inst_1 (Subgroup.subtype.{u1} G _inst_1 K) H) (Subgroup.subgroupOf.{u1} G _inst_1 H K)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (K : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Subgroup.toGroup.{u1} G _inst_1 K)) (Subgroup.comap.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Subgroup.toGroup.{u1} G _inst_1 K) G _inst_1 (Subgroup.subtype.{u1} G _inst_1 K) H) (Subgroup.subgroupOf.{u1} G _inst_1 H K)
Case conversion may be inaccurate. Consider using '#align subgroup.comap_subtype Subgroup.comap_subtypeₓ'. -/
@[simp, to_additive]
theorem comap_subtype (H K : Subgroup G) : H.comap K.Subtype = H.subgroupOf K :=
  rfl
#align subgroup.comap_subtype Subgroup.comap_subtype
#align add_subgroup.comap_subtype AddSubgroup.comap_subtype

/- warning: subgroup.comap_inclusion_subgroup_of -> Subgroup.comap_inclusion_subgroupOf is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {K₁ : Subgroup.{u1} G _inst_1} {K₂ : Subgroup.{u1} G _inst_1} (h : LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) K₁ K₂) (H : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K₁) (Subgroup.toGroup.{u1} G _inst_1 K₁)) (Subgroup.comap.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K₁) (Subgroup.toGroup.{u1} G _inst_1 K₁) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K₂) (Subgroup.toGroup.{u1} G _inst_1 K₂) (Subgroup.inclusion.{u1} G _inst_1 K₁ K₂ h) (Subgroup.subgroupOf.{u1} G _inst_1 H K₂)) (Subgroup.subgroupOf.{u1} G _inst_1 H K₁)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {K₁ : Subgroup.{u1} G _inst_1} {K₂ : Subgroup.{u1} G _inst_1} (h : LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) K₁ K₂) (H : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K₁)) (Subgroup.toGroup.{u1} G _inst_1 K₁)) (Subgroup.comap.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K₁)) (Subgroup.toGroup.{u1} G _inst_1 K₁) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K₂)) (Subgroup.toGroup.{u1} G _inst_1 K₂) (Subgroup.inclusion.{u1} G _inst_1 K₁ K₂ h) (Subgroup.subgroupOf.{u1} G _inst_1 H K₂)) (Subgroup.subgroupOf.{u1} G _inst_1 H K₁)
Case conversion may be inaccurate. Consider using '#align subgroup.comap_inclusion_subgroup_of Subgroup.comap_inclusion_subgroupOfₓ'. -/
@[simp, to_additive]
theorem comap_inclusion_subgroupOf {K₁ K₂ : Subgroup G} (h : K₁ ≤ K₂) (H : Subgroup G) :
    (H.subgroupOf K₂).comap (inclusion h) = H.subgroupOf K₁ :=
  rfl
#align subgroup.comap_inclusion_subgroup_of Subgroup.comap_inclusion_subgroupOf
#align add_subgroup.comap_inclusion_add_subgroup_of AddSubgroup.comap_inclusion_addSubgroupOf

/- warning: subgroup.coe_subgroup_of -> Subgroup.coe_subgroupOf is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (K : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Set.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K)) (Set.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K)) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K)) (Set.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K)) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K)) (Set.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K)) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K)) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.setLike.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K))))) (Subgroup.subgroupOf.{u1} G _inst_1 H K)) (Set.preimage.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) G (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) -> G) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.subtype.{u1} G _inst_1 K)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (K : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Set.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K))) (SetLike.coe.{u1, u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Subgroup.toGroup.{u1} G _inst_1 K)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Subgroup.instSetLikeSubgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Subgroup.toGroup.{u1} G _inst_1 K)) (Subgroup.subgroupOf.{u1} G _inst_1 H K)) (Set.preimage.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) G (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 K)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (fun (_x : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) => G) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 K)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) G (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 K))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 K)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 K)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (MonoidHom.monoidHomClass.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 K)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (Subgroup.subtype.{u1} G _inst_1 K)) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H))
Case conversion may be inaccurate. Consider using '#align subgroup.coe_subgroup_of Subgroup.coe_subgroupOfₓ'. -/
@[to_additive]
theorem coe_subgroupOf (H K : Subgroup G) : (H.subgroupOf K : Set K) = K.Subtype ⁻¹' H :=
  rfl
#align subgroup.coe_subgroup_of Subgroup.coe_subgroupOf
#align add_subgroup.coe_add_subgroup_of AddSubgroup.coe_addSubgroupOf

/- warning: subgroup.mem_subgroup_of -> Subgroup.mem_subgroupOf is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1} {h : coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K}, Iff (Membership.Mem.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K)) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K)) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.setLike.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K))) h (Subgroup.subgroupOf.{u1} G _inst_1 H K)) (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) G (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x K))))) h) H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1} {h : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)}, Iff (Membership.mem.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Subgroup.toGroup.{u1} G _inst_1 K)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Subgroup.toGroup.{u1} G _inst_1 K)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Subgroup.instSetLikeSubgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Subgroup.toGroup.{u1} G _inst_1 K))) h (Subgroup.subgroupOf.{u1} G _inst_1 H K)) (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) K)) h) H)
Case conversion may be inaccurate. Consider using '#align subgroup.mem_subgroup_of Subgroup.mem_subgroupOfₓ'. -/
@[to_additive]
theorem mem_subgroupOf {H K : Subgroup G} {h : K} : h ∈ H.subgroupOf K ↔ (h : G) ∈ H :=
  Iff.rfl
#align subgroup.mem_subgroup_of Subgroup.mem_subgroupOf
#align add_subgroup.mem_add_subgroup_of AddSubgroup.mem_addSubgroupOf

/- warning: subgroup.subgroup_of_map_subtype -> Subgroup.subgroupOf_map_subtype is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (K : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.map.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K) G _inst_1 (Subgroup.subtype.{u1} G _inst_1 K) (Subgroup.subgroupOf.{u1} G _inst_1 H K)) (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasInf.{u1} G _inst_1) H K)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (K : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.map.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Subgroup.toGroup.{u1} G _inst_1 K) G _inst_1 (Subgroup.subtype.{u1} G _inst_1 K) (Subgroup.subgroupOf.{u1} G _inst_1 H K)) (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instInfSubgroup.{u1} G _inst_1) H K)
Case conversion may be inaccurate. Consider using '#align subgroup.subgroup_of_map_subtype Subgroup.subgroupOf_map_subtypeₓ'. -/
@[simp, to_additive]
theorem subgroupOf_map_subtype (H K : Subgroup G) : (H.subgroupOf K).map K.Subtype = H ⊓ K :=
  SetLike.ext' <| Subtype.image_preimage_coe _ _
#align subgroup.subgroup_of_map_subtype Subgroup.subgroupOf_map_subtype
#align add_subgroup.add_subgroup_of_map_subtype AddSubgroup.addSubgroupOf_map_subtype

/- warning: subgroup.bot_subgroup_of -> Subgroup.bot_subgroupOf is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)) (Subgroup.subgroupOf.{u1} G _inst_1 (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1)) H) (Bot.bot.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)) (Subgroup.hasBot.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)) (Subgroup.subgroupOf.{u1} G _inst_1 (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1)) H) (Bot.bot.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)) (Subgroup.instBotSubgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))
Case conversion may be inaccurate. Consider using '#align subgroup.bot_subgroup_of Subgroup.bot_subgroupOfₓ'. -/
@[simp, to_additive]
theorem bot_subgroupOf : (⊥ : Subgroup G).subgroupOf H = ⊥ :=
  Eq.symm (Subgroup.ext fun g => Subtype.ext_iff)
#align subgroup.bot_subgroup_of Subgroup.bot_subgroupOf
#align add_subgroup.bot_add_subgroup_of AddSubgroup.bot_addSubgroupOf

/- warning: subgroup.top_subgroup_of -> Subgroup.top_subgroupOf is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)) (Subgroup.subgroupOf.{u1} G _inst_1 (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasTop.{u1} G _inst_1)) H) (Top.top.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)) (Subgroup.hasTop.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)) (Subgroup.subgroupOf.{u1} G _inst_1 (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instTopSubgroup.{u1} G _inst_1)) H) (Top.top.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)) (Subgroup.instTopSubgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))
Case conversion may be inaccurate. Consider using '#align subgroup.top_subgroup_of Subgroup.top_subgroupOfₓ'. -/
@[simp, to_additive]
theorem top_subgroupOf : (⊤ : Subgroup G).subgroupOf H = ⊤ :=
  rfl
#align subgroup.top_subgroup_of Subgroup.top_subgroupOf
#align add_subgroup.top_add_subgroup_of AddSubgroup.top_addSubgroupOf

/- warning: subgroup.subgroup_of_bot_eq_bot -> Subgroup.subgroupOf_bot_eq_bot is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1))) (Subgroup.toGroup.{u1} G _inst_1 (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1)))) (Subgroup.subgroupOf.{u1} G _inst_1 H (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1))) (Bot.bot.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1))) (Subgroup.toGroup.{u1} G _inst_1 (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1)))) (Subgroup.hasBot.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1))) (Subgroup.toGroup.{u1} G _inst_1 (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1)))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1)))) (Subgroup.toGroup.{u1} G _inst_1 (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1)))) (Subgroup.subgroupOf.{u1} G _inst_1 H (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1))) (Bot.bot.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1)))) (Subgroup.toGroup.{u1} G _inst_1 (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1)))) (Subgroup.instBotSubgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1)))) (Subgroup.toGroup.{u1} G _inst_1 (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1)))))
Case conversion may be inaccurate. Consider using '#align subgroup.subgroup_of_bot_eq_bot Subgroup.subgroupOf_bot_eq_botₓ'. -/
@[to_additive]
theorem subgroupOf_bot_eq_bot : H.subgroupOf ⊥ = ⊥ :=
  Subsingleton.elim _ _
#align subgroup.subgroup_of_bot_eq_bot Subgroup.subgroupOf_bot_eq_bot
#align add_subgroup.add_subgroup_of_bot_eq_bot AddSubgroup.addSubgroupOf_bot_eq_bot

/- warning: subgroup.subgroup_of_bot_eq_top -> Subgroup.subgroupOf_bot_eq_top is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1))) (Subgroup.toGroup.{u1} G _inst_1 (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1)))) (Subgroup.subgroupOf.{u1} G _inst_1 H (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1))) (Top.top.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1))) (Subgroup.toGroup.{u1} G _inst_1 (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1)))) (Subgroup.hasTop.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1))) (Subgroup.toGroup.{u1} G _inst_1 (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1)))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1)))) (Subgroup.toGroup.{u1} G _inst_1 (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1)))) (Subgroup.subgroupOf.{u1} G _inst_1 H (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1))) (Top.top.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1)))) (Subgroup.toGroup.{u1} G _inst_1 (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1)))) (Subgroup.instTopSubgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1)))) (Subgroup.toGroup.{u1} G _inst_1 (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1)))))
Case conversion may be inaccurate. Consider using '#align subgroup.subgroup_of_bot_eq_top Subgroup.subgroupOf_bot_eq_topₓ'. -/
@[to_additive]
theorem subgroupOf_bot_eq_top : H.subgroupOf ⊥ = ⊤ :=
  Subsingleton.elim _ _
#align subgroup.subgroup_of_bot_eq_top Subgroup.subgroupOf_bot_eq_top
#align add_subgroup.add_subgroup_of_bot_eq_top AddSubgroup.addSubgroupOf_bot_eq_top

/- warning: subgroup.subgroup_of_self -> Subgroup.subgroupOf_self is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)) (Subgroup.subgroupOf.{u1} G _inst_1 H H) (Top.top.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)) (Subgroup.hasTop.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)) (Subgroup.subgroupOf.{u1} G _inst_1 H H) (Top.top.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)) (Subgroup.instTopSubgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))
Case conversion may be inaccurate. Consider using '#align subgroup.subgroup_of_self Subgroup.subgroupOf_selfₓ'. -/
@[simp, to_additive]
theorem subgroupOf_self : H.subgroupOf H = ⊤ :=
  top_unique fun g hg => g.2
#align subgroup.subgroup_of_self Subgroup.subgroupOf_self
#align add_subgroup.add_subgroup_of_self AddSubgroup.addSubgroupOf_self

/- warning: subgroup.subgroup_of_inj -> Subgroup.subgroupOf_inj is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H₁ : Subgroup.{u1} G _inst_1} {H₂ : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1}, Iff (Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K)) (Subgroup.subgroupOf.{u1} G _inst_1 H₁ K) (Subgroup.subgroupOf.{u1} G _inst_1 H₂ K)) (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasInf.{u1} G _inst_1) H₁ K) (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasInf.{u1} G _inst_1) H₂ K))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H₁ : Subgroup.{u1} G _inst_1} {H₂ : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1}, Iff (Eq.{succ u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Subgroup.toGroup.{u1} G _inst_1 K)) (Subgroup.subgroupOf.{u1} G _inst_1 H₁ K) (Subgroup.subgroupOf.{u1} G _inst_1 H₂ K)) (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instInfSubgroup.{u1} G _inst_1) H₁ K) (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instInfSubgroup.{u1} G _inst_1) H₂ K))
Case conversion may be inaccurate. Consider using '#align subgroup.subgroup_of_inj Subgroup.subgroupOf_injₓ'. -/
@[simp, to_additive]
theorem subgroupOf_inj {H₁ H₂ K : Subgroup G} :
    H₁.subgroupOf K = H₂.subgroupOf K ↔ H₁ ⊓ K = H₂ ⊓ K := by
  simpa only [SetLike.ext_iff, mem_inf, mem_subgroup_of, and_congr_left_iff] using Subtype.forall
#align subgroup.subgroup_of_inj Subgroup.subgroupOf_inj
#align add_subgroup.add_subgroup_of_inj AddSubgroup.addSubgroupOf_inj

/- warning: subgroup.inf_subgroup_of_right -> Subgroup.inf_subgroupOf_right is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (K : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K)) (Subgroup.subgroupOf.{u1} G _inst_1 (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasInf.{u1} G _inst_1) H K) K) (Subgroup.subgroupOf.{u1} G _inst_1 H K)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (K : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Subgroup.toGroup.{u1} G _inst_1 K)) (Subgroup.subgroupOf.{u1} G _inst_1 (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instInfSubgroup.{u1} G _inst_1) H K) K) (Subgroup.subgroupOf.{u1} G _inst_1 H K)
Case conversion may be inaccurate. Consider using '#align subgroup.inf_subgroup_of_right Subgroup.inf_subgroupOf_rightₓ'. -/
@[simp, to_additive]
theorem inf_subgroupOf_right (H K : Subgroup G) : (H ⊓ K).subgroupOf K = H.subgroupOf K :=
  subgroupOf_inj.2 inf_right_idem
#align subgroup.inf_subgroup_of_right Subgroup.inf_subgroupOf_right
#align add_subgroup.inf_add_subgroup_of_right AddSubgroup.inf_addSubgroupOf_right

/- warning: subgroup.inf_subgroup_of_left -> Subgroup.inf_subgroupOf_left is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (K : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K)) (Subgroup.subgroupOf.{u1} G _inst_1 (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasInf.{u1} G _inst_1) K H) K) (Subgroup.subgroupOf.{u1} G _inst_1 H K)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (K : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Subgroup.toGroup.{u1} G _inst_1 K)) (Subgroup.subgroupOf.{u1} G _inst_1 (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instInfSubgroup.{u1} G _inst_1) K H) K) (Subgroup.subgroupOf.{u1} G _inst_1 H K)
Case conversion may be inaccurate. Consider using '#align subgroup.inf_subgroup_of_left Subgroup.inf_subgroupOf_leftₓ'. -/
@[simp, to_additive]
theorem inf_subgroupOf_left (H K : Subgroup G) : (K ⊓ H).subgroupOf K = H.subgroupOf K := by
  rw [inf_comm, inf_subgroup_of_right]
#align subgroup.inf_subgroup_of_left Subgroup.inf_subgroupOf_left
#align add_subgroup.inf_add_subgroup_of_left AddSubgroup.inf_addSubgroupOf_left

/- warning: subgroup.subgroup_of_eq_bot -> Subgroup.subgroupOf_eq_bot is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1}, Iff (Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K)) (Subgroup.subgroupOf.{u1} G _inst_1 H K) (Bot.bot.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K)) (Subgroup.hasBot.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K)))) (Disjoint.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (BoundedOrder.toOrderBot.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (CompleteLattice.toBoundedOrder.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))) H K)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1}, Iff (Eq.{succ u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Subgroup.toGroup.{u1} G _inst_1 K)) (Subgroup.subgroupOf.{u1} G _inst_1 H K) (Bot.bot.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Subgroup.toGroup.{u1} G _inst_1 K)) (Subgroup.instBotSubgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Subgroup.toGroup.{u1} G _inst_1 K)))) (Disjoint.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))) (BoundedOrder.toOrderBot.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (CompleteLattice.toBoundedOrder.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))) H K)
Case conversion may be inaccurate. Consider using '#align subgroup.subgroup_of_eq_bot Subgroup.subgroupOf_eq_botₓ'. -/
@[simp, to_additive]
theorem subgroupOf_eq_bot {H K : Subgroup G} : H.subgroupOf K = ⊥ ↔ Disjoint H K := by
  rw [disjoint_iff, ← bot_subgroup_of, subgroup_of_inj, bot_inf_eq]
#align subgroup.subgroup_of_eq_bot Subgroup.subgroupOf_eq_bot
#align add_subgroup.add_subgroup_of_eq_bot AddSubgroup.addSubgroupOf_eq_bot

/- warning: subgroup.subgroup_of_eq_top -> Subgroup.subgroupOf_eq_top is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1}, Iff (Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K)) (Subgroup.subgroupOf.{u1} G _inst_1 H K) (Top.top.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K)) (Subgroup.hasTop.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K)))) (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) K H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1}, Iff (Eq.{succ u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Subgroup.toGroup.{u1} G _inst_1 K)) (Subgroup.subgroupOf.{u1} G _inst_1 H K) (Top.top.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Subgroup.toGroup.{u1} G _inst_1 K)) (Subgroup.instTopSubgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Subgroup.toGroup.{u1} G _inst_1 K)))) (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) K H)
Case conversion may be inaccurate. Consider using '#align subgroup.subgroup_of_eq_top Subgroup.subgroupOf_eq_topₓ'. -/
@[simp, to_additive]
theorem subgroupOf_eq_top {H K : Subgroup G} : H.subgroupOf K = ⊤ ↔ K ≤ H := by
  rw [← top_subgroup_of, subgroup_of_inj, top_inf_eq, inf_eq_right]
#align subgroup.subgroup_of_eq_top Subgroup.subgroupOf_eq_top
#align add_subgroup.add_subgroup_of_eq_top AddSubgroup.addSubgroupOf_eq_top

/- warning: subgroup.prod -> Subgroup.prod is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N], (Subgroup.{u1} G _inst_1) -> (Subgroup.{u2} N _inst_4) -> (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N], (Subgroup.{u1} G _inst_1) -> (Subgroup.{u2} N _inst_4) -> (Subgroup.{max u2 u1} (Prod.{u1, u2} G N) (Prod.instGroupProd.{u1, u2} G N _inst_1 _inst_4))
Case conversion may be inaccurate. Consider using '#align subgroup.prod Subgroup.prodₓ'. -/
/-- Given `subgroup`s `H`, `K` of groups `G`, `N` respectively, `H × K` as a subgroup of `G × N`. -/
@[to_additive Prod
      "Given `add_subgroup`s `H`, `K` of `add_group`s `A`, `B` respectively, `H × K`\nas an `add_subgroup` of `A × B`."]
def prod (H : Subgroup G) (K : Subgroup N) : Subgroup (G × N) :=
  { Submonoid.prod H.toSubmonoid K.toSubmonoid with
    inv_mem' := fun _ hx => ⟨H.inv_mem' hx.1, K.inv_mem' hx.2⟩ }
#align subgroup.prod Subgroup.prod
#align add_subgroup.prod AddSubgroup.prod

/- warning: subgroup.coe_prod -> Subgroup.coe_prod is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (H : Subgroup.{u1} G _inst_1) (K : Subgroup.{u2} N _inst_4), Eq.{succ (max u1 u2)} (Set.{max u1 u2} (Prod.{u1, u2} G N)) ((fun (a : Type.{max u1 u2}) (b : Type.{max u1 u2}) [self : HasLiftT.{succ (max u1 u2), succ (max u1 u2)} a b] => self.0) (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (Set.{max u1 u2} (Prod.{u1, u2} G N)) (HasLiftT.mk.{succ (max u1 u2), succ (max u1 u2)} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (Set.{max u1 u2} (Prod.{u1, u2} G N)) (CoeTCₓ.coe.{succ (max u1 u2), succ (max u1 u2)} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (Set.{max u1 u2} (Prod.{u1, u2} G N)) (SetLike.Set.hasCoeT.{max u1 u2, max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (Prod.{u1, u2} G N) (Subgroup.setLike.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4))))) (Subgroup.prod.{u1, u2} G _inst_1 N _inst_4 H K)) (Set.prod.{u1, u2} G N ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Subgroup.{u2} N _inst_4) (Set.{u2} N) (HasLiftT.mk.{succ u2, succ u2} (Subgroup.{u2} N _inst_4) (Set.{u2} N) (CoeTCₓ.coe.{succ u2, succ u2} (Subgroup.{u2} N _inst_4) (Set.{u2} N) (SetLike.Set.hasCoeT.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)))) K))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (H : Subgroup.{u2} G _inst_1) (K : Subgroup.{u1} N _inst_4), Eq.{max (succ u2) (succ u1)} (Set.{max u2 u1} (Prod.{u2, u1} G N)) (SetLike.coe.{max u2 u1, max u2 u1} (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (Prod.{u2, u1} G N) (Subgroup.instSetLikeSubgroup.{max u2 u1} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (Subgroup.prod.{u2, u1} G _inst_1 N _inst_4 H K)) (Set.prod.{u2, u1} G N (SetLike.coe.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1) H) (SetLike.coe.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4) K))
Case conversion may be inaccurate. Consider using '#align subgroup.coe_prod Subgroup.coe_prodₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
@[to_additive coe_prod]
theorem coe_prod (H : Subgroup G) (K : Subgroup N) : (H.Prod K : Set (G × N)) = H ×ˢ K :=
  rfl
#align subgroup.coe_prod Subgroup.coe_prod
#align add_subgroup.coe_prod AddSubgroup.coe_prod

/- warning: subgroup.mem_prod -> Subgroup.mem_prod is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u2} N _inst_4} {p : Prod.{u1, u2} G N}, Iff (Membership.Mem.{max u1 u2, max u1 u2} (Prod.{u1, u2} G N) (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (SetLike.hasMem.{max u1 u2, max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (Prod.{u1, u2} G N) (Subgroup.setLike.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4))) p (Subgroup.prod.{u1, u2} G _inst_1 N _inst_4 H K)) (And (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Prod.fst.{u1, u2} G N p) H) (Membership.Mem.{u2, u2} N (Subgroup.{u2} N _inst_4) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (Prod.snd.{u1, u2} G N p) K))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {H : Subgroup.{u2} G _inst_1} {K : Subgroup.{u1} N _inst_4} {p : Prod.{u2, u1} G N}, Iff (Membership.mem.{max u2 u1, max u2 u1} (Prod.{u2, u1} G N) (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (SetLike.instMembership.{max u2 u1, max u2 u1} (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (Prod.{u2, u1} G N) (Subgroup.instSetLikeSubgroup.{max u2 u1} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4))) p (Subgroup.prod.{u2, u1} G _inst_1 N _inst_4 H K)) (And (Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) (Prod.fst.{u2, u1} G N p) H) (Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) (Prod.snd.{u2, u1} G N p) K))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_prod Subgroup.mem_prodₓ'. -/
@[to_additive mem_prod]
theorem mem_prod {H : Subgroup G} {K : Subgroup N} {p : G × N} : p ∈ H.Prod K ↔ p.1 ∈ H ∧ p.2 ∈ K :=
  Iff.rfl
#align subgroup.mem_prod Subgroup.mem_prod
#align add_subgroup.mem_prod AddSubgroup.mem_prod

/- warning: subgroup.prod_mono -> Subgroup.prod_mono is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N], Relator.LiftFun.{succ u1, succ u1, max (succ u2) (succ (max u1 u2)), max (succ u2) (succ (max u1 u2))} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) ((Subgroup.{u2} N _inst_4) -> (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4))) ((Subgroup.{u2} N _inst_4) -> (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4))) (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1))))) (Relator.LiftFun.{succ u2, succ u2, succ (max u1 u2), succ (max u1 u2)} (Subgroup.{u2} N _inst_4) (Subgroup.{u2} N _inst_4) (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (LE.le.{u2} (Subgroup.{u2} N _inst_4) (Preorder.toLE.{u2} (Subgroup.{u2} N _inst_4) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} N _inst_4) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4))))) (LE.le.{max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (Preorder.toLE.{max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (PartialOrder.toPreorder.{max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (SetLike.partialOrder.{max u1 u2, max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (Prod.{u1, u2} G N) (Subgroup.setLike.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4))))))) (Subgroup.prod.{u1, u2} G _inst_1 N _inst_4) (Subgroup.prod.{u1, u2} G _inst_1 N _inst_4)
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N], Relator.LiftFun.{succ u2, succ u2, max (succ u1) (succ (max u2 u1)), max (succ u1) (succ (max u2 u1))} (Subgroup.{u2} G _inst_1) (Subgroup.{u2} G _inst_1) ((Subgroup.{u1} N _inst_4) -> (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4))) ((Subgroup.{u1} N _inst_4) -> (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4))) (fun (x._@.Mathlib.GroupTheory.Subgroup.Basic._hyg.14126 : Subgroup.{u2} G _inst_1) (x._@.Mathlib.GroupTheory.Subgroup.Basic._hyg.14128 : Subgroup.{u2} G _inst_1) => LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))))) x._@.Mathlib.GroupTheory.Subgroup.Basic._hyg.14126 x._@.Mathlib.GroupTheory.Subgroup.Basic._hyg.14128) (Relator.LiftFun.{succ u1, succ u1, succ (max u2 u1), succ (max u2 u1)} (Subgroup.{u1} N _inst_4) (Subgroup.{u1} N _inst_4) (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (fun (x._@.Mathlib.GroupTheory.Subgroup.Basic._hyg.14144 : Subgroup.{u1} N _inst_4) (x._@.Mathlib.GroupTheory.Subgroup.Basic._hyg.14146 : Subgroup.{u1} N _inst_4) => LE.le.{u1} (Subgroup.{u1} N _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} N _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} N _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} N _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u1} N _inst_4))))) x._@.Mathlib.GroupTheory.Subgroup.Basic._hyg.14144 x._@.Mathlib.GroupTheory.Subgroup.Basic._hyg.14146) (fun (x._@.Mathlib.GroupTheory.Subgroup.Basic._hyg.14159 : Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (x._@.Mathlib.GroupTheory.Subgroup.Basic._hyg.14161 : Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) => LE.le.{max u2 u1} (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (Preorder.toLE.{max u2 u1} (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (PartialOrder.toPreorder.{max u2 u1} (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (CompleteSemilatticeInf.toPartialOrder.{max u2 u1} (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (CompleteLattice.toCompleteSemilatticeInf.{max u2 u1} (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (Subgroup.instCompleteLatticeSubgroup.{max u2 u1} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)))))) x._@.Mathlib.GroupTheory.Subgroup.Basic._hyg.14159 x._@.Mathlib.GroupTheory.Subgroup.Basic._hyg.14161)) (Subgroup.prod.{u2, u1} G _inst_1 N _inst_4) (Subgroup.prod.{u2, u1} G _inst_1 N _inst_4)
Case conversion may be inaccurate. Consider using '#align subgroup.prod_mono Subgroup.prod_monoₓ'. -/
@[to_additive prod_mono]
theorem prod_mono : ((· ≤ ·) ⇒ (· ≤ ·) ⇒ (· ≤ ·)) (@prod G _ N _) (@prod G _ N _) :=
  fun s s' hs t t' ht => Set.prod_mono hs ht
#align subgroup.prod_mono Subgroup.prod_mono
#align add_subgroup.prod_mono AddSubgroup.prod_mono

/- warning: subgroup.prod_mono_right -> Subgroup.prod_mono_right is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (K : Subgroup.{u1} G _inst_1), Monotone.{u2, max u1 u2} (Subgroup.{u2} N _inst_4) (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} N _inst_4) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4))) (PartialOrder.toPreorder.{max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (SetLike.partialOrder.{max u1 u2, max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (Prod.{u1, u2} G N) (Subgroup.setLike.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)))) (fun (t : Subgroup.{u2} N _inst_4) => Subgroup.prod.{u1, u2} G _inst_1 N _inst_4 K t)
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (K : Subgroup.{u2} G _inst_1), Monotone.{u1, max u2 u1} (Subgroup.{u1} N _inst_4) (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} N _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} N _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u1} N _inst_4)))) (PartialOrder.toPreorder.{max u2 u1} (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (CompleteSemilatticeInf.toPartialOrder.{max u2 u1} (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (CompleteLattice.toCompleteSemilatticeInf.{max u2 u1} (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (Subgroup.instCompleteLatticeSubgroup.{max u2 u1} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4))))) (fun (t : Subgroup.{u1} N _inst_4) => Subgroup.prod.{u2, u1} G _inst_1 N _inst_4 K t)
Case conversion may be inaccurate. Consider using '#align subgroup.prod_mono_right Subgroup.prod_mono_rightₓ'. -/
@[to_additive prod_mono_right]
theorem prod_mono_right (K : Subgroup G) : Monotone fun t : Subgroup N => K.Prod t :=
  prod_mono (le_refl K)
#align subgroup.prod_mono_right Subgroup.prod_mono_right
#align add_subgroup.prod_mono_right AddSubgroup.prod_mono_right

/- warning: subgroup.prod_mono_left -> Subgroup.prod_mono_left is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (H : Subgroup.{u2} N _inst_4), Monotone.{u1, max u1 u2} (Subgroup.{u1} G _inst_1) (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1))) (PartialOrder.toPreorder.{max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (SetLike.partialOrder.{max u1 u2, max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (Prod.{u1, u2} G N) (Subgroup.setLike.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)))) (fun (K : Subgroup.{u1} G _inst_1) => Subgroup.prod.{u1, u2} G _inst_1 N _inst_4 K H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (H : Subgroup.{u2} N _inst_4), Monotone.{u1, max u1 u2} (Subgroup.{u1} G _inst_1) (Subgroup.{max u2 u1} (Prod.{u1, u2} G N) (Prod.instGroupProd.{u1, u2} G N _inst_1 _inst_4)) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) (PartialOrder.toPreorder.{max u1 u2} (Subgroup.{max u2 u1} (Prod.{u1, u2} G N) (Prod.instGroupProd.{u1, u2} G N _inst_1 _inst_4)) (CompleteSemilatticeInf.toPartialOrder.{max u1 u2} (Subgroup.{max u2 u1} (Prod.{u1, u2} G N) (Prod.instGroupProd.{u1, u2} G N _inst_1 _inst_4)) (CompleteLattice.toCompleteSemilatticeInf.{max u1 u2} (Subgroup.{max u2 u1} (Prod.{u1, u2} G N) (Prod.instGroupProd.{u1, u2} G N _inst_1 _inst_4)) (Subgroup.instCompleteLatticeSubgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.instGroupProd.{u1, u2} G N _inst_1 _inst_4))))) (fun (K : Subgroup.{u1} G _inst_1) => Subgroup.prod.{u1, u2} G _inst_1 N _inst_4 K H)
Case conversion may be inaccurate. Consider using '#align subgroup.prod_mono_left Subgroup.prod_mono_leftₓ'. -/
@[to_additive prod_mono_left]
theorem prod_mono_left (H : Subgroup N) : Monotone fun K : Subgroup G => K.Prod H := fun s₁ s₂ hs =>
  prod_mono hs (le_refl H)
#align subgroup.prod_mono_left Subgroup.prod_mono_left
#align add_subgroup.prod_mono_left AddSubgroup.prod_mono_left

/- warning: subgroup.prod_top -> Subgroup.prod_top is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (K : Subgroup.{u1} G _inst_1), Eq.{succ (max u1 u2)} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (Subgroup.prod.{u1, u2} G _inst_1 N _inst_4 K (Top.top.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.hasTop.{u2} N _inst_4))) (Subgroup.comap.{max u1 u2, u1} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4) G _inst_1 (MonoidHom.fst.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) K)
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (K : Subgroup.{u2} G _inst_1), Eq.{max (succ u2) (succ u1)} (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (Subgroup.prod.{u2, u1} G _inst_1 N _inst_4 K (Top.top.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instTopSubgroup.{u1} N _inst_4))) (Subgroup.comap.{max u2 u1, u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4) G _inst_1 (MonoidHom.fst.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) K)
Case conversion may be inaccurate. Consider using '#align subgroup.prod_top Subgroup.prod_topₓ'. -/
@[to_additive prod_top]
theorem prod_top (K : Subgroup G) : K.Prod (⊤ : Subgroup N) = K.comap (MonoidHom.fst G N) :=
  ext fun x => by simp [mem_prod, MonoidHom.coe_fst]
#align subgroup.prod_top Subgroup.prod_top
#align add_subgroup.prod_top AddSubgroup.prod_top

/- warning: subgroup.top_prod -> Subgroup.top_prod is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (H : Subgroup.{u2} N _inst_4), Eq.{succ (max u1 u2)} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (Subgroup.prod.{u1, u2} G _inst_1 N _inst_4 (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasTop.{u1} G _inst_1)) H) (Subgroup.comap.{max u1 u2, u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4) N _inst_4 (MonoidHom.snd.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (H : Subgroup.{u2} N _inst_4), Eq.{max (succ u1) (succ u2)} (Subgroup.{max u2 u1} (Prod.{u1, u2} G N) (Prod.instGroupProd.{u1, u2} G N _inst_1 _inst_4)) (Subgroup.prod.{u1, u2} G _inst_1 N _inst_4 (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instTopSubgroup.{u1} G _inst_1)) H) (Subgroup.comap.{max u1 u2, u2} (Prod.{u1, u2} G N) (Prod.instGroupProd.{u1, u2} G N _inst_1 _inst_4) N _inst_4 (MonoidHom.snd.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) H)
Case conversion may be inaccurate. Consider using '#align subgroup.top_prod Subgroup.top_prodₓ'. -/
@[to_additive top_prod]
theorem top_prod (H : Subgroup N) : (⊤ : Subgroup G).Prod H = H.comap (MonoidHom.snd G N) :=
  ext fun x => by simp [mem_prod, MonoidHom.coe_snd]
#align subgroup.top_prod Subgroup.top_prod
#align add_subgroup.top_prod AddSubgroup.top_prod

/- warning: subgroup.top_prod_top -> Subgroup.top_prod_top is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N], Eq.{succ (max u1 u2)} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (Subgroup.prod.{u1, u2} G _inst_1 N _inst_4 (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasTop.{u1} G _inst_1)) (Top.top.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.hasTop.{u2} N _inst_4))) (Top.top.{max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (Subgroup.hasTop.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N], Eq.{max (succ u2) (succ u1)} (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (Subgroup.prod.{u2, u1} G _inst_1 N _inst_4 (Top.top.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instTopSubgroup.{u2} G _inst_1)) (Top.top.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instTopSubgroup.{u1} N _inst_4))) (Top.top.{max u2 u1} (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (Subgroup.instTopSubgroup.{max u2 u1} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)))
Case conversion may be inaccurate. Consider using '#align subgroup.top_prod_top Subgroup.top_prod_topₓ'. -/
@[simp, to_additive top_prod_top]
theorem top_prod_top : (⊤ : Subgroup G).Prod (⊤ : Subgroup N) = ⊤ :=
  (top_prod _).trans <| comap_top _
#align subgroup.top_prod_top Subgroup.top_prod_top
#align add_subgroup.top_prod_top AddSubgroup.top_prod_top

/- warning: subgroup.bot_prod_bot -> Subgroup.bot_prod_bot is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N], Eq.{succ (max u1 u2)} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (Subgroup.prod.{u1, u2} G _inst_1 N _inst_4 (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1)) (Bot.bot.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.hasBot.{u2} N _inst_4))) (Bot.bot.{max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (Subgroup.hasBot.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N], Eq.{max (succ u2) (succ u1)} (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (Subgroup.prod.{u2, u1} G _inst_1 N _inst_4 (Bot.bot.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instBotSubgroup.{u2} G _inst_1)) (Bot.bot.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instBotSubgroup.{u1} N _inst_4))) (Bot.bot.{max u2 u1} (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (Subgroup.instBotSubgroup.{max u2 u1} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)))
Case conversion may be inaccurate. Consider using '#align subgroup.bot_prod_bot Subgroup.bot_prod_botₓ'. -/
@[to_additive]
theorem bot_prod_bot : (⊥ : Subgroup G).Prod (⊥ : Subgroup N) = ⊥ :=
  SetLike.coe_injective <| by simp [coe_prod, Prod.one_eq_mk]
#align subgroup.bot_prod_bot Subgroup.bot_prod_bot
#align add_subgroup.bot_sum_bot AddSubgroup.bot_sum_bot

/- warning: subgroup.le_prod_iff -> Subgroup.le_prod_iff is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u2} N _inst_4} {J : Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)}, Iff (LE.le.{max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (Preorder.toLE.{max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (PartialOrder.toPreorder.{max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (SetLike.partialOrder.{max u1 u2, max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (Prod.{u1, u2} G N) (Subgroup.setLike.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4))))) J (Subgroup.prod.{u1, u2} G _inst_1 N _inst_4 H K)) (And (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.map.{max u1 u2, u1} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4) G _inst_1 (MonoidHom.fst.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) J) H) (LE.le.{u2} (Subgroup.{u2} N _inst_4) (Preorder.toLE.{u2} (Subgroup.{u2} N _inst_4) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} N _inst_4) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)))) (Subgroup.map.{max u1 u2, u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4) N _inst_4 (MonoidHom.snd.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) J) K))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {H : Subgroup.{u2} G _inst_1} {K : Subgroup.{u1} N _inst_4} {J : Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)}, Iff (LE.le.{max u2 u1} (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (Preorder.toLE.{max u2 u1} (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (PartialOrder.toPreorder.{max u2 u1} (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (CompleteSemilatticeInf.toPartialOrder.{max u2 u1} (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (CompleteLattice.toCompleteSemilatticeInf.{max u2 u1} (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (Subgroup.instCompleteLatticeSubgroup.{max u2 u1} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)))))) J (Subgroup.prod.{u2, u1} G _inst_1 N _inst_4 H K)) (And (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))))) (Subgroup.map.{max u2 u1, u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4) G _inst_1 (MonoidHom.fst.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) J) H) (LE.le.{u1} (Subgroup.{u1} N _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} N _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} N _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} N _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u1} N _inst_4))))) (Subgroup.map.{max u2 u1, u1} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4) N _inst_4 (MonoidHom.snd.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) J) K))
Case conversion may be inaccurate. Consider using '#align subgroup.le_prod_iff Subgroup.le_prod_iffₓ'. -/
@[to_additive le_prod_iff]
theorem le_prod_iff {H : Subgroup G} {K : Subgroup N} {J : Subgroup (G × N)} :
    J ≤ H.Prod K ↔ map (MonoidHom.fst G N) J ≤ H ∧ map (MonoidHom.snd G N) J ≤ K := by
  simpa only [← Subgroup.toSubmonoid_le] using Submonoid.le_prod_iff
#align subgroup.le_prod_iff Subgroup.le_prod_iff
#align add_subgroup.le_prod_iff AddSubgroup.le_prod_iff

/- warning: subgroup.prod_le_iff -> Subgroup.prod_le_iff is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u2} N _inst_4} {J : Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)}, Iff (LE.le.{max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (Preorder.toLE.{max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (PartialOrder.toPreorder.{max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (SetLike.partialOrder.{max u1 u2, max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (Prod.{u1, u2} G N) (Subgroup.setLike.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4))))) (Subgroup.prod.{u1, u2} G _inst_1 N _inst_4 H K) J) (And (LE.le.{max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (Preorder.toLE.{max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (PartialOrder.toPreorder.{max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (SetLike.partialOrder.{max u1 u2, max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (Prod.{u1, u2} G N) (Subgroup.setLike.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4))))) (Subgroup.map.{u1, max u1 u2} G _inst_1 (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4) (MonoidHom.inl.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) H) J) (LE.le.{max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (Preorder.toLE.{max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (PartialOrder.toPreorder.{max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (SetLike.partialOrder.{max u1 u2, max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (Prod.{u1, u2} G N) (Subgroup.setLike.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4))))) (Subgroup.map.{u2, max u1 u2} N _inst_4 (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4) (MonoidHom.inr.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) K) J))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {H : Subgroup.{u2} G _inst_1} {K : Subgroup.{u1} N _inst_4} {J : Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)}, Iff (LE.le.{max u2 u1} (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (Preorder.toLE.{max u2 u1} (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (PartialOrder.toPreorder.{max u2 u1} (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (CompleteSemilatticeInf.toPartialOrder.{max u2 u1} (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (CompleteLattice.toCompleteSemilatticeInf.{max u2 u1} (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (Subgroup.instCompleteLatticeSubgroup.{max u2 u1} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)))))) (Subgroup.prod.{u2, u1} G _inst_1 N _inst_4 H K) J) (And (LE.le.{max u2 u1} (Subgroup.{max u2 u1} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (Preorder.toLE.{max u2 u1} (Subgroup.{max u2 u1} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (PartialOrder.toPreorder.{max u2 u1} (Subgroup.{max u2 u1} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (CompleteSemilatticeInf.toPartialOrder.{max u2 u1} (Subgroup.{max u2 u1} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (CompleteLattice.toCompleteSemilatticeInf.{max u2 u1} (Subgroup.{max u2 u1} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (Subgroup.instCompleteLatticeSubgroup.{max u2 u1} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)))))) (Subgroup.map.{u2, max u2 u1} G _inst_1 (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4) (MonoidHom.inl.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) H) J) (LE.le.{max u2 u1} (Subgroup.{max u2 u1} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (Preorder.toLE.{max u2 u1} (Subgroup.{max u2 u1} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (PartialOrder.toPreorder.{max u2 u1} (Subgroup.{max u2 u1} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (CompleteSemilatticeInf.toPartialOrder.{max u2 u1} (Subgroup.{max u2 u1} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (CompleteLattice.toCompleteSemilatticeInf.{max u2 u1} (Subgroup.{max u2 u1} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (Subgroup.instCompleteLatticeSubgroup.{max u2 u1} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)))))) (Subgroup.map.{u1, max u2 u1} N _inst_4 (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4) (MonoidHom.inr.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) K) J))
Case conversion may be inaccurate. Consider using '#align subgroup.prod_le_iff Subgroup.prod_le_iffₓ'. -/
@[to_additive prod_le_iff]
theorem prod_le_iff {H : Subgroup G} {K : Subgroup N} {J : Subgroup (G × N)} :
    H.Prod K ≤ J ↔ map (MonoidHom.inl G N) H ≤ J ∧ map (MonoidHom.inr G N) K ≤ J := by
  simpa only [← Subgroup.toSubmonoid_le] using Submonoid.prod_le_iff
#align subgroup.prod_le_iff Subgroup.prod_le_iff
#align add_subgroup.prod_le_iff AddSubgroup.prod_le_iff

/- warning: subgroup.prod_eq_bot_iff -> Subgroup.prod_eq_bot_iff is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u2} N _inst_4}, Iff (Eq.{succ (max u1 u2)} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (Subgroup.prod.{u1, u2} G _inst_1 N _inst_4 H K) (Bot.bot.{max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (Subgroup.hasBot.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)))) (And (Eq.{succ u1} (Subgroup.{u1} G _inst_1) H (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1))) (Eq.{succ u2} (Subgroup.{u2} N _inst_4) K (Bot.bot.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.hasBot.{u2} N _inst_4))))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {H : Subgroup.{u2} G _inst_1} {K : Subgroup.{u1} N _inst_4}, Iff (Eq.{max (succ u2) (succ u1)} (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (Subgroup.prod.{u2, u1} G _inst_1 N _inst_4 H K) (Bot.bot.{max u2 u1} (Subgroup.{max u1 u2} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)) (Subgroup.instBotSubgroup.{max u2 u1} (Prod.{u2, u1} G N) (Prod.instGroupProd.{u2, u1} G N _inst_1 _inst_4)))) (And (Eq.{succ u2} (Subgroup.{u2} G _inst_1) H (Bot.bot.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instBotSubgroup.{u2} G _inst_1))) (Eq.{succ u1} (Subgroup.{u1} N _inst_4) K (Bot.bot.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instBotSubgroup.{u1} N _inst_4))))
Case conversion may be inaccurate. Consider using '#align subgroup.prod_eq_bot_iff Subgroup.prod_eq_bot_iffₓ'. -/
@[simp, to_additive prod_eq_bot_iff]
theorem prod_eq_bot_iff {H : Subgroup G} {K : Subgroup N} : H.Prod K = ⊥ ↔ H = ⊥ ∧ K = ⊥ := by
  simpa only [← Subgroup.toSubmonoid_eq] using Submonoid.prod_eq_bot_iff
#align subgroup.prod_eq_bot_iff Subgroup.prod_eq_bot_iff
#align add_subgroup.prod_eq_bot_iff AddSubgroup.prod_eq_bot_iff

/- warning: subgroup.prod_equiv -> Subgroup.prodEquiv is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (H : Subgroup.{u1} G _inst_1) (K : Subgroup.{u2} N _inst_4), MulEquiv.{max u1 u2, max u1 u2} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (Prod.{u1, u2} G N) (Subgroup.setLike.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4))) (Subgroup.prod.{u1, u2} G _inst_1 N _inst_4 H K)) (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) K)) (Subgroup.mul.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4) (Subgroup.prod.{u1, u2} G _inst_1 N _inst_4 H K)) (Prod.hasMul.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) K) (Subgroup.mul.{u1} G _inst_1 H) (Subgroup.mul.{u2} N _inst_4 K))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (H : Subgroup.{u1} G _inst_1) (K : Subgroup.{u2} N _inst_4), MulEquiv.{max u1 u2, max u2 u1} (Subtype.{succ (max u1 u2)} (Prod.{u1, u2} G N) (fun (x : Prod.{u1, u2} G N) => Membership.mem.{max u1 u2, max u1 u2} (Prod.{u1, u2} G N) (Subgroup.{max u2 u1} (Prod.{u1, u2} G N) (Prod.instGroupProd.{u1, u2} G N _inst_1 _inst_4)) (SetLike.instMembership.{max u1 u2, max u1 u2} (Subgroup.{max u2 u1} (Prod.{u1, u2} G N) (Prod.instGroupProd.{u1, u2} G N _inst_1 _inst_4)) (Prod.{u1, u2} G N) (Subgroup.instSetLikeSubgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.instGroupProd.{u1, u2} G N _inst_1 _inst_4))) x (Subgroup.prod.{u1, u2} G _inst_1 N _inst_4 H K))) (Prod.{u1, u2} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subtype.{succ u2} N (fun (x : N) => Membership.mem.{u2, u2} N (Subgroup.{u2} N _inst_4) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u2} N _inst_4)) x K))) (Subgroup.mul.{max u1 u2} (Prod.{u1, u2} G N) (Prod.instGroupProd.{u1, u2} G N _inst_1 _inst_4) (Subgroup.prod.{u1, u2} G _inst_1 N _inst_4 H K)) (Prod.instMulProd.{u1, u2} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subtype.{succ u2} N (fun (x : N) => Membership.mem.{u2, u2} N (Subgroup.{u2} N _inst_4) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u2} N _inst_4)) x K)) (Subgroup.mul.{u1} G _inst_1 H) (Subgroup.mul.{u2} N _inst_4 K))
Case conversion may be inaccurate. Consider using '#align subgroup.prod_equiv Subgroup.prodEquivₓ'. -/
/-- Product of subgroups is isomorphic to their product as groups. -/
@[to_additive prod_equiv
      "Product of additive subgroups is isomorphic to their product\nas additive groups"]
def prodEquiv (H : Subgroup G) (K : Subgroup N) : H.Prod K ≃* H × K :=
  { Equiv.Set.prod ↑H ↑K with map_mul' := fun x y => rfl }
#align subgroup.prod_equiv Subgroup.prodEquiv
#align add_subgroup.prod_equiv AddSubgroup.prodEquiv

section Pi

variable {η : Type _} {f : η → Type _}

#print Submonoid.pi /-
-- defined here and not in group_theory.submonoid.operations to have access to algebra.group.pi
/-- A version of `set.pi` for submonoids. Given an index set `I` and a family of submodules
`s : Π i, submonoid f i`, `pi I s` is the submonoid of dependent functions `f : Π i, f i` such that
`f i` belongs to `pi I s` whenever `i ∈ I`. -/
@[to_additive
      " A version of `set.pi` for `add_submonoid`s. Given an index set `I` and a family\nof submodules `s : Π i, add_submonoid f i`, `pi I s` is the `add_submonoid` of dependent functions\n`f : Π i, f i` such that `f i` belongs to `pi I s` whenever `i ∈ I`. -/ "]
def Submonoid.pi [∀ i, MulOneClass (f i)] (I : Set η) (s : ∀ i, Submonoid (f i)) :
    Submonoid (∀ i, f i) where
  carrier := I.pi fun i => (s i).carrier
  one_mem' i _ := (s i).one_mem
  mul_mem' p q hp hq i hI := (s i).mul_mem (hp i hI) (hq i hI)
#align submonoid.pi Submonoid.pi
#align add_submonoid.pi AddSubmonoid.pi
-/

variable [∀ i, Group (f i)]

#print Subgroup.pi /-
/-- A version of `set.pi` for subgroups. Given an index set `I` and a family of submodules
`s : Π i, subgroup f i`, `pi I s` is the subgroup of dependent functions `f : Π i, f i` such that
`f i` belongs to `pi I s` whenever `i ∈ I`. -/
@[to_additive
      " A version of `set.pi` for `add_subgroup`s. Given an index set `I` and a family\nof submodules `s : Π i, add_subgroup f i`, `pi I s` is the `add_subgroup` of dependent functions\n`f : Π i, f i` such that `f i` belongs to `pi I s` whenever `i ∈ I`. -/ "]
def pi (I : Set η) (H : ∀ i, Subgroup (f i)) : Subgroup (∀ i, f i) :=
  { Submonoid.pi I fun i => (H i).toSubmonoid with
    inv_mem' := fun p hp i hI => (H i).inv_mem (hp i hI) }
#align subgroup.pi Subgroup.pi
#align add_subgroup.pi AddSubgroup.pi
-/

/- warning: subgroup.coe_pi -> Subgroup.coe_pi is a dubious translation:
lean 3 declaration is
  forall {η : Type.{u1}} {f : η -> Type.{u2}} [_inst_6 : forall (i : η), Group.{u2} (f i)] (I : Set.{u1} η) (H : forall (i : η), Subgroup.{u2} (f i) (_inst_6 i)), Eq.{succ (max u1 u2)} (Set.{max u1 u2} (forall (i : η), f i)) ((fun (a : Type.{max u1 u2}) (b : Type.{max u1 u2}) [self : HasLiftT.{succ (max u1 u2), succ (max u1 u2)} a b] => self.0) (Subgroup.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (Set.{max u1 u2} (forall (i : η), f i)) (HasLiftT.mk.{succ (max u1 u2), succ (max u1 u2)} (Subgroup.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (Set.{max u1 u2} (forall (i : η), f i)) (CoeTCₓ.coe.{succ (max u1 u2), succ (max u1 u2)} (Subgroup.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (Set.{max u1 u2} (forall (i : η), f i)) (SetLike.Set.hasCoeT.{max u1 u2, max u1 u2} (Subgroup.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (forall (i : η), f i) (Subgroup.setLike.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i)))))) (Subgroup.pi.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i) I H)) (Set.pi.{u1, u2} η (fun (i : η) => f i) I (fun (i : η) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Subgroup.{u2} (f i) (_inst_6 i)) (Set.{u2} (f i)) (HasLiftT.mk.{succ u2, succ u2} (Subgroup.{u2} (f i) (_inst_6 i)) (Set.{u2} (f i)) (CoeTCₓ.coe.{succ u2, succ u2} (Subgroup.{u2} (f i) (_inst_6 i)) (Set.{u2} (f i)) (SetLike.Set.hasCoeT.{u2, u2} (Subgroup.{u2} (f i) (_inst_6 i)) (f i) (Subgroup.setLike.{u2} (f i) (_inst_6 i))))) (H i)))
but is expected to have type
  forall {η : Type.{u2}} {f : η -> Type.{u1}} [_inst_6 : forall (i : η), Group.{u1} (f i)] (I : Set.{u2} η) (H : forall (i : η), Subgroup.{u1} (f i) (_inst_6 i)), Eq.{max (succ u2) (succ u1)} (Set.{max u2 u1} (forall (i : η), f i)) (SetLike.coe.{max u2 u1, max u2 u1} (Subgroup.{max u2 u1} (forall (i : η), f i) (Pi.group.{u2, u1} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (forall (i : η), f i) (Subgroup.instSetLikeSubgroup.{max u2 u1} (forall (i : η), f i) (Pi.group.{u2, u1} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (Subgroup.pi.{u2, u1} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i) I H)) (Set.pi.{u2, u1} η (fun (i : η) => f i) I (fun (i : η) => SetLike.coe.{u1, u1} (Subgroup.{u1} (f i) (_inst_6 i)) (f i) (Subgroup.instSetLikeSubgroup.{u1} (f i) (_inst_6 i)) (H i)))
Case conversion may be inaccurate. Consider using '#align subgroup.coe_pi Subgroup.coe_piₓ'. -/
@[to_additive]
theorem coe_pi (I : Set η) (H : ∀ i, Subgroup (f i)) :
    (pi I H : Set (∀ i, f i)) = Set.pi I fun i => (H i : Set (f i)) :=
  rfl
#align subgroup.coe_pi Subgroup.coe_pi
#align add_subgroup.coe_pi AddSubgroup.coe_pi

/- warning: subgroup.mem_pi -> Subgroup.mem_pi is a dubious translation:
lean 3 declaration is
  forall {η : Type.{u1}} {f : η -> Type.{u2}} [_inst_6 : forall (i : η), Group.{u2} (f i)] (I : Set.{u1} η) {H : forall (i : η), Subgroup.{u2} (f i) (_inst_6 i)} {p : forall (i : η), f i}, Iff (Membership.Mem.{max u1 u2, max u1 u2} (forall (i : η), f i) (Subgroup.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (SetLike.hasMem.{max u1 u2, max u1 u2} (Subgroup.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (forall (i : η), f i) (Subgroup.setLike.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i)))) p (Subgroup.pi.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i) I H)) (forall (i : η), (Membership.Mem.{u1, u1} η (Set.{u1} η) (Set.hasMem.{u1} η) i I) -> (Membership.Mem.{u2, u2} (f i) (Subgroup.{u2} (f i) (_inst_6 i)) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} (f i) (_inst_6 i)) (f i) (Subgroup.setLike.{u2} (f i) (_inst_6 i))) (p i) (H i)))
but is expected to have type
  forall {η : Type.{u2}} {f : η -> Type.{u1}} [_inst_6 : forall (i : η), Group.{u1} (f i)] (I : Set.{u2} η) {H : forall (i : η), Subgroup.{u1} (f i) (_inst_6 i)} {p : forall (i : η), f i}, Iff (Membership.mem.{max u2 u1, max u1 u2} (forall (i : η), f i) (Subgroup.{max u2 u1} (forall (i : η), f i) (Pi.group.{u2, u1} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Subgroup.{max u2 u1} (forall (i : η), f i) (Pi.group.{u2, u1} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (forall (i : η), f i) (Subgroup.instSetLikeSubgroup.{max u2 u1} (forall (i : η), f i) (Pi.group.{u2, u1} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i)))) p (Subgroup.pi.{u2, u1} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i) I H)) (forall (i : η), (Membership.mem.{u2, u2} η (Set.{u2} η) (Set.instMembershipSet.{u2} η) i I) -> (Membership.mem.{u1, u1} (f i) (Subgroup.{u1} (f i) (_inst_6 i)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} (f i) (_inst_6 i)) (f i) (Subgroup.instSetLikeSubgroup.{u1} (f i) (_inst_6 i))) (p i) (H i)))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_pi Subgroup.mem_piₓ'. -/
@[to_additive]
theorem mem_pi (I : Set η) {H : ∀ i, Subgroup (f i)} {p : ∀ i, f i} :
    p ∈ pi I H ↔ ∀ i : η, i ∈ I → p i ∈ H i :=
  Iff.rfl
#align subgroup.mem_pi Subgroup.mem_pi
#align add_subgroup.mem_pi AddSubgroup.mem_pi

/- warning: subgroup.pi_top -> Subgroup.pi_top is a dubious translation:
lean 3 declaration is
  forall {η : Type.{u1}} {f : η -> Type.{u2}} [_inst_6 : forall (i : η), Group.{u2} (f i)] (I : Set.{u1} η), Eq.{succ (max u1 u2)} (Subgroup.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (Subgroup.pi.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i) I (fun (i : η) => Top.top.{u2} (Subgroup.{u2} (f i) (_inst_6 i)) (Subgroup.hasTop.{u2} (f i) (_inst_6 i)))) (Top.top.{max u1 u2} (Subgroup.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (Subgroup.hasTop.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))))
but is expected to have type
  forall {η : Type.{u2}} {f : η -> Type.{u1}} [_inst_6 : forall (i : η), Group.{u1} (f i)] (I : Set.{u2} η), Eq.{max (succ u2) (succ u1)} (Subgroup.{max u2 u1} (forall (i : η), f i) (Pi.group.{u2, u1} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (Subgroup.pi.{u2, u1} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i) I (fun (i : η) => Top.top.{u1} (Subgroup.{u1} (f i) (_inst_6 i)) (Subgroup.instTopSubgroup.{u1} (f i) (_inst_6 i)))) (Top.top.{max u2 u1} (Subgroup.{max u2 u1} (forall (i : η), f i) (Pi.group.{u2, u1} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (Subgroup.instTopSubgroup.{max u2 u1} (forall (i : η), f i) (Pi.group.{u2, u1} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))))
Case conversion may be inaccurate. Consider using '#align subgroup.pi_top Subgroup.pi_topₓ'. -/
@[to_additive]
theorem pi_top (I : Set η) : (pi I fun i => (⊤ : Subgroup (f i))) = ⊤ :=
  ext fun x => by simp [mem_pi]
#align subgroup.pi_top Subgroup.pi_top
#align add_subgroup.pi_top AddSubgroup.pi_top

/- warning: subgroup.pi_empty -> Subgroup.pi_empty is a dubious translation:
lean 3 declaration is
  forall {η : Type.{u1}} {f : η -> Type.{u2}} [_inst_6 : forall (i : η), Group.{u2} (f i)] (H : forall (i : η), Subgroup.{u2} (f i) (_inst_6 i)), Eq.{succ (max u1 u2)} (Subgroup.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (Subgroup.pi.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i) (EmptyCollection.emptyCollection.{u1} (Set.{u1} η) (Set.hasEmptyc.{u1} η)) H) (Top.top.{max u1 u2} (Subgroup.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (Subgroup.hasTop.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))))
but is expected to have type
  forall {η : Type.{u1}} {f : η -> Type.{u2}} [_inst_6 : forall (i : η), Group.{u2} (f i)] (H : forall (i : η), Subgroup.{u2} (f i) (_inst_6 i)), Eq.{max (succ u1) (succ u2)} (Subgroup.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (Subgroup.pi.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i) (EmptyCollection.emptyCollection.{u1} (Set.{u1} η) (Set.instEmptyCollectionSet.{u1} η)) H) (Top.top.{max u1 u2} (Subgroup.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (Subgroup.instTopSubgroup.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))))
Case conversion may be inaccurate. Consider using '#align subgroup.pi_empty Subgroup.pi_emptyₓ'. -/
@[to_additive]
theorem pi_empty (H : ∀ i, Subgroup (f i)) : pi ∅ H = ⊤ :=
  ext fun x => by simp [mem_pi]
#align subgroup.pi_empty Subgroup.pi_empty
#align add_subgroup.pi_empty AddSubgroup.pi_empty

/- warning: subgroup.pi_bot -> Subgroup.pi_bot is a dubious translation:
lean 3 declaration is
  forall {η : Type.{u1}} {f : η -> Type.{u2}} [_inst_6 : forall (i : η), Group.{u2} (f i)], Eq.{succ (max u1 u2)} (Subgroup.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (Subgroup.pi.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i) (Set.univ.{u1} η) (fun (i : η) => Bot.bot.{u2} (Subgroup.{u2} (f i) (_inst_6 i)) (Subgroup.hasBot.{u2} (f i) (_inst_6 i)))) (Bot.bot.{max u1 u2} (Subgroup.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (Subgroup.hasBot.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))))
but is expected to have type
  forall {η : Type.{u2}} {f : η -> Type.{u1}} [_inst_6 : forall (i : η), Group.{u1} (f i)], Eq.{max (succ u2) (succ u1)} (Subgroup.{max u2 u1} (forall (i : η), f i) (Pi.group.{u2, u1} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (Subgroup.pi.{u2, u1} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i) (Set.univ.{u2} η) (fun (i : η) => Bot.bot.{u1} (Subgroup.{u1} (f i) (_inst_6 i)) (Subgroup.instBotSubgroup.{u1} (f i) (_inst_6 i)))) (Bot.bot.{max u2 u1} (Subgroup.{max u2 u1} (forall (i : η), f i) (Pi.group.{u2, u1} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (Subgroup.instBotSubgroup.{max u2 u1} (forall (i : η), f i) (Pi.group.{u2, u1} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))))
Case conversion may be inaccurate. Consider using '#align subgroup.pi_bot Subgroup.pi_botₓ'. -/
@[to_additive]
theorem pi_bot : (pi Set.univ fun i => (⊥ : Subgroup (f i))) = ⊥ :=
  (eq_bot_iff_forall _).mpr fun p hp =>
    by
    simp only [mem_pi, mem_bot] at *
    ext j
    exact hp j trivial
#align subgroup.pi_bot Subgroup.pi_bot
#align add_subgroup.pi_bot AddSubgroup.pi_bot

/- warning: subgroup.le_pi_iff -> Subgroup.le_pi_iff is a dubious translation:
lean 3 declaration is
  forall {η : Type.{u1}} {f : η -> Type.{u2}} [_inst_6 : forall (i : η), Group.{u2} (f i)] {I : Set.{u1} η} {H : forall (i : η), Subgroup.{u2} (f i) (_inst_6 i)} {J : Subgroup.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))}, Iff (LE.le.{max u1 u2} (Subgroup.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (Preorder.toLE.{max u1 u2} (Subgroup.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (PartialOrder.toPreorder.{max u1 u2} (Subgroup.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (SetLike.partialOrder.{max u1 u2, max u1 u2} (Subgroup.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (forall (i : η), f i) (Subgroup.setLike.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i)))))) J (Subgroup.pi.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i) I H)) (forall (i : η), (Membership.Mem.{u1, u1} η (Set.{u1} η) (Set.hasMem.{u1} η) i I) -> (LE.le.{u2} (Subgroup.{u2} (f i) (_inst_6 i)) (Preorder.toLE.{u2} (Subgroup.{u2} (f i) (_inst_6 i)) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} (f i) (_inst_6 i)) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} (f i) (_inst_6 i)) (f i) (Subgroup.setLike.{u2} (f i) (_inst_6 i))))) (Subgroup.map.{max u1 u2, u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i)) (f i) (_inst_6 i) (Pi.evalMonoidHom.{u1, u2} η f (fun (i : η) => Monoid.toMulOneClass.{u2} (f i) (DivInvMonoid.toMonoid.{u2} (f i) (Group.toDivInvMonoid.{u2} (f i) (_inst_6 i)))) i) J) (H i)))
but is expected to have type
  forall {η : Type.{u2}} {f : η -> Type.{u1}} [_inst_6 : forall (i : η), Group.{u1} (f i)] {I : Set.{u2} η} {H : forall (i : η), Subgroup.{u1} (f i) (_inst_6 i)} {J : Subgroup.{max u2 u1} (forall (i : η), f i) (Pi.group.{u2, u1} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))}, Iff (LE.le.{max u2 u1} (Subgroup.{max u2 u1} (forall (i : η), f i) (Pi.group.{u2, u1} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (Preorder.toLE.{max u2 u1} (Subgroup.{max u2 u1} (forall (i : η), f i) (Pi.group.{u2, u1} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (PartialOrder.toPreorder.{max u2 u1} (Subgroup.{max u2 u1} (forall (i : η), f i) (Pi.group.{u2, u1} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (CompleteSemilatticeInf.toPartialOrder.{max u2 u1} (Subgroup.{max u2 u1} (forall (i : η), f i) (Pi.group.{u2, u1} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (CompleteLattice.toCompleteSemilatticeInf.{max u2 u1} (Subgroup.{max u2 u1} (forall (i : η), f i) (Pi.group.{u2, u1} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (Subgroup.instCompleteLatticeSubgroup.{max u2 u1} (forall (i : η), f i) (Pi.group.{u2, u1} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))))))) J (Subgroup.pi.{u2, u1} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i) I H)) (forall (i : η), (Membership.mem.{u2, u2} η (Set.{u2} η) (Set.instMembershipSet.{u2} η) i I) -> (LE.le.{u1} (Subgroup.{u1} (f i) (_inst_6 i)) (Preorder.toLE.{u1} (Subgroup.{u1} (f i) (_inst_6 i)) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} (f i) (_inst_6 i)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} (f i) (_inst_6 i)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} (f i) (_inst_6 i)) (Subgroup.instCompleteLatticeSubgroup.{u1} (f i) (_inst_6 i)))))) (Subgroup.map.{max u2 u1, u1} (forall (i : η), f i) (Pi.group.{u2, u1} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i)) (f i) (_inst_6 i) (Pi.evalMonoidHom.{u2, u1} η f (fun (i : η) => Monoid.toMulOneClass.{u1} (f i) (DivInvMonoid.toMonoid.{u1} (f i) (Group.toDivInvMonoid.{u1} (f i) (_inst_6 i)))) i) J) (H i)))
Case conversion may be inaccurate. Consider using '#align subgroup.le_pi_iff Subgroup.le_pi_iffₓ'. -/
@[to_additive]
theorem le_pi_iff {I : Set η} {H : ∀ i, Subgroup (f i)} {J : Subgroup (∀ i, f i)} :
    J ≤ pi I H ↔ ∀ i : η, i ∈ I → map (Pi.evalMonoidHom f i) J ≤ H i :=
  by
  constructor
  · intro h i hi
    rintro _ ⟨x, hx, rfl⟩
    exact (h hx) _ hi
  · intro h x hx i hi
    refine' h i hi ⟨_, hx, rfl⟩
#align subgroup.le_pi_iff Subgroup.le_pi_iff
#align add_subgroup.le_pi_iff AddSubgroup.le_pi_iff

/- warning: subgroup.mul_single_mem_pi -> Subgroup.mulSingle_mem_pi is a dubious translation:
lean 3 declaration is
  forall {η : Type.{u1}} {f : η -> Type.{u2}} [_inst_6 : forall (i : η), Group.{u2} (f i)] [_inst_7 : DecidableEq.{succ u1} η] {I : Set.{u1} η} {H : forall (i : η), Subgroup.{u2} (f i) (_inst_6 i)} (i : η) (x : f i), Iff (Membership.Mem.{max u1 u2, max u1 u2} (forall (i : η), f i) (Subgroup.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (SetLike.hasMem.{max u1 u2, max u1 u2} (Subgroup.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (forall (i : η), f i) (Subgroup.setLike.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i)))) (Pi.mulSingle.{u1, u2} η (fun (i : η) => f i) (fun (a : η) (b : η) => _inst_7 a b) (fun (i : η) => MulOneClass.toHasOne.{u2} (f i) (Monoid.toMulOneClass.{u2} (f i) (DivInvMonoid.toMonoid.{u2} (f i) (Group.toDivInvMonoid.{u2} (f i) (_inst_6 i))))) i x) (Subgroup.pi.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i) I H)) ((Membership.Mem.{u1, u1} η (Set.{u1} η) (Set.hasMem.{u1} η) i I) -> (Membership.Mem.{u2, u2} (f i) (Subgroup.{u2} (f i) (_inst_6 i)) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} (f i) (_inst_6 i)) (f i) (Subgroup.setLike.{u2} (f i) (_inst_6 i))) x (H i)))
but is expected to have type
  forall {η : Type.{u2}} {f : η -> Type.{u1}} [_inst_6 : forall (i : η), Group.{u1} (f i)] [_inst_7 : DecidableEq.{succ u2} η] {I : Set.{u2} η} {H : forall (i : η), Subgroup.{u1} (f i) (_inst_6 i)} (i : η) (x : f i), Iff (Membership.mem.{max u1 u2, max u1 u2} (forall (i : η), f i) (Subgroup.{max u2 u1} (forall (i : η), f i) (Pi.group.{u2, u1} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Subgroup.{max u2 u1} (forall (i : η), f i) (Pi.group.{u2, u1} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (forall (i : η), f i) (Subgroup.instSetLikeSubgroup.{max u2 u1} (forall (i : η), f i) (Pi.group.{u2, u1} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i)))) (Pi.mulSingle.{u2, u1} η f (fun (a : η) (b : η) => _inst_7 a b) (fun (i : η) => InvOneClass.toOne.{u1} (f i) (DivInvOneMonoid.toInvOneClass.{u1} (f i) (DivisionMonoid.toDivInvOneMonoid.{u1} (f i) (Group.toDivisionMonoid.{u1} (f i) (_inst_6 i))))) i x) (Subgroup.pi.{u2, u1} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i) I H)) ((Membership.mem.{u2, u2} η (Set.{u2} η) (Set.instMembershipSet.{u2} η) i I) -> (Membership.mem.{u1, u1} (f i) (Subgroup.{u1} (f i) (_inst_6 i)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} (f i) (_inst_6 i)) (f i) (Subgroup.instSetLikeSubgroup.{u1} (f i) (_inst_6 i))) x (H i)))
Case conversion may be inaccurate. Consider using '#align subgroup.mul_single_mem_pi Subgroup.mulSingle_mem_piₓ'. -/
@[simp, to_additive]
theorem mulSingle_mem_pi [DecidableEq η] {I : Set η} {H : ∀ i, Subgroup (f i)} (i : η) (x : f i) :
    Pi.mulSingle i x ∈ pi I H ↔ i ∈ I → x ∈ H i :=
  by
  constructor
  · intro h hi
    simpa using h i hi
  · intro h j hj
    by_cases heq : j = i
    · subst HEq
      simpa using h hj
    · simp [HEq, one_mem]
#align subgroup.mul_single_mem_pi Subgroup.mulSingle_mem_pi
#align add_subgroup.single_mem_pi AddSubgroup.single_mem_pi

/- warning: subgroup.pi_eq_bot_iff -> Subgroup.pi_eq_bot_iff is a dubious translation:
lean 3 declaration is
  forall {η : Type.{u1}} {f : η -> Type.{u2}} [_inst_6 : forall (i : η), Group.{u2} (f i)] (H : forall (i : η), Subgroup.{u2} (f i) (_inst_6 i)), Iff (Eq.{succ (max u1 u2)} (Subgroup.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (Subgroup.pi.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i) (Set.univ.{u1} η) H) (Bot.bot.{max u1 u2} (Subgroup.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (Subgroup.hasBot.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))))) (forall (i : η), Eq.{succ u2} (Subgroup.{u2} (f i) (_inst_6 i)) (H i) (Bot.bot.{u2} (Subgroup.{u2} (f i) (_inst_6 i)) (Subgroup.hasBot.{u2} (f i) (_inst_6 i))))
but is expected to have type
  forall {η : Type.{u1}} {f : η -> Type.{u2}} [_inst_6 : forall (i : η), Group.{u2} (f i)] (H : forall (i : η), Subgroup.{u2} (f i) (_inst_6 i)), Iff (Eq.{max (succ u1) (succ u2)} (Subgroup.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (Subgroup.pi.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i) (Set.univ.{u1} η) H) (Bot.bot.{max u1 u2} (Subgroup.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))) (Subgroup.instBotSubgroup.{max u1 u2} (forall (i : η), f i) (Pi.group.{u1, u2} η (fun (i : η) => f i) (fun (i : η) => _inst_6 i))))) (forall (i : η), Eq.{succ u2} (Subgroup.{u2} (f i) (_inst_6 i)) (H i) (Bot.bot.{u2} (Subgroup.{u2} (f i) (_inst_6 i)) (Subgroup.instBotSubgroup.{u2} (f i) (_inst_6 i))))
Case conversion may be inaccurate. Consider using '#align subgroup.pi_eq_bot_iff Subgroup.pi_eq_bot_iffₓ'. -/
@[to_additive]
theorem pi_eq_bot_iff (H : ∀ i, Subgroup (f i)) : pi Set.univ H = ⊥ ↔ ∀ i, H i = ⊥ := by
  classical
    simp only [eq_bot_iff_forall]
    constructor
    · intro h i x hx
      have : MonoidHom.single f i x = 1 :=
        h (MonoidHom.single f i x) ((mul_single_mem_pi i x).mpr fun _ => hx)
      simpa using congr_fun this i
    · exact fun h x hx => funext fun i => h _ _ (hx i trivial)
#align subgroup.pi_eq_bot_iff Subgroup.pi_eq_bot_iff
#align add_subgroup.pi_eq_bot_iff AddSubgroup.pi_eq_bot_iff

end Pi

#print Subgroup.Normal /-
/-- A subgroup is normal if whenever `n ∈ H`, then `g * n * g⁻¹ ∈ H` for every `g : G` -/
structure Normal : Prop where
  conj_mem : ∀ n, n ∈ H → ∀ g : G, g * n * g⁻¹ ∈ H
#align subgroup.normal Subgroup.Normal
-/

attribute [class] normal

end Subgroup

namespace AddSubgroup

#print AddSubgroup.Normal /-
/- ./././Mathport/Syntax/Translate/Command.lean:388:30: infer kinds are unsupported in Lean 4: #[`conj_mem] [] -/
/-- An add_subgroup is normal if whenever `n ∈ H`, then `g + n - g ∈ H` for every `g : G` -/
structure Normal (H : AddSubgroup A) : Prop where
  conj_mem : ∀ n, n ∈ H → ∀ g : A, g + n + -g ∈ H
#align add_subgroup.normal AddSubgroup.Normal
-/

attribute [to_additive AddSubgroup.Normal] Subgroup.Normal

attribute [class] normal

end AddSubgroup

namespace Subgroup

variable {H K : Subgroup G}

#print Subgroup.normal_of_comm /-
@[to_additive]
instance (priority := 100) normal_of_comm {G : Type _} [CommGroup G] (H : Subgroup G) : H.Normal :=
  ⟨by simp [mul_comm, mul_left_comm]⟩
#align subgroup.normal_of_comm Subgroup.normal_of_comm
#align add_subgroup.normal_of_comm AddSubgroup.normal_of_comm
-/

namespace Normal

variable (nH : H.Normal)

/- warning: subgroup.normal.mem_comm -> Subgroup.Normal.mem_comm is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, (Subgroup.Normal.{u1} G _inst_1 H) -> (forall {a : G} {b : G}, (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) a b) H) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) b a) H))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, (Subgroup.Normal.{u1} G _inst_1 H) -> (forall {a : G} {b : G}, (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) a b) H) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) b a) H))
Case conversion may be inaccurate. Consider using '#align subgroup.normal.mem_comm Subgroup.Normal.mem_commₓ'. -/
@[to_additive]
theorem mem_comm {a b : G} (h : a * b ∈ H) : b * a ∈ H :=
  by
  have : a⁻¹ * (a * b) * a⁻¹⁻¹ ∈ H := nH.conj_mem (a * b) h a⁻¹
  simpa
#align subgroup.normal.mem_comm Subgroup.Normal.mem_comm
#align add_subgroup.normal.mem_comm AddSubgroup.Normal.mem_comm

/- warning: subgroup.normal.mem_comm_iff -> Subgroup.Normal.mem_comm_iff is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, (Subgroup.Normal.{u1} G _inst_1 H) -> (forall {a : G} {b : G}, Iff (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) a b) H) (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) b a) H))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, (Subgroup.Normal.{u1} G _inst_1 H) -> (forall {a : G} {b : G}, Iff (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) a b) H) (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) b a) H))
Case conversion may be inaccurate. Consider using '#align subgroup.normal.mem_comm_iff Subgroup.Normal.mem_comm_iffₓ'. -/
@[to_additive]
theorem mem_comm_iff {a b : G} : a * b ∈ H ↔ b * a ∈ H :=
  ⟨nH.mem_comm, nH.mem_comm⟩
#align subgroup.normal.mem_comm_iff Subgroup.Normal.mem_comm_iff
#align add_subgroup.normal.mem_comm_iff AddSubgroup.Normal.mem_comm_iff

end Normal

variable (H)

#print Subgroup.Characteristic /-
/-- A subgroup is characteristic if it is fixed by all automorphisms.
  Several equivalent conditions are provided by lemmas of the form `characteristic.iff...` -/
structure Characteristic : Prop where
  fixed : ∀ ϕ : G ≃* G, H.comap ϕ.toMonoidHom = H
#align subgroup.characteristic Subgroup.Characteristic
-/

attribute [class] characteristic

#print Subgroup.normal_of_characteristic /-
instance (priority := 100) normal_of_characteristic [h : H.Characteristic] : H.Normal :=
  ⟨fun a ha b => (SetLike.ext_iff.mp (h.fixed (MulAut.conj b)) a).mpr ha⟩
#align subgroup.normal_of_characteristic Subgroup.normal_of_characteristic
-/

end Subgroup

namespace AddSubgroup

variable (H : AddSubgroup A)

#print AddSubgroup.Characteristic /-
/-- A add_subgroup is characteristic if it is fixed by all automorphisms.
  Several equivalent conditions are provided by lemmas of the form `characteristic.iff...` -/
structure Characteristic : Prop where
  fixed : ∀ ϕ : A ≃+ A, H.comap ϕ.toAddMonoidHom = H
#align add_subgroup.characteristic AddSubgroup.Characteristic
-/

attribute [to_additive AddSubgroup.Characteristic] Subgroup.Characteristic

attribute [class] characteristic

#print AddSubgroup.normal_of_characteristic /-
instance (priority := 100) normal_of_characteristic [h : H.Characteristic] : H.Normal :=
  ⟨fun a ha b => (SetLike.ext_iff.mp (h.fixed (AddAut.conj b)) a).mpr ha⟩
#align add_subgroup.normal_of_characteristic AddSubgroup.normal_of_characteristic
-/

end AddSubgroup

namespace Subgroup

variable {H K : Subgroup G}

/- warning: subgroup.characteristic_iff_comap_eq -> Subgroup.characteristic_iff_comap_eq is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, Iff (Subgroup.Characteristic.{u1} G _inst_1 H) (forall (ϕ : MulEquiv.{u1, u1} G G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.comap.{u1, u1} G _inst_1 G _inst_1 (MulEquiv.toMonoidHom.{u1, u1} G G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) ϕ) H) H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, Iff (Subgroup.Characteristic.{u1} G _inst_1 H) (forall (ϕ : MulEquiv.{u1, u1} G G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.comap.{u1, u1} G _inst_1 G _inst_1 (MulEquiv.toMonoidHom.{u1, u1} G G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) ϕ) H) H)
Case conversion may be inaccurate. Consider using '#align subgroup.characteristic_iff_comap_eq Subgroup.characteristic_iff_comap_eqₓ'. -/
@[to_additive]
theorem characteristic_iff_comap_eq : H.Characteristic ↔ ∀ ϕ : G ≃* G, H.comap ϕ.toMonoidHom = H :=
  ⟨Characteristic.fixed, Characteristic.mk⟩
#align subgroup.characteristic_iff_comap_eq Subgroup.characteristic_iff_comap_eq
#align add_subgroup.characteristic_iff_comap_eq AddSubgroup.characteristic_iff_comap_eq

/- warning: subgroup.characteristic_iff_comap_le -> Subgroup.characteristic_iff_comap_le is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, Iff (Subgroup.Characteristic.{u1} G _inst_1 H) (forall (ϕ : MulEquiv.{u1, u1} G G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))), LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.comap.{u1, u1} G _inst_1 G _inst_1 (MulEquiv.toMonoidHom.{u1, u1} G G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) ϕ) H) H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, Iff (Subgroup.Characteristic.{u1} G _inst_1 H) (forall (ϕ : MulEquiv.{u1, u1} G G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))), LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (Subgroup.comap.{u1, u1} G _inst_1 G _inst_1 (MulEquiv.toMonoidHom.{u1, u1} G G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) ϕ) H) H)
Case conversion may be inaccurate. Consider using '#align subgroup.characteristic_iff_comap_le Subgroup.characteristic_iff_comap_leₓ'. -/
@[to_additive]
theorem characteristic_iff_comap_le : H.Characteristic ↔ ∀ ϕ : G ≃* G, H.comap ϕ.toMonoidHom ≤ H :=
  characteristic_iff_comap_eq.trans
    ⟨fun h ϕ => le_of_eq (h ϕ), fun h ϕ =>
      le_antisymm (h ϕ) fun g hg => h ϕ.symm ((congr_arg (· ∈ H) (ϕ.symm_apply_apply g)).mpr hg)⟩
#align subgroup.characteristic_iff_comap_le Subgroup.characteristic_iff_comap_le
#align add_subgroup.characteristic_iff_comap_le AddSubgroup.characteristic_iff_comap_le

/- warning: subgroup.characteristic_iff_le_comap -> Subgroup.characteristic_iff_le_comap is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, Iff (Subgroup.Characteristic.{u1} G _inst_1 H) (forall (ϕ : MulEquiv.{u1, u1} G G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))), LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H (Subgroup.comap.{u1, u1} G _inst_1 G _inst_1 (MulEquiv.toMonoidHom.{u1, u1} G G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) ϕ) H))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, Iff (Subgroup.Characteristic.{u1} G _inst_1 H) (forall (ϕ : MulEquiv.{u1, u1} G G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))), LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) H (Subgroup.comap.{u1, u1} G _inst_1 G _inst_1 (MulEquiv.toMonoidHom.{u1, u1} G G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) ϕ) H))
Case conversion may be inaccurate. Consider using '#align subgroup.characteristic_iff_le_comap Subgroup.characteristic_iff_le_comapₓ'. -/
@[to_additive]
theorem characteristic_iff_le_comap : H.Characteristic ↔ ∀ ϕ : G ≃* G, H ≤ H.comap ϕ.toMonoidHom :=
  characteristic_iff_comap_eq.trans
    ⟨fun h ϕ => ge_of_eq (h ϕ), fun h ϕ =>
      le_antisymm (fun g hg => (congr_arg (· ∈ H) (ϕ.symm_apply_apply g)).mp (h ϕ.symm hg)) (h ϕ)⟩
#align subgroup.characteristic_iff_le_comap Subgroup.characteristic_iff_le_comap
#align add_subgroup.characteristic_iff_le_comap AddSubgroup.characteristic_iff_le_comap

/- warning: subgroup.characteristic_iff_map_eq -> Subgroup.characteristic_iff_map_eq is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, Iff (Subgroup.Characteristic.{u1} G _inst_1 H) (forall (ϕ : MulEquiv.{u1, u1} G G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.map.{u1, u1} G _inst_1 G _inst_1 (MulEquiv.toMonoidHom.{u1, u1} G G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) ϕ) H) H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, Iff (Subgroup.Characteristic.{u1} G _inst_1 H) (forall (ϕ : MulEquiv.{u1, u1} G G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.map.{u1, u1} G _inst_1 G _inst_1 (MulEquiv.toMonoidHom.{u1, u1} G G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) ϕ) H) H)
Case conversion may be inaccurate. Consider using '#align subgroup.characteristic_iff_map_eq Subgroup.characteristic_iff_map_eqₓ'. -/
@[to_additive]
theorem characteristic_iff_map_eq : H.Characteristic ↔ ∀ ϕ : G ≃* G, H.map ϕ.toMonoidHom = H :=
  by
  simp_rw [map_equiv_eq_comap_symm]
  exact characteristic_iff_comap_eq.trans ⟨fun h ϕ => h ϕ.symm, fun h ϕ => h ϕ.symm⟩
#align subgroup.characteristic_iff_map_eq Subgroup.characteristic_iff_map_eq
#align add_subgroup.characteristic_iff_map_eq AddSubgroup.characteristic_iff_map_eq

/- warning: subgroup.characteristic_iff_map_le -> Subgroup.characteristic_iff_map_le is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, Iff (Subgroup.Characteristic.{u1} G _inst_1 H) (forall (ϕ : MulEquiv.{u1, u1} G G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))), LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.map.{u1, u1} G _inst_1 G _inst_1 (MulEquiv.toMonoidHom.{u1, u1} G G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) ϕ) H) H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, Iff (Subgroup.Characteristic.{u1} G _inst_1 H) (forall (ϕ : MulEquiv.{u1, u1} G G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))), LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (Subgroup.map.{u1, u1} G _inst_1 G _inst_1 (MulEquiv.toMonoidHom.{u1, u1} G G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) ϕ) H) H)
Case conversion may be inaccurate. Consider using '#align subgroup.characteristic_iff_map_le Subgroup.characteristic_iff_map_leₓ'. -/
@[to_additive]
theorem characteristic_iff_map_le : H.Characteristic ↔ ∀ ϕ : G ≃* G, H.map ϕ.toMonoidHom ≤ H :=
  by
  simp_rw [map_equiv_eq_comap_symm]
  exact characteristic_iff_comap_le.trans ⟨fun h ϕ => h ϕ.symm, fun h ϕ => h ϕ.symm⟩
#align subgroup.characteristic_iff_map_le Subgroup.characteristic_iff_map_le
#align add_subgroup.characteristic_iff_map_le AddSubgroup.characteristic_iff_map_le

/- warning: subgroup.characteristic_iff_le_map -> Subgroup.characteristic_iff_le_map is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, Iff (Subgroup.Characteristic.{u1} G _inst_1 H) (forall (ϕ : MulEquiv.{u1, u1} G G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))), LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H (Subgroup.map.{u1, u1} G _inst_1 G _inst_1 (MulEquiv.toMonoidHom.{u1, u1} G G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) ϕ) H))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, Iff (Subgroup.Characteristic.{u1} G _inst_1 H) (forall (ϕ : MulEquiv.{u1, u1} G G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))), LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) H (Subgroup.map.{u1, u1} G _inst_1 G _inst_1 (MulEquiv.toMonoidHom.{u1, u1} G G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) ϕ) H))
Case conversion may be inaccurate. Consider using '#align subgroup.characteristic_iff_le_map Subgroup.characteristic_iff_le_mapₓ'. -/
@[to_additive]
theorem characteristic_iff_le_map : H.Characteristic ↔ ∀ ϕ : G ≃* G, H ≤ H.map ϕ.toMonoidHom :=
  by
  simp_rw [map_equiv_eq_comap_symm]
  exact characteristic_iff_le_comap.trans ⟨fun h ϕ => h ϕ.symm, fun h ϕ => h ϕ.symm⟩
#align subgroup.characteristic_iff_le_map Subgroup.characteristic_iff_le_map
#align add_subgroup.characteristic_iff_le_map AddSubgroup.characteristic_iff_le_map

/- warning: subgroup.bot_characteristic -> Subgroup.botCharacteristic is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Subgroup.Characteristic.{u1} G _inst_1 (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Subgroup.Characteristic.{u1} G _inst_1 (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1))
Case conversion may be inaccurate. Consider using '#align subgroup.bot_characteristic Subgroup.botCharacteristicₓ'. -/
@[to_additive]
instance botCharacteristic : Characteristic (⊥ : Subgroup G) :=
  characteristic_iff_le_map.mpr fun ϕ => bot_le
#align subgroup.bot_characteristic Subgroup.botCharacteristic
#align add_subgroup.bot_characteristic AddSubgroup.botCharacteristic

/- warning: subgroup.top_characteristic -> Subgroup.topCharacteristic is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Subgroup.Characteristic.{u1} G _inst_1 (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasTop.{u1} G _inst_1))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Subgroup.Characteristic.{u1} G _inst_1 (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instTopSubgroup.{u1} G _inst_1))
Case conversion may be inaccurate. Consider using '#align subgroup.top_characteristic Subgroup.topCharacteristicₓ'. -/
@[to_additive]
instance topCharacteristic : Characteristic (⊤ : Subgroup G) :=
  characteristic_iff_map_le.mpr fun ϕ => le_top
#align subgroup.top_characteristic Subgroup.topCharacteristic
#align add_subgroup.top_characteristic AddSubgroup.topCharacteristic

variable (G)

#print Subgroup.center /-
/-- The center of a group `G` is the set of elements that commute with everything in `G` -/
@[to_additive
      "The center of an additive group `G` is the set of elements that commute with\neverything in `G`"]
def center : Subgroup G :=
  { Submonoid.center G with
    carrier := Set.center G
    inv_mem' := fun a => Set.inv_mem_center }
#align subgroup.center Subgroup.center
#align add_subgroup.center AddSubgroup.center
-/

/- warning: subgroup.coe_center -> Subgroup.coe_center is a dubious translation:
lean 3 declaration is
  forall (G : Type.{u1}) [_inst_1 : Group.{u1} G], Eq.{succ u1} (Set.{u1} G) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.center.{u1} G _inst_1)) (Set.center.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))
but is expected to have type
  forall (G : Type.{u1}) [_inst_1 : Group.{u1} G], Eq.{succ u1} (Set.{u1} G) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (Subgroup.center.{u1} G _inst_1)) (Set.center.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))
Case conversion may be inaccurate. Consider using '#align subgroup.coe_center Subgroup.coe_centerₓ'. -/
@[to_additive]
theorem coe_center : ↑(center G) = Set.center G :=
  rfl
#align subgroup.coe_center Subgroup.coe_center
#align add_subgroup.coe_center AddSubgroup.coe_center

#print Subgroup.center_toSubmonoid /-
@[simp, to_additive]
theorem center_toSubmonoid : (center G).toSubmonoid = Submonoid.center G :=
  rfl
#align subgroup.center_to_submonoid Subgroup.center_toSubmonoid
#align add_subgroup.center_to_add_submonoid AddSubgroup.center_toAddSubmonoid
-/

variable {G}

/- warning: subgroup.mem_center_iff -> Subgroup.mem_center_iff is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {z : G}, Iff (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) z (Subgroup.center.{u1} G _inst_1)) (forall (g : G), Eq.{succ u1} G (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g z) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) z g))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {z : G}, Iff (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) z (Subgroup.center.{u1} G _inst_1)) (forall (g : G), Eq.{succ u1} G (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g z) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) z g))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_center_iff Subgroup.mem_center_iffₓ'. -/
@[to_additive]
theorem mem_center_iff {z : G} : z ∈ center G ↔ ∀ g, g * z = z * g :=
  Iff.rfl
#align subgroup.mem_center_iff Subgroup.mem_center_iff
#align add_subgroup.mem_center_iff AddSubgroup.mem_center_iff

/- warning: subgroup.decidable_mem_center -> Subgroup.decidableMemCenter is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (z : G) [_inst_4 : Decidable (forall (g : G), Eq.{succ u1} G (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g z) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) z g))], Decidable (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) z (Subgroup.center.{u1} G _inst_1))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (z : G) [_inst_4 : Decidable (forall (g : G), Eq.{succ u1} G (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g z) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) z g))], Decidable (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) z (Subgroup.center.{u1} G _inst_1))
Case conversion may be inaccurate. Consider using '#align subgroup.decidable_mem_center Subgroup.decidableMemCenterₓ'. -/
instance decidableMemCenter (z : G) [Decidable (∀ g, g * z = z * g)] : Decidable (z ∈ center G) :=
  decidable_of_iff' _ mem_center_iff
#align subgroup.decidable_mem_center Subgroup.decidableMemCenter

#print Subgroup.centerCharacteristic /-
@[to_additive]
instance centerCharacteristic : (center G).Characteristic :=
  by
  refine' characteristic_iff_comap_le.mpr fun ϕ g hg h => _
  rw [← ϕ.injective.eq_iff, ϕ.map_mul, ϕ.map_mul]
  exact hg (ϕ h)
#align subgroup.center_characteristic Subgroup.centerCharacteristic
#align add_subgroup.center_characteristic AddSubgroup.centerCharacteristic
-/

/- warning: comm_group.center_eq_top -> CommGroup.center_eq_top is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_4 : CommGroup.{u1} G], Eq.{succ u1} (Subgroup.{u1} G (CommGroup.toGroup.{u1} G _inst_4)) (Subgroup.center.{u1} G (CommGroup.toGroup.{u1} G _inst_4)) (Top.top.{u1} (Subgroup.{u1} G (CommGroup.toGroup.{u1} G _inst_4)) (Subgroup.hasTop.{u1} G (CommGroup.toGroup.{u1} G _inst_4)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_4 : CommGroup.{u1} G], Eq.{succ u1} (Subgroup.{u1} G (CommGroup.toGroup.{u1} G _inst_4)) (Subgroup.center.{u1} G (CommGroup.toGroup.{u1} G _inst_4)) (Top.top.{u1} (Subgroup.{u1} G (CommGroup.toGroup.{u1} G _inst_4)) (Subgroup.instTopSubgroup.{u1} G (CommGroup.toGroup.{u1} G _inst_4)))
Case conversion may be inaccurate. Consider using '#align comm_group.center_eq_top CommGroup.center_eq_topₓ'. -/
theorem CommGroup.center_eq_top {G : Type _} [CommGroup G] : center G = ⊤ :=
  by
  rw [eq_top_iff']
  intro x y
  exact mul_comm y x
#align comm_group.center_eq_top CommGroup.center_eq_top

/- warning: group.comm_group_of_center_eq_top -> Group.commGroupOfCenterEqTop is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.center.{u1} G _inst_1) (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasTop.{u1} G _inst_1))) -> (CommGroup.{u1} G)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.center.{u1} G _inst_1) (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instTopSubgroup.{u1} G _inst_1))) -> (CommGroup.{u1} G)
Case conversion may be inaccurate. Consider using '#align group.comm_group_of_center_eq_top Group.commGroupOfCenterEqTopₓ'. -/
/-- A group is commutative if the center is the whole group -/
def Group.commGroupOfCenterEqTop (h : center G = ⊤) : CommGroup G :=
  { (_ : Group G) with
    mul_comm := by
      rw [eq_top_iff'] at h
      intro x y
      exact h y x }
#align group.comm_group_of_center_eq_top Group.commGroupOfCenterEqTop

variable {G} (H)

section Normalizer

#print Subgroup.normalizer /-
/-- The `normalizer` of `H` is the largest subgroup of `G` inside which `H` is normal. -/
@[to_additive "The `normalizer` of `H` is the largest subgroup of `G` inside which `H` is normal."]
def normalizer : Subgroup G
    where
  carrier := { g : G | ∀ n, n ∈ H ↔ g * n * g⁻¹ ∈ H }
  one_mem' := by simp
  mul_mem' a b (ha : ∀ n, n ∈ H ↔ a * n * a⁻¹ ∈ H) (hb : ∀ n, n ∈ H ↔ b * n * b⁻¹ ∈ H) n :=
    by
    rw [hb, ha]
    simp [mul_assoc]
  inv_mem' a (ha : ∀ n, n ∈ H ↔ a * n * a⁻¹ ∈ H) n :=
    by
    rw [ha (a⁻¹ * n * a⁻¹⁻¹)]
    simp [mul_assoc]
#align subgroup.normalizer Subgroup.normalizer
#align add_subgroup.normalizer AddSubgroup.normalizer
-/

#print Subgroup.setNormalizer /-
-- variant for sets.
-- TODO should this replace `normalizer`?
/-- The `set_normalizer` of `S` is the subgroup of `G` whose elements satisfy `g*S*g⁻¹=S` -/
@[to_additive
      "The `set_normalizer` of `S` is the subgroup of `G` whose elements satisfy\n`g+S-g=S`."]
def setNormalizer (S : Set G) : Subgroup G
    where
  carrier := { g : G | ∀ n, n ∈ S ↔ g * n * g⁻¹ ∈ S }
  one_mem' := by simp
  mul_mem' a b (ha : ∀ n, n ∈ S ↔ a * n * a⁻¹ ∈ S) (hb : ∀ n, n ∈ S ↔ b * n * b⁻¹ ∈ S) n :=
    by
    rw [hb, ha]
    simp [mul_assoc]
  inv_mem' a (ha : ∀ n, n ∈ S ↔ a * n * a⁻¹ ∈ S) n :=
    by
    rw [ha (a⁻¹ * n * a⁻¹⁻¹)]
    simp [mul_assoc]
#align subgroup.set_normalizer Subgroup.setNormalizer
#align add_subgroup.set_normalizer AddSubgroup.setNormalizer
-/

variable {H}

/- warning: subgroup.mem_normalizer_iff -> Subgroup.mem_normalizer_iff is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {g : G}, Iff (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) g (Subgroup.normalizer.{u1} G _inst_1 H)) (forall (h : G), Iff (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) h H) (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g h) (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) g)) H))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {g : G}, Iff (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) g (Subgroup.normalizer.{u1} G _inst_1 H)) (forall (h : G), Iff (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) h H) (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g h) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) g)) H))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_normalizer_iff Subgroup.mem_normalizer_iffₓ'. -/
@[to_additive]
theorem mem_normalizer_iff {g : G} : g ∈ H.normalizer ↔ ∀ h, h ∈ H ↔ g * h * g⁻¹ ∈ H :=
  Iff.rfl
#align subgroup.mem_normalizer_iff Subgroup.mem_normalizer_iff
#align add_subgroup.mem_normalizer_iff AddSubgroup.mem_normalizer_iff

/- warning: subgroup.mem_normalizer_iff'' -> Subgroup.mem_normalizer_iff'' is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {g : G}, Iff (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) g (Subgroup.normalizer.{u1} G _inst_1 H)) (forall (h : G), Iff (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) h H) (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) g) h) g) H))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {g : G}, Iff (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) g (Subgroup.normalizer.{u1} G _inst_1 H)) (forall (h : G), Iff (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) h H) (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) g) h) g) H))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_normalizer_iff'' Subgroup.mem_normalizer_iff''ₓ'. -/
@[to_additive]
theorem mem_normalizer_iff'' {g : G} : g ∈ H.normalizer ↔ ∀ h : G, h ∈ H ↔ g⁻¹ * h * g ∈ H := by
  rw [← inv_mem_iff, mem_normalizer_iff, inv_inv]
#align subgroup.mem_normalizer_iff'' Subgroup.mem_normalizer_iff''
#align add_subgroup.mem_normalizer_iff'' AddSubgroup.mem_normalizer_iff''

/- warning: subgroup.mem_normalizer_iff' -> Subgroup.mem_normalizer_iff' is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {g : G}, Iff (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) g (Subgroup.normalizer.{u1} G _inst_1 H)) (forall (n : G), Iff (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) n g) H) (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g n) H))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {g : G}, Iff (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) g (Subgroup.normalizer.{u1} G _inst_1 H)) (forall (n : G), Iff (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) n g) H) (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g n) H))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_normalizer_iff' Subgroup.mem_normalizer_iff'ₓ'. -/
@[to_additive]
theorem mem_normalizer_iff' {g : G} : g ∈ H.normalizer ↔ ∀ n, n * g ∈ H ↔ g * n ∈ H :=
  ⟨fun h n => by rw [h, mul_assoc, mul_inv_cancel_right], fun h n => by
    rw [mul_assoc, ← h, inv_mul_cancel_right]⟩
#align subgroup.mem_normalizer_iff' Subgroup.mem_normalizer_iff'
#align add_subgroup.mem_normalizer_iff' AddSubgroup.mem_normalizer_iff'

/- warning: subgroup.le_normalizer -> Subgroup.le_normalizer is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H (Subgroup.normalizer.{u1} G _inst_1 H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) H (Subgroup.normalizer.{u1} G _inst_1 H)
Case conversion may be inaccurate. Consider using '#align subgroup.le_normalizer Subgroup.le_normalizerₓ'. -/
@[to_additive]
theorem le_normalizer : H ≤ normalizer H := fun x xH n => by
  rw [H.mul_mem_cancel_right (H.inv_mem xH), H.mul_mem_cancel_left xH]
#align subgroup.le_normalizer Subgroup.le_normalizer
#align add_subgroup.le_normalizer AddSubgroup.le_normalizer

/- warning: subgroup.normal_in_normalizer -> Subgroup.normal_in_normalizer is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, Subgroup.Normal.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.normalizer.{u1} G _inst_1 H)) (Subgroup.toGroup.{u1} G _inst_1 (Subgroup.normalizer.{u1} G _inst_1 H)) (Subgroup.subgroupOf.{u1} G _inst_1 H (Subgroup.normalizer.{u1} G _inst_1 H))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, Subgroup.Normal.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.normalizer.{u1} G _inst_1 H))) (Subgroup.toGroup.{u1} G _inst_1 (Subgroup.normalizer.{u1} G _inst_1 H)) (Subgroup.subgroupOf.{u1} G _inst_1 H (Subgroup.normalizer.{u1} G _inst_1 H))
Case conversion may be inaccurate. Consider using '#align subgroup.normal_in_normalizer Subgroup.normal_in_normalizerₓ'. -/
@[to_additive]
instance (priority := 100) normal_in_normalizer : (H.subgroupOf H.normalizer).Normal :=
  ⟨fun x xH g => by simpa using (g.2 x).1 xH⟩
#align subgroup.normal_in_normalizer Subgroup.normal_in_normalizer
#align add_subgroup.normal_in_normalizer AddSubgroup.normal_in_normalizer

/- warning: subgroup.normalizer_eq_top -> Subgroup.normalizer_eq_top is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, Iff (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.normalizer.{u1} G _inst_1 H) (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasTop.{u1} G _inst_1))) (Subgroup.Normal.{u1} G _inst_1 H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, Iff (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.normalizer.{u1} G _inst_1 H) (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instTopSubgroup.{u1} G _inst_1))) (Subgroup.Normal.{u1} G _inst_1 H)
Case conversion may be inaccurate. Consider using '#align subgroup.normalizer_eq_top Subgroup.normalizer_eq_topₓ'. -/
@[to_additive]
theorem normalizer_eq_top : H.normalizer = ⊤ ↔ H.Normal :=
  eq_top_iff.trans
    ⟨fun h => ⟨fun a ha b => (h (mem_top b) a).mp ha⟩, fun h a ha b =>
      ⟨fun hb => h.conj_mem b hb a, fun hb => by rwa [h.mem_comm_iff, inv_mul_cancel_left] at hb⟩⟩
#align subgroup.normalizer_eq_top Subgroup.normalizer_eq_top
#align add_subgroup.normalizer_eq_top AddSubgroup.normalizer_eq_top

/- warning: subgroup.center_le_normalizer -> Subgroup.center_le_normalizer is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.center.{u1} G _inst_1) (Subgroup.normalizer.{u1} G _inst_1 H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (Subgroup.center.{u1} G _inst_1) (Subgroup.normalizer.{u1} G _inst_1 H)
Case conversion may be inaccurate. Consider using '#align subgroup.center_le_normalizer Subgroup.center_le_normalizerₓ'. -/
@[to_additive]
theorem center_le_normalizer : center G ≤ H.normalizer := fun x hx y => by
  simp [← mem_center_iff.mp hx y, mul_assoc]
#align subgroup.center_le_normalizer Subgroup.center_le_normalizer
#align add_subgroup.center_le_normalizer AddSubgroup.center_le_normalizer

open Classical

/- warning: subgroup.le_normalizer_of_normal -> Subgroup.le_normalizer_of_normal is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1} [hK : Subgroup.Normal.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K) (Subgroup.subgroupOf.{u1} G _inst_1 H K)], (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H K) -> (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) K (Subgroup.normalizer.{u1} G _inst_1 H))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1} [hK : Subgroup.Normal.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Subgroup.toGroup.{u1} G _inst_1 K) (Subgroup.subgroupOf.{u1} G _inst_1 H K)], (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) H K) -> (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) K (Subgroup.normalizer.{u1} G _inst_1 H))
Case conversion may be inaccurate. Consider using '#align subgroup.le_normalizer_of_normal Subgroup.le_normalizer_of_normalₓ'. -/
@[to_additive]
theorem le_normalizer_of_normal [hK : (H.subgroupOf K).Normal] (HK : H ≤ K) : K ≤ H.normalizer :=
  fun x hx y =>
  ⟨fun yH => hK.conj_mem ⟨y, HK yH⟩ yH ⟨x, hx⟩, fun yH => by
    simpa [mem_subgroup_of, mul_assoc] using
      hK.conj_mem ⟨x * y * x⁻¹, HK yH⟩ yH ⟨x⁻¹, K.inv_mem hx⟩⟩
#align subgroup.le_normalizer_of_normal Subgroup.le_normalizer_of_normal
#align add_subgroup.le_normalizer_of_normal AddSubgroup.le_normalizer_of_normal

variable {N : Type _} [Group N]

/- warning: subgroup.le_normalizer_comap -> Subgroup.le_normalizer_comap is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))), LE.le.{u2} (Subgroup.{u2} N _inst_4) (Preorder.toLE.{u2} (Subgroup.{u2} N _inst_4) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} N _inst_4) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)))) (Subgroup.comap.{u2, u1} N _inst_4 G _inst_1 f (Subgroup.normalizer.{u1} G _inst_1 H)) (Subgroup.normalizer.{u2} N _inst_4 (Subgroup.comap.{u2, u1} N _inst_4 G _inst_1 f H))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))), LE.le.{u2} (Subgroup.{u2} N _inst_4) (Preorder.toLE.{u2} (Subgroup.{u2} N _inst_4) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} N _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} N _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u2} N _inst_4))))) (Subgroup.comap.{u2, u1} N _inst_4 G _inst_1 f (Subgroup.normalizer.{u1} G _inst_1 H)) (Subgroup.normalizer.{u2} N _inst_4 (Subgroup.comap.{u2, u1} N _inst_4 G _inst_1 f H))
Case conversion may be inaccurate. Consider using '#align subgroup.le_normalizer_comap Subgroup.le_normalizer_comapₓ'. -/
/-- The preimage of the normalizer is contained in the normalizer of the preimage. -/
@[to_additive "The preimage of the normalizer is contained in the normalizer of the preimage."]
theorem le_normalizer_comap (f : N →* G) : H.normalizer.comap f ≤ (H.comap f).normalizer := fun x =>
  by
  simp only [mem_normalizer_iff, mem_comap]
  intro h n
  simp [h (f n)]
#align subgroup.le_normalizer_comap Subgroup.le_normalizer_comap
#align add_subgroup.le_normalizer_comap AddSubgroup.le_normalizer_comap

/- warning: subgroup.le_normalizer_map -> Subgroup.le_normalizer_map is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), LE.le.{u2} (Subgroup.{u2} N _inst_4) (Preorder.toLE.{u2} (Subgroup.{u2} N _inst_4) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} N _inst_4) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)))) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f (Subgroup.normalizer.{u1} G _inst_1 H)) (Subgroup.normalizer.{u2} N _inst_4 (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {H : Subgroup.{u2} G _inst_1} {N : Type.{u1}} [_inst_4 : Group.{u1} N] (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))), LE.le.{u1} (Subgroup.{u1} N _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} N _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} N _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} N _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u1} N _inst_4))))) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f (Subgroup.normalizer.{u2} G _inst_1 H)) (Subgroup.normalizer.{u1} N _inst_4 (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H))
Case conversion may be inaccurate. Consider using '#align subgroup.le_normalizer_map Subgroup.le_normalizer_mapₓ'. -/
/-- The image of the normalizer is contained in the normalizer of the image. -/
@[to_additive "The image of the normalizer is contained in the normalizer of the image."]
theorem le_normalizer_map (f : G →* N) : H.normalizer.map f ≤ (H.map f).normalizer := fun _ =>
  by
  simp only [and_imp, exists_prop, mem_map, exists_imp, mem_normalizer_iff]
  rintro x hx rfl n
  constructor
  · rintro ⟨y, hy, rfl⟩
    use x * y * x⁻¹, (hx y).1 hy
    simp
  · rintro ⟨y, hyH, hy⟩
    use x⁻¹ * y * x
    rw [hx]
    simp [hy, hyH, mul_assoc]
#align subgroup.le_normalizer_map Subgroup.le_normalizer_map
#align add_subgroup.le_normalizer_map AddSubgroup.le_normalizer_map

variable (G)

#print NormalizerCondition /-
/-- Every proper subgroup `H` of `G` is a proper normal subgroup of the normalizer of `H` in `G`. -/
def NormalizerCondition :=
  ∀ H : Subgroup G, H < ⊤ → H < normalizer H
#align normalizer_condition NormalizerCondition
-/

variable {G}

/- warning: normalizer_condition_iff_only_full_group_self_normalizing -> normalizerCondition_iff_only_full_group_self_normalizing is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Iff (NormalizerCondition.{u1} G _inst_1) (forall (H : Subgroup.{u1} G _inst_1), (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.normalizer.{u1} G _inst_1 H) H) -> (Eq.{succ u1} (Subgroup.{u1} G _inst_1) H (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasTop.{u1} G _inst_1))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Iff (NormalizerCondition.{u1} G _inst_1) (forall (H : Subgroup.{u1} G _inst_1), (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.normalizer.{u1} G _inst_1 H) H) -> (Eq.{succ u1} (Subgroup.{u1} G _inst_1) H (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instTopSubgroup.{u1} G _inst_1))))
Case conversion may be inaccurate. Consider using '#align normalizer_condition_iff_only_full_group_self_normalizing normalizerCondition_iff_only_full_group_self_normalizingₓ'. -/
/-- Alternative phrasing of the normalizer condition: Only the full group is self-normalizing.
This may be easier to work with, as it avoids inequalities and negations.  -/
theorem normalizerCondition_iff_only_full_group_self_normalizing :
    NormalizerCondition G ↔ ∀ H : Subgroup G, H.normalizer = H → H = ⊤ :=
  by
  apply forall_congr'; intro H
  simp only [lt_iff_le_and_ne, le_normalizer, true_and_iff, le_top, Ne.def]
  tauto
#align normalizer_condition_iff_only_full_group_self_normalizing normalizerCondition_iff_only_full_group_self_normalizing

variable (H)

/- warning: subgroup.normalizer_condition.normal_of_coatom -> Subgroup.NormalizerCondition.normal_of_coatom is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), (NormalizerCondition.{u1} G _inst_1) -> (IsCoatom.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1))) (BoundedOrder.toOrderTop.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (CompleteLattice.toBoundedOrder.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))) H) -> (Subgroup.Normal.{u1} G _inst_1 H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), (NormalizerCondition.{u1} G _inst_1) -> (IsCoatom.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) (BoundedOrder.toOrderTop.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (CompleteLattice.toBoundedOrder.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))) H) -> (Subgroup.Normal.{u1} G _inst_1 H)
Case conversion may be inaccurate. Consider using '#align subgroup.normalizer_condition.normal_of_coatom Subgroup.NormalizerCondition.normal_of_coatomₓ'. -/
/-- In a group that satisifes the normalizer condition, every maximal subgroup is normal -/
theorem NormalizerCondition.normal_of_coatom (hnc : NormalizerCondition G) (hmax : IsCoatom H) :
    H.Normal :=
  normalizer_eq_top.mp (hmax.2 _ (hnc H (lt_top_iff_ne_top.mpr hmax.1)))
#align subgroup.normalizer_condition.normal_of_coatom Subgroup.NormalizerCondition.normal_of_coatom

end Normalizer

section Centralizer

#print Subgroup.centralizer /-
/-- The `centralizer` of `H` is the subgroup of `g : G` commuting with every `h : H`. -/
@[to_additive
      "The `centralizer` of `H` is the additive subgroup of `g : G` commuting with\nevery `h : H`."]
def centralizer : Subgroup G :=
  { Submonoid.centralizer ↑H with
    carrier := Set.centralizer H
    inv_mem' := fun g => Set.inv_mem_centralizer }
#align subgroup.centralizer Subgroup.centralizer
#align add_subgroup.centralizer AddSubgroup.centralizer
-/

variable {H}

/- warning: subgroup.mem_centralizer_iff -> Subgroup.mem_centralizer_iff is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {g : G}, Iff (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) g (Subgroup.centralizer.{u1} G _inst_1 H)) (forall (h : G), (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) h H) -> (Eq.{succ u1} G (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) h g) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g h)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {g : G}, Iff (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) g (Subgroup.centralizer.{u1} G _inst_1 H)) (forall (h : G), (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) h H) -> (Eq.{succ u1} G (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) h g) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g h)))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_centralizer_iff Subgroup.mem_centralizer_iffₓ'. -/
@[to_additive]
theorem mem_centralizer_iff {g : G} : g ∈ H.centralizer ↔ ∀ h ∈ H, h * g = g * h :=
  Iff.rfl
#align subgroup.mem_centralizer_iff Subgroup.mem_centralizer_iff
#align add_subgroup.mem_centralizer_iff AddSubgroup.mem_centralizer_iff

/- warning: subgroup.mem_centralizer_iff_commutator_eq_one -> Subgroup.mem_centralizer_iff_commutator_eq_one is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {g : G}, Iff (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) g (Subgroup.centralizer.{u1} G _inst_1 H)) (forall (h : G), (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) h H) -> (Eq.{succ u1} G (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) h g) (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) h)) (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) g)) (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {g : G}, Iff (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) g (Subgroup.centralizer.{u1} G _inst_1 H)) (forall (h : G), (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) h H) -> (Eq.{succ u1} G (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) h g) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) h)) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) g)) (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_centralizer_iff_commutator_eq_one Subgroup.mem_centralizer_iff_commutator_eq_oneₓ'. -/
@[to_additive]
theorem mem_centralizer_iff_commutator_eq_one {g : G} :
    g ∈ H.centralizer ↔ ∀ h ∈ H, h * g * h⁻¹ * g⁻¹ = 1 := by
  simp only [mem_centralizer_iff, mul_inv_eq_iff_eq_mul, one_mul]
#align subgroup.mem_centralizer_iff_commutator_eq_one Subgroup.mem_centralizer_iff_commutator_eq_one
#align add_subgroup.mem_centralizer_iff_commutator_eq_zero AddSubgroup.mem_centralizer_iff_commutator_eq_zero

/- warning: subgroup.centralizer_top -> Subgroup.centralizer_top is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.centralizer.{u1} G _inst_1 (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasTop.{u1} G _inst_1))) (Subgroup.center.{u1} G _inst_1)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.centralizer.{u1} G _inst_1 (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instTopSubgroup.{u1} G _inst_1))) (Subgroup.center.{u1} G _inst_1)
Case conversion may be inaccurate. Consider using '#align subgroup.centralizer_top Subgroup.centralizer_topₓ'. -/
@[to_additive]
theorem centralizer_top : centralizer ⊤ = center G :=
  SetLike.ext' (Set.centralizer_univ G)
#align subgroup.centralizer_top Subgroup.centralizer_top
#align add_subgroup.centralizer_top AddSubgroup.centralizer_top

/- warning: subgroup.le_centralizer_iff -> Subgroup.le_centralizer_iff is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1}, Iff (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H (Subgroup.centralizer.{u1} G _inst_1 K)) (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) K (Subgroup.centralizer.{u1} G _inst_1 H))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1}, Iff (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) H (Subgroup.centralizer.{u1} G _inst_1 K)) (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) K (Subgroup.centralizer.{u1} G _inst_1 H))
Case conversion may be inaccurate. Consider using '#align subgroup.le_centralizer_iff Subgroup.le_centralizer_iffₓ'. -/
@[to_additive]
theorem le_centralizer_iff : H ≤ K.centralizer ↔ K ≤ H.centralizer :=
  ⟨fun h x hx y hy => (h hy x hx).symm, fun h x hx y hy => (h hy x hx).symm⟩
#align subgroup.le_centralizer_iff Subgroup.le_centralizer_iff
#align add_subgroup.le_centralizer_iff AddSubgroup.le_centralizer_iff

/- warning: subgroup.centralizer_le -> Subgroup.centralizer_le is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1}, (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H K) -> (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.centralizer.{u1} G _inst_1 K) (Subgroup.centralizer.{u1} G _inst_1 H))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1}, (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) H K) -> (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (Subgroup.centralizer.{u1} G _inst_1 K) (Subgroup.centralizer.{u1} G _inst_1 H))
Case conversion may be inaccurate. Consider using '#align subgroup.centralizer_le Subgroup.centralizer_leₓ'. -/
@[to_additive]
theorem centralizer_le (h : H ≤ K) : centralizer K ≤ centralizer H :=
  Submonoid.centralizer_le h
#align subgroup.centralizer_le Subgroup.centralizer_le
#align add_subgroup.centralizer_le AddSubgroup.centralizer_le

#print Subgroup.Centralizer.characteristic /-
@[to_additive]
instance Subgroup.Centralizer.characteristic [hH : H.Characteristic] :
    H.centralizer.Characteristic :=
  by
  refine' subgroup.characteristic_iff_comap_le.mpr fun ϕ g hg h hh => ϕ.Injective _
  rw [map_mul, map_mul]
  exact hg (ϕ h) (subgroup.characteristic_iff_le_comap.mp hH ϕ hh)
#align subgroup.subgroup.centralizer.characteristic Subgroup.Centralizer.characteristic
#align add_subgroup.subgroup.centralizer.characteristic AddSubgroup.Centralizer.characteristic
-/

end Centralizer

#print Subgroup.IsCommutative /-
/-- Commutivity of a subgroup -/
structure IsCommutative : Prop where
  is_comm : IsCommutative H (· * ·)
#align subgroup.is_commutative Subgroup.IsCommutative
-/

attribute [class] IsCommutative

#print AddSubgroup.IsCommutative /-
/-- Commutivity of an additive subgroup -/
structure AddSubgroup.IsCommutative (H : AddSubgroup A) : Prop where
  is_comm : IsCommutative H (· + ·)
#align add_subgroup.is_commutative AddSubgroup.IsCommutative
-/

attribute [to_additive AddSubgroup.IsCommutative] Subgroup.IsCommutative

attribute [class] AddSubgroup.IsCommutative

/- warning: subgroup.is_commutative.comm_group -> Subgroup.IsCommutative.commGroup is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) [h : Subgroup.IsCommutative.{u1} G _inst_1 H], CommGroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) [h : Subgroup.IsCommutative.{u1} G _inst_1 H], CommGroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H))
Case conversion may be inaccurate. Consider using '#align subgroup.is_commutative.comm_group Subgroup.IsCommutative.commGroupₓ'. -/
/-- A commutative subgroup is commutative. -/
@[to_additive "A commutative subgroup is commutative."]
instance IsCommutative.commGroup [h : H.IsCommutative] : CommGroup H :=
  { H.toGroup with mul_comm := h.is_comm.comm }
#align subgroup.is_commutative.comm_group Subgroup.IsCommutative.commGroup
#align add_subgroup.is_commutative.add_comm_group AddSubgroup.IsCommutative.addCommGroup

#print Subgroup.center.isCommutative /-
instance center.isCommutative : (center G).IsCommutative :=
  ⟨⟨fun a b => Subtype.ext (b.2 a)⟩⟩
#align subgroup.center.is_commutative Subgroup.center.isCommutative
-/

#print Subgroup.map_isCommutative /-
@[to_additive]
instance map_isCommutative (f : G →* G') [H.IsCommutative] : (H.map f).IsCommutative :=
  ⟨⟨by
      rintro ⟨-, a, ha, rfl⟩ ⟨-, b, hb, rfl⟩
      rw [Subtype.ext_iff, coe_mul, coe_mul, Subtype.coe_mk, Subtype.coe_mk, ← map_mul, ← map_mul]
      exact congr_arg f (subtype.ext_iff.mp (mul_comm ⟨a, ha⟩ ⟨b, hb⟩))⟩⟩
#align subgroup.map_is_commutative Subgroup.map_isCommutative
#align add_subgroup.map_is_commutative AddSubgroup.map_isCommutative
-/

/- warning: subgroup.comap_injective_is_commutative -> Subgroup.comap_injective_isCommutative is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} {G' : Type.{u2}} [_inst_1 : Group.{u1} G] [_inst_2 : Group.{u2} G'] (H : Subgroup.{u1} G _inst_1) {f : MonoidHom.{u2, u1} G' G (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))}, (Function.Injective.{succ u2, succ u1} G' G (coeFn.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MonoidHom.{u2, u1} G' G (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{u2, u1} G' G (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => G' -> G) (MonoidHom.hasCoeToFun.{u2, u1} G' G (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) f)) -> (forall [_inst_4 : Subgroup.IsCommutative.{u1} G _inst_1 H], Subgroup.IsCommutative.{u2} G' _inst_2 (Subgroup.comap.{u2, u1} G' _inst_2 G _inst_1 f H))
but is expected to have type
  forall {G : Type.{u1}} {G' : Type.{u2}} [_inst_1 : Group.{u1} G] [_inst_2 : Group.{u2} G'] (H : Subgroup.{u1} G _inst_1) {f : MonoidHom.{u2, u1} G' G (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))}, (Function.Injective.{succ u2, succ u1} G' G (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (MonoidHom.{u2, u1} G' G (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) G' (fun (_x : G') => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G') => G) _x) (MulHomClass.toFunLike.{max u1 u2, u2, u1} (MonoidHom.{u2, u1} G' G (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) G' G (MulOneClass.toMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u2, u1} (MonoidHom.{u2, u1} G' G (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) G' G (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (MonoidHom.monoidHomClass.{u2, u1} G' G (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) f)) -> (forall [_inst_4 : Subgroup.IsCommutative.{u1} G _inst_1 H], Subgroup.IsCommutative.{u2} G' _inst_2 (Subgroup.comap.{u2, u1} G' _inst_2 G _inst_1 f H))
Case conversion may be inaccurate. Consider using '#align subgroup.comap_injective_is_commutative Subgroup.comap_injective_isCommutativeₓ'. -/
@[to_additive]
theorem comap_injective_isCommutative {f : G' →* G} (hf : Injective f) [H.IsCommutative] :
    (H.comap f).IsCommutative :=
  ⟨⟨fun a b =>
      Subtype.ext
        (by
          have := mul_comm (⟨f a, a.2⟩ : H) (⟨f b, b.2⟩ : H)
          rwa [Subtype.ext_iff, coe_mul, coe_mul, coe_mk, coe_mk, ← map_mul, ← map_mul,
            hf.eq_iff] at this)⟩⟩
#align subgroup.comap_injective_is_commutative Subgroup.comap_injective_isCommutative
#align add_subgroup.comap_injective_is_commutative AddSubgroup.comap_injective_isCommutative

/- warning: subgroup.subgroup_of_is_commutative -> Subgroup.subgroupOf_isCommutative is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) {K : Subgroup.{u1} G _inst_1} [_inst_4 : Subgroup.IsCommutative.{u1} G _inst_1 H], Subgroup.IsCommutative.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K) (Subgroup.subgroupOf.{u1} G _inst_1 H K)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) {K : Subgroup.{u1} G _inst_1} [_inst_4 : Subgroup.IsCommutative.{u1} G _inst_1 H], Subgroup.IsCommutative.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Subgroup.toGroup.{u1} G _inst_1 K) (Subgroup.subgroupOf.{u1} G _inst_1 H K)
Case conversion may be inaccurate. Consider using '#align subgroup.subgroup_of_is_commutative Subgroup.subgroupOf_isCommutativeₓ'. -/
@[to_additive]
instance subgroupOf_isCommutative [H.IsCommutative] : (H.subgroupOf K).IsCommutative :=
  H.comap_injective_isCommutative Subtype.coe_injective
#align subgroup.subgroup_of_is_commutative Subgroup.subgroupOf_isCommutative
#align add_subgroup.add_subgroup_of_is_commutative AddSubgroup.addSubgroupOf_isCommutative

/- warning: subgroup.le_centralizer_iff_is_commutative -> Subgroup.le_centralizer_iff_isCommutative is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {K : Subgroup.{u1} G _inst_1}, Iff (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) K (Subgroup.centralizer.{u1} G _inst_1 K)) (Subgroup.IsCommutative.{u1} G _inst_1 K)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {K : Subgroup.{u1} G _inst_1}, Iff (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) K (Subgroup.centralizer.{u1} G _inst_1 K)) (Subgroup.IsCommutative.{u1} G _inst_1 K)
Case conversion may be inaccurate. Consider using '#align subgroup.le_centralizer_iff_is_commutative Subgroup.le_centralizer_iff_isCommutativeₓ'. -/
@[to_additive]
theorem le_centralizer_iff_isCommutative : K ≤ K.centralizer ↔ K.IsCommutative :=
  ⟨fun h => ⟨⟨fun x y => Subtype.ext (h y.2 x x.2)⟩⟩, fun h x hx y hy =>
    congr_arg coe (h.1.1 ⟨y, hy⟩ ⟨x, hx⟩)⟩
#align subgroup.le_centralizer_iff_is_commutative Subgroup.le_centralizer_iff_isCommutative
#align add_subgroup.le_centralizer_iff_is_commutative AddSubgroup.le_centralizer_iff_isCommutative

/- warning: subgroup.le_centralizer -> Subgroup.le_centralizer is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) [h : Subgroup.IsCommutative.{u1} G _inst_1 H], LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H (Subgroup.centralizer.{u1} G _inst_1 H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) [h : Subgroup.IsCommutative.{u1} G _inst_1 H], LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) H (Subgroup.centralizer.{u1} G _inst_1 H)
Case conversion may be inaccurate. Consider using '#align subgroup.le_centralizer Subgroup.le_centralizerₓ'. -/
@[to_additive]
theorem le_centralizer [h : H.IsCommutative] : H ≤ H.centralizer :=
  le_centralizer_iff_isCommutative.mpr h
#align subgroup.le_centralizer Subgroup.le_centralizer
#align add_subgroup.le_centralizer AddSubgroup.le_centralizer

end Subgroup

namespace Group

variable {s : Set G}

#print Group.conjugatesOfSet /-
/-- Given a set `s`, `conjugates_of_set s` is the set of all conjugates of
the elements of `s`. -/
def conjugatesOfSet (s : Set G) : Set G :=
  ⋃ a ∈ s, conjugatesOf a
#align group.conjugates_of_set Group.conjugatesOfSet
-/

/- warning: group.mem_conjugates_of_set_iff -> Group.mem_conjugatesOfSet_iff is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G} {x : G}, Iff (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) x (Group.conjugatesOfSet.{u1} G _inst_1 s)) (Exists.{succ u1} G (fun (a : G) => Exists.{0} (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) a s) (fun (H : Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) a s) => IsConj.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) a x)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G} {x : G}, Iff (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (Group.conjugatesOfSet.{u1} G _inst_1 s)) (Exists.{succ u1} G (fun (a : G) => And (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) a s) (IsConj.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) a x)))
Case conversion may be inaccurate. Consider using '#align group.mem_conjugates_of_set_iff Group.mem_conjugatesOfSet_iffₓ'. -/
theorem mem_conjugatesOfSet_iff {x : G} : x ∈ conjugatesOfSet s ↔ ∃ a ∈ s, IsConj a x :=
  Set.mem_unionᵢ₂
#align group.mem_conjugates_of_set_iff Group.mem_conjugatesOfSet_iff

#print Group.subset_conjugatesOfSet /-
theorem subset_conjugatesOfSet : s ⊆ conjugatesOfSet s := fun (x : G) (h : x ∈ s) =>
  mem_conjugatesOfSet_iff.2 ⟨x, h, IsConj.refl _⟩
#align group.subset_conjugates_of_set Group.subset_conjugatesOfSet
-/

#print Group.conjugatesOfSet_mono /-
theorem conjugatesOfSet_mono {s t : Set G} (h : s ⊆ t) : conjugatesOfSet s ⊆ conjugatesOfSet t :=
  Set.bunionᵢ_subset_bunionᵢ_left h
#align group.conjugates_of_set_mono Group.conjugatesOfSet_mono
-/

/- warning: group.conjugates_subset_normal -> Group.conjugates_subset_normal is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Subgroup.{u1} G _inst_1} [tn : Subgroup.Normal.{u1} G _inst_1 N] {a : G}, (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) a N) -> (HasSubset.Subset.{u1} (Set.{u1} G) (Set.hasSubset.{u1} G) (conjugatesOf.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) a) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) N))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Subgroup.{u1} G _inst_1} [tn : Subgroup.Normal.{u1} G _inst_1 N] {a : G}, (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) a N) -> (HasSubset.Subset.{u1} (Set.{u1} G) (Set.instHasSubsetSet.{u1} G) (conjugatesOf.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) a) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) N))
Case conversion may be inaccurate. Consider using '#align group.conjugates_subset_normal Group.conjugates_subset_normalₓ'. -/
theorem conjugates_subset_normal {N : Subgroup G} [tn : N.Normal] {a : G} (h : a ∈ N) :
    conjugatesOf a ⊆ N := by
  rintro a hc
  obtain ⟨c, rfl⟩ := isConj_iff.1 hc
  exact tn.conj_mem a h c
#align group.conjugates_subset_normal Group.conjugates_subset_normal

/- warning: group.conjugates_of_set_subset -> Group.conjugatesOfSet_subset is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G} {N : Subgroup.{u1} G _inst_1} [_inst_4 : Subgroup.Normal.{u1} G _inst_1 N], (HasSubset.Subset.{u1} (Set.{u1} G) (Set.hasSubset.{u1} G) s ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) N)) -> (HasSubset.Subset.{u1} (Set.{u1} G) (Set.hasSubset.{u1} G) (Group.conjugatesOfSet.{u1} G _inst_1 s) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) N))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G} {N : Subgroup.{u1} G _inst_1} [_inst_4 : Subgroup.Normal.{u1} G _inst_1 N], (HasSubset.Subset.{u1} (Set.{u1} G) (Set.instHasSubsetSet.{u1} G) s (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) N)) -> (HasSubset.Subset.{u1} (Set.{u1} G) (Set.instHasSubsetSet.{u1} G) (Group.conjugatesOfSet.{u1} G _inst_1 s) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) N))
Case conversion may be inaccurate. Consider using '#align group.conjugates_of_set_subset Group.conjugatesOfSet_subsetₓ'. -/
theorem conjugatesOfSet_subset {s : Set G} {N : Subgroup G} [N.Normal] (h : s ⊆ N) :
    conjugatesOfSet s ⊆ N :=
  Set.unionᵢ₂_subset fun x H => conjugates_subset_normal (h H)
#align group.conjugates_of_set_subset Group.conjugatesOfSet_subset

/- warning: group.conj_mem_conjugates_of_set -> Group.conj_mem_conjugatesOfSet is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G} {x : G} {c : G}, (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) x (Group.conjugatesOfSet.{u1} G _inst_1 s)) -> (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) c x) (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) c)) (Group.conjugatesOfSet.{u1} G _inst_1 s))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G} {x : G} {c : G}, (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (Group.conjugatesOfSet.{u1} G _inst_1 s)) -> (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) c x) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) c)) (Group.conjugatesOfSet.{u1} G _inst_1 s))
Case conversion may be inaccurate. Consider using '#align group.conj_mem_conjugates_of_set Group.conj_mem_conjugatesOfSetₓ'. -/
/-- The set of conjugates of `s` is closed under conjugation. -/
theorem conj_mem_conjugatesOfSet {x c : G} :
    x ∈ conjugatesOfSet s → c * x * c⁻¹ ∈ conjugatesOfSet s := fun H =>
  by
  rcases mem_conjugates_of_set_iff.1 H with ⟨a, h₁, h₂⟩
  exact mem_conjugates_of_set_iff.2 ⟨a, h₁, h₂.trans (isConj_iff.2 ⟨c, rfl⟩)⟩
#align group.conj_mem_conjugates_of_set Group.conj_mem_conjugatesOfSet

end Group

namespace Subgroup

open Group

variable {s : Set G}

#print Subgroup.normalClosure /-
/-- The normal closure of a set `s` is the subgroup closure of all the conjugates of
elements of `s`. It is the smallest normal subgroup containing `s`. -/
def normalClosure (s : Set G) : Subgroup G :=
  closure (conjugatesOfSet s)
#align subgroup.normal_closure Subgroup.normalClosure
-/

/- warning: subgroup.conjugates_of_set_subset_normal_closure -> Subgroup.conjugatesOfSet_subset_normalClosure is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G}, HasSubset.Subset.{u1} (Set.{u1} G) (Set.hasSubset.{u1} G) (Group.conjugatesOfSet.{u1} G _inst_1 s) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.normalClosure.{u1} G _inst_1 s))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G}, HasSubset.Subset.{u1} (Set.{u1} G) (Set.instHasSubsetSet.{u1} G) (Group.conjugatesOfSet.{u1} G _inst_1 s) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (Subgroup.normalClosure.{u1} G _inst_1 s))
Case conversion may be inaccurate. Consider using '#align subgroup.conjugates_of_set_subset_normal_closure Subgroup.conjugatesOfSet_subset_normalClosureₓ'. -/
theorem conjugatesOfSet_subset_normalClosure : conjugatesOfSet s ⊆ normalClosure s :=
  subset_closure
#align subgroup.conjugates_of_set_subset_normal_closure Subgroup.conjugatesOfSet_subset_normalClosure

/- warning: subgroup.subset_normal_closure -> Subgroup.subset_normalClosure is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G}, HasSubset.Subset.{u1} (Set.{u1} G) (Set.hasSubset.{u1} G) s ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.normalClosure.{u1} G _inst_1 s))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G}, HasSubset.Subset.{u1} (Set.{u1} G) (Set.instHasSubsetSet.{u1} G) s (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (Subgroup.normalClosure.{u1} G _inst_1 s))
Case conversion may be inaccurate. Consider using '#align subgroup.subset_normal_closure Subgroup.subset_normalClosureₓ'. -/
theorem subset_normalClosure : s ⊆ normalClosure s :=
  Set.Subset.trans subset_conjugatesOfSet conjugatesOfSet_subset_normalClosure
#align subgroup.subset_normal_closure Subgroup.subset_normalClosure

/- warning: subgroup.le_normal_closure -> Subgroup.le_normalClosure is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H (Subgroup.normalClosure.{u1} G _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) H (Subgroup.normalClosure.{u1} G _inst_1 (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H))
Case conversion may be inaccurate. Consider using '#align subgroup.le_normal_closure Subgroup.le_normalClosureₓ'. -/
theorem le_normalClosure {H : Subgroup G} : H ≤ normalClosure ↑H := fun _ h =>
  subset_normalClosure h
#align subgroup.le_normal_closure Subgroup.le_normalClosure

#print Subgroup.normalClosure_normal /-
/-- The normal closure of `s` is a normal subgroup. -/
instance normalClosure_normal : (normalClosure s).Normal :=
  ⟨fun n h g =>
    by
    refine' Subgroup.closure_induction h (fun x hx => _) _ (fun x y ihx ihy => _) fun x ihx => _
    · exact conjugates_of_set_subset_normal_closure (conj_mem_conjugates_of_set hx)
    · simpa using (normal_closure s).one_mem
    · rw [← conj_mul]
      exact mul_mem ihx ihy
    · rw [← conj_inv]
      exact inv_mem ihx⟩
#align subgroup.normal_closure_normal Subgroup.normalClosure_normal
-/

/- warning: subgroup.normal_closure_le_normal -> Subgroup.normalClosure_le_normal is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G} {N : Subgroup.{u1} G _inst_1} [_inst_4 : Subgroup.Normal.{u1} G _inst_1 N], (HasSubset.Subset.{u1} (Set.{u1} G) (Set.hasSubset.{u1} G) s ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) N)) -> (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.normalClosure.{u1} G _inst_1 s) N)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G} {N : Subgroup.{u1} G _inst_1} [_inst_4 : Subgroup.Normal.{u1} G _inst_1 N], (HasSubset.Subset.{u1} (Set.{u1} G) (Set.instHasSubsetSet.{u1} G) s (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) N)) -> (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (Subgroup.normalClosure.{u1} G _inst_1 s) N)
Case conversion may be inaccurate. Consider using '#align subgroup.normal_closure_le_normal Subgroup.normalClosure_le_normalₓ'. -/
/-- The normal closure of `s` is the smallest normal subgroup containing `s`. -/
theorem normalClosure_le_normal {N : Subgroup G} [N.Normal] (h : s ⊆ N) : normalClosure s ≤ N :=
  by
  intro a w
  refine' closure_induction w (fun x hx => _) _ (fun x y ihx ihy => _) fun x ihx => _
  · exact conjugates_of_set_subset h hx
  · exact one_mem _
  · exact mul_mem ihx ihy
  · exact inv_mem ihx
#align subgroup.normal_closure_le_normal Subgroup.normalClosure_le_normal

/- warning: subgroup.normal_closure_subset_iff -> Subgroup.normalClosure_subset_iff is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G} {N : Subgroup.{u1} G _inst_1} [_inst_4 : Subgroup.Normal.{u1} G _inst_1 N], Iff (HasSubset.Subset.{u1} (Set.{u1} G) (Set.hasSubset.{u1} G) s ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) N)) (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.normalClosure.{u1} G _inst_1 s) N)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G} {N : Subgroup.{u1} G _inst_1} [_inst_4 : Subgroup.Normal.{u1} G _inst_1 N], Iff (HasSubset.Subset.{u1} (Set.{u1} G) (Set.instHasSubsetSet.{u1} G) s (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) N)) (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (Subgroup.normalClosure.{u1} G _inst_1 s) N)
Case conversion may be inaccurate. Consider using '#align subgroup.normal_closure_subset_iff Subgroup.normalClosure_subset_iffₓ'. -/
theorem normalClosure_subset_iff {N : Subgroup G} [N.Normal] : s ⊆ N ↔ normalClosure s ≤ N :=
  ⟨normalClosure_le_normal, Set.Subset.trans subset_normalClosure⟩
#align subgroup.normal_closure_subset_iff Subgroup.normalClosure_subset_iff

/- warning: subgroup.normal_closure_mono -> Subgroup.normalClosure_mono is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G} {t : Set.{u1} G}, (HasSubset.Subset.{u1} (Set.{u1} G) (Set.hasSubset.{u1} G) s t) -> (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.normalClosure.{u1} G _inst_1 s) (Subgroup.normalClosure.{u1} G _inst_1 t))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G} {t : Set.{u1} G}, (HasSubset.Subset.{u1} (Set.{u1} G) (Set.instHasSubsetSet.{u1} G) s t) -> (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (Subgroup.normalClosure.{u1} G _inst_1 s) (Subgroup.normalClosure.{u1} G _inst_1 t))
Case conversion may be inaccurate. Consider using '#align subgroup.normal_closure_mono Subgroup.normalClosure_monoₓ'. -/
theorem normalClosure_mono {s t : Set G} (h : s ⊆ t) : normalClosure s ≤ normalClosure t :=
  normalClosure_le_normal (Set.Subset.trans h subset_normalClosure)
#align subgroup.normal_closure_mono Subgroup.normalClosure_mono

#print Subgroup.normalClosure_eq_infᵢ /-
theorem normalClosure_eq_infᵢ :
    normalClosure s = ⨅ (N : Subgroup G) (_ : Normal N) (hs : s ⊆ N), N :=
  le_antisymm (le_infᵢ fun N => le_infᵢ fun hN => le_infᵢ normal_closure_le_normal)
    (infᵢ_le_of_le (normalClosure s)
      (infᵢ_le_of_le (by infer_instance) (infᵢ_le_of_le subset_normalClosure le_rfl)))
#align subgroup.normal_closure_eq_infi Subgroup.normalClosure_eq_infᵢ
-/

#print Subgroup.normalClosure_eq_self /-
@[simp]
theorem normalClosure_eq_self (H : Subgroup G) [H.Normal] : normalClosure ↑H = H :=
  le_antisymm (normalClosure_le_normal rfl.Subset) le_normalClosure
#align subgroup.normal_closure_eq_self Subgroup.normalClosure_eq_self
-/

#print Subgroup.normalClosure_idempotent /-
@[simp]
theorem normalClosure_idempotent : normalClosure ↑(normalClosure s) = normalClosure s :=
  normalClosure_eq_self _
#align subgroup.normal_closure_idempotent Subgroup.normalClosure_idempotent
-/

/- warning: subgroup.closure_le_normal_closure -> Subgroup.closure_le_normalClosure is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G}, LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.closure.{u1} G _inst_1 s) (Subgroup.normalClosure.{u1} G _inst_1 s)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G}, LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (Subgroup.closure.{u1} G _inst_1 s) (Subgroup.normalClosure.{u1} G _inst_1 s)
Case conversion may be inaccurate. Consider using '#align subgroup.closure_le_normal_closure Subgroup.closure_le_normalClosureₓ'. -/
theorem closure_le_normalClosure {s : Set G} : closure s ≤ normalClosure s := by
  simp only [subset_normal_closure, closure_le]
#align subgroup.closure_le_normal_closure Subgroup.closure_le_normalClosure

#print Subgroup.normalClosure_closure_eq_normalClosure /-
@[simp]
theorem normalClosure_closure_eq_normalClosure {s : Set G} :
    normalClosure ↑(closure s) = normalClosure s :=
  le_antisymm (normalClosure_le_normal closure_le_normalClosure) (normalClosure_mono subset_closure)
#align subgroup.normal_closure_closure_eq_normal_closure Subgroup.normalClosure_closure_eq_normalClosure
-/

#print Subgroup.normalCore /-
/-- The normal core of a subgroup `H` is the largest normal subgroup of `G` contained in `H`,
as shown by `subgroup.normal_core_eq_supr`. -/
def normalCore (H : Subgroup G) : Subgroup G
    where
  carrier := { a : G | ∀ b : G, b * a * b⁻¹ ∈ H }
  one_mem' a := by rw [mul_one, mul_inv_self] <;> exact H.one_mem
  inv_mem' a h b := (congr_arg (· ∈ H) conj_inv).mp (H.inv_mem (h b))
  mul_mem' a b ha hb c := (congr_arg (· ∈ H) conj_mul).mp (H.mul_mem (ha c) (hb c))
#align subgroup.normal_core Subgroup.normalCore
-/

/- warning: subgroup.normal_core_le -> Subgroup.normalCore_le is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.normalCore.{u1} G _inst_1 H) H
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (Subgroup.normalCore.{u1} G _inst_1 H) H
Case conversion may be inaccurate. Consider using '#align subgroup.normal_core_le Subgroup.normalCore_leₓ'. -/
theorem normalCore_le (H : Subgroup G) : H.normalCore ≤ H := fun a h =>
  by
  rw [← mul_one a, ← inv_one, ← one_mul a]
  exact h 1
#align subgroup.normal_core_le Subgroup.normalCore_le

#print Subgroup.normalCore_normal /-
instance normalCore_normal (H : Subgroup G) : H.normalCore.Normal :=
  ⟨fun a h b c => by
    rw [mul_assoc, mul_assoc, ← mul_inv_rev, ← mul_assoc, ← mul_assoc] <;> exact h (c * b)⟩
#align subgroup.normal_core_normal Subgroup.normalCore_normal
-/

/- warning: subgroup.normal_le_normal_core -> Subgroup.normal_le_normalCore is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {N : Subgroup.{u1} G _inst_1} [hN : Subgroup.Normal.{u1} G _inst_1 N], Iff (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) N (Subgroup.normalCore.{u1} G _inst_1 H)) (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) N H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {N : Subgroup.{u1} G _inst_1} [hN : Subgroup.Normal.{u1} G _inst_1 N], Iff (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) N (Subgroup.normalCore.{u1} G _inst_1 H)) (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) N H)
Case conversion may be inaccurate. Consider using '#align subgroup.normal_le_normal_core Subgroup.normal_le_normalCoreₓ'. -/
theorem normal_le_normalCore {H : Subgroup G} {N : Subgroup G} [hN : N.Normal] :
    N ≤ H.normalCore ↔ N ≤ H :=
  ⟨ge_trans H.normalCore_le, fun h_le n hn g => h_le (hN.conj_mem n hn g)⟩
#align subgroup.normal_le_normal_core Subgroup.normal_le_normalCore

/- warning: subgroup.normal_core_mono -> Subgroup.normalCore_mono is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1}, (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H K) -> (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.normalCore.{u1} G _inst_1 H) (Subgroup.normalCore.{u1} G _inst_1 K))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1}, (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) H K) -> (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (Subgroup.normalCore.{u1} G _inst_1 H) (Subgroup.normalCore.{u1} G _inst_1 K))
Case conversion may be inaccurate. Consider using '#align subgroup.normal_core_mono Subgroup.normalCore_monoₓ'. -/
theorem normalCore_mono {H K : Subgroup G} (h : H ≤ K) : H.normalCore ≤ K.normalCore :=
  normal_le_normalCore.mpr (H.normalCore_le.trans h)
#align subgroup.normal_core_mono Subgroup.normalCore_mono

/- warning: subgroup.normal_core_eq_supr -> Subgroup.normalCore_eq_supᵢ is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.normalCore.{u1} G _inst_1 H) (supᵢ.{u1, succ u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))) (Subgroup.{u1} G _inst_1) (fun (N : Subgroup.{u1} G _inst_1) => supᵢ.{u1, 0} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))) (Subgroup.Normal.{u1} G _inst_1 N) (fun (_x : Subgroup.Normal.{u1} G _inst_1 N) => supᵢ.{u1, 0} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))) (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) N H) (fun (hs : LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) N H) => N))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.normalCore.{u1} G _inst_1 H) (supᵢ.{u1, succ u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toSupSet.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)) (Subgroup.{u1} G _inst_1) (fun (N : Subgroup.{u1} G _inst_1) => supᵢ.{u1, 0} (Subgroup.{u1} G _inst_1) (CompleteLattice.toSupSet.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)) (Subgroup.Normal.{u1} G _inst_1 N) (fun (_x : Subgroup.Normal.{u1} G _inst_1 N) => supᵢ.{u1, 0} (Subgroup.{u1} G _inst_1) (CompleteLattice.toSupSet.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)) (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) N H) (fun (hs : LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) N H) => N))))
Case conversion may be inaccurate. Consider using '#align subgroup.normal_core_eq_supr Subgroup.normalCore_eq_supᵢₓ'. -/
theorem normalCore_eq_supᵢ (H : Subgroup G) :
    H.normalCore = ⨆ (N : Subgroup G) (_ : Normal N) (hs : N ≤ H), N :=
  le_antisymm
    (le_supᵢ_of_le H.normalCore
      (le_supᵢ_of_le H.normalCore_normal (le_supᵢ_of_le H.normalCore_le le_rfl)))
    (supᵢ_le fun N => supᵢ_le fun hN => supᵢ_le normal_le_normal_core.mpr)
#align subgroup.normal_core_eq_supr Subgroup.normalCore_eq_supᵢ

#print Subgroup.normalCore_eq_self /-
@[simp]
theorem normalCore_eq_self (H : Subgroup G) [H.Normal] : H.normalCore = H :=
  le_antisymm H.normalCore_le (normal_le_normalCore.mpr le_rfl)
#align subgroup.normal_core_eq_self Subgroup.normalCore_eq_self
-/

#print Subgroup.normalCore_idempotent /-
@[simp]
theorem normalCore_idempotent (H : Subgroup G) : H.normalCore.normalCore = H.normalCore :=
  H.normalCore.normalCore_eq_self
#align subgroup.normal_core_idempotent Subgroup.normalCore_idempotent
-/

end Subgroup

namespace MonoidHom

variable {N : Type _} {P : Type _} [Group N] [Group P] (K : Subgroup G)

open Subgroup

#print MonoidHom.range /-
/-- The range of a monoid homomorphism from a group is a subgroup. -/
@[to_additive "The range of an `add_monoid_hom` from an `add_group` is an `add_subgroup`."]
def range (f : G →* N) : Subgroup N :=
  Subgroup.copy ((⊤ : Subgroup G).map f) (Set.range f) (by simp [Set.ext_iff])
#align monoid_hom.range MonoidHom.range
#align add_monoid_hom.range AddMonoidHom.range
-/

/- warning: monoid_hom.coe_range -> MonoidHom.coe_range is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), Eq.{succ u2} (Set.{u2} N) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Subgroup.{u2} N _inst_4) (Set.{u2} N) (HasLiftT.mk.{succ u2, succ u2} (Subgroup.{u2} N _inst_4) (Set.{u2} N) (CoeTCₓ.coe.{succ u2, succ u2} (Subgroup.{u2} N _inst_4) (Set.{u2} N) (SetLike.Set.hasCoeT.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)))) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Set.range.{u2, succ u1} N G (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))), Eq.{succ u1} (Set.{u1} N) (SetLike.coe.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4) (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)) (Set.range.{u1, succ u2} N G (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f))
Case conversion may be inaccurate. Consider using '#align monoid_hom.coe_range MonoidHom.coe_rangeₓ'. -/
@[simp, to_additive]
theorem coe_range (f : G →* N) : (f.range : Set N) = Set.range f :=
  rfl
#align monoid_hom.coe_range MonoidHom.coe_range
#align add_monoid_hom.coe_range AddMonoidHom.coe_range

/- warning: monoid_hom.mem_range -> MonoidHom.mem_range is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))} {y : N}, Iff (Membership.Mem.{u2, u2} N (Subgroup.{u2} N _inst_4) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) y (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Exists.{succ u1} G (fun (x : G) => Eq.{succ u2} N (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f x) y))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))} {y : N}, Iff (Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) y (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)) (Exists.{succ u2} G (fun (x : G) => Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f x) y))
Case conversion may be inaccurate. Consider using '#align monoid_hom.mem_range MonoidHom.mem_rangeₓ'. -/
@[simp, to_additive]
theorem mem_range {f : G →* N} {y : N} : y ∈ f.range ↔ ∃ x, f x = y :=
  Iff.rfl
#align monoid_hom.mem_range MonoidHom.mem_range
#align add_monoid_hom.mem_range AddMonoidHom.mem_range

/- warning: monoid_hom.range_eq_map -> MonoidHom.range_eq_map is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), Eq.{succ u2} (Subgroup.{u2} N _inst_4) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasTop.{u1} G _inst_1)))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))), Eq.{succ u1} (Subgroup.{u1} N _inst_4) (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f (Top.top.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instTopSubgroup.{u2} G _inst_1)))
Case conversion may be inaccurate. Consider using '#align monoid_hom.range_eq_map MonoidHom.range_eq_mapₓ'. -/
@[to_additive]
theorem range_eq_map (f : G →* N) : f.range = (⊤ : Subgroup G).map f := by ext <;> simp
#align monoid_hom.range_eq_map MonoidHom.range_eq_map
#align add_monoid_hom.range_eq_map AddMonoidHom.range_eq_map

/- warning: monoid_hom.restrict_range -> MonoidHom.restrict_range is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (K : Subgroup.{u1} G _inst_1) (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), Eq.{succ u2} (Subgroup.{u2} N _inst_4) (MonoidHom.range.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K) N _inst_4 (MonoidHom.restrict.{u1, u2, u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) N (Subgroup.{u1} G _inst_1) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Subgroup.setLike.{u1} G _inst_1) (SubgroupClass.to_submonoidClass.{u1, u1} (Subgroup.{u1} G _inst_1) G (Group.toDivInvMonoid.{u1} G _inst_1) (Subgroup.setLike.{u1} G _inst_1) (Subgroup.subgroupClass.{u1} G _inst_1)) f K)) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f K)
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (K : Subgroup.{u2} G _inst_1) (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))), Eq.{succ u1} (Subgroup.{u1} N _inst_4) (MonoidHom.range.{u2, u1} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x K)) (Subgroup.toGroup.{u2} G _inst_1 K) N _inst_4 (MonoidHom.restrict.{u2, u1, u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) N (Subgroup.{u2} G _inst_1) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.instSetLikeSubgroup.{u2} G _inst_1) (SubgroupClass.toSubmonoidClass.{u2, u2} (Subgroup.{u2} G _inst_1) G (Group.toDivInvMonoid.{u2} G _inst_1) (Subgroup.instSetLikeSubgroup.{u2} G _inst_1) (Subgroup.instSubgroupClassSubgroupToDivInvMonoidInstSetLikeSubgroup.{u2} G _inst_1)) f K)) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f K)
Case conversion may be inaccurate. Consider using '#align monoid_hom.restrict_range MonoidHom.restrict_rangeₓ'. -/
@[simp, to_additive]
theorem restrict_range (f : G →* N) : (f.restrict K).range = K.map f := by
  simp_rw [SetLike.ext_iff, mem_range, mem_map, restrict_apply, SetLike.exists, Subtype.coe_mk,
    iff_self_iff, forall_const]
#align monoid_hom.restrict_range MonoidHom.restrict_range
#align add_monoid_hom.restrict_range AddMonoidHom.restrict_range

/- warning: monoid_hom.range_restrict -> MonoidHom.rangeRestrict is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), MonoidHom.{u1, u2} G (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (DivInvMonoid.toMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Group.toDivInvMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Subgroup.toGroup.{u2} N _inst_4 (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), MonoidHom.{u1, u2} G (Subtype.{succ u2} N (fun (x : N) => Membership.mem.{u2, u2} N (Subgroup.{u2} N _inst_4) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u2} N _inst_4)) x (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Submonoid.toMulOneClass.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Subgroup.toSubmonoid.{u2} N _inst_4 (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)))
Case conversion may be inaccurate. Consider using '#align monoid_hom.range_restrict MonoidHom.rangeRestrictₓ'. -/
/-- The canonical surjective group homomorphism `G →* f(G)` induced by a group
homomorphism `G →* N`. -/
@[to_additive
      "The canonical surjective `add_group` homomorphism `G →+ f(G)` induced by a group\nhomomorphism `G →+ N`."]
def rangeRestrict (f : G →* N) : G →* f.range :=
  codRestrict f _ fun x => ⟨x, rfl⟩
#align monoid_hom.range_restrict MonoidHom.rangeRestrict
#align add_monoid_hom.range_restrict AddMonoidHom.rangeRestrict

/- warning: monoid_hom.coe_range_restrict -> MonoidHom.coe_rangeRestrict is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (g : G), Eq.{succ u2} N ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) N (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) N (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) N (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) N (coeSubtype.{succ u2} N (fun (x : N) => Membership.Mem.{u2, u2} N (Subgroup.{u2} N _inst_4) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) x (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)))))) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (DivInvMonoid.toMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Group.toDivInvMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Subgroup.toGroup.{u2} N _inst_4 (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)))))) (fun (_x : MonoidHom.{u1, u2} G (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (DivInvMonoid.toMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Group.toDivInvMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Subgroup.toGroup.{u2} N _inst_4 (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)))))) => G -> (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f))) (MonoidHom.hasCoeToFun.{u1, u2} G (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (DivInvMonoid.toMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Group.toDivInvMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Subgroup.toGroup.{u2} N _inst_4 (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)))))) (MonoidHom.rangeRestrict.{u1, u2} G _inst_1 N _inst_4 f) g)) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f g)
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (g : G), Eq.{succ u1} N (Subtype.val.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Set.{u1} N) (Set.instMembershipSet.{u1} N) x (SetLike.coe.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4) (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)))) G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)))) G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (MonoidHom.monoidHomClass.{u2, u1} G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)))))) (MonoidHom.rangeRestrict.{u2, u1} G _inst_1 N _inst_4 f) g)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f g)
Case conversion may be inaccurate. Consider using '#align monoid_hom.coe_range_restrict MonoidHom.coe_rangeRestrictₓ'. -/
@[simp, to_additive]
theorem coe_rangeRestrict (f : G →* N) (g : G) : (f.range_restrict g : N) = f g :=
  rfl
#align monoid_hom.coe_range_restrict MonoidHom.coe_rangeRestrict
#align add_monoid_hom.coe_range_restrict AddMonoidHom.coe_rangeRestrict

/- warning: monoid_hom.coe_comp_range_restrict -> MonoidHom.coe_comp_rangeRestrict is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), Eq.{max (succ u1) (succ u2)} (G -> N) (Function.comp.{succ u1, succ u2, succ u2} G (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) N ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) N (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) N (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) N (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) N (coeSubtype.{succ u2} N (fun (x : N) => Membership.Mem.{u2, u2} N (Subgroup.{u2} N _inst_4) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) x (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f))))))) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (DivInvMonoid.toMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Group.toDivInvMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Subgroup.toGroup.{u2} N _inst_4 (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)))))) (fun (_x : MonoidHom.{u1, u2} G (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (DivInvMonoid.toMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Group.toDivInvMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Subgroup.toGroup.{u2} N _inst_4 (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)))))) => G -> (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f))) (MonoidHom.hasCoeToFun.{u1, u2} G (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (DivInvMonoid.toMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Group.toDivInvMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Subgroup.toGroup.{u2} N _inst_4 (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)))))) (MonoidHom.rangeRestrict.{u1, u2} G _inst_1 N _inst_4 f))) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f)
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))), Eq.{max (succ u2) (succ u1)} (G -> N) (Function.comp.{succ u2, succ u1, succ u1} G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Set.{u1} N) (Set.instMembershipSet.{u1} N) x (SetLike.coe.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4) (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)))) N (Subtype.val.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Set.{u1} N) (Set.instMembershipSet.{u1} N) x (SetLike.coe.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4) (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)))) G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)))) G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (MonoidHom.monoidHomClass.{u2, u1} G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)))))) (MonoidHom.rangeRestrict.{u2, u1} G _inst_1 N _inst_4 f))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f)
Case conversion may be inaccurate. Consider using '#align monoid_hom.coe_comp_range_restrict MonoidHom.coe_comp_rangeRestrictₓ'. -/
@[to_additive]
theorem coe_comp_rangeRestrict (f : G →* N) :
    (coe : f.range → N) ∘ (⇑f.range_restrict : G → f.range) = f :=
  rfl
#align monoid_hom.coe_comp_range_restrict MonoidHom.coe_comp_rangeRestrict
#align add_monoid_hom.coe_comp_range_restrict AddMonoidHom.coe_comp_rangeRestrict

/- warning: monoid_hom.subtype_comp_range_restrict -> MonoidHom.subtype_comp_rangeRestrict is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), Eq.{max (succ u2) (succ u1)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (MonoidHom.comp.{u1, u2, u2} G (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (DivInvMonoid.toMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Group.toDivInvMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Subgroup.toGroup.{u2} N _inst_4 (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f))))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Subgroup.subtype.{u2} N _inst_4 (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (MonoidHom.rangeRestrict.{u1, u2} G _inst_1 N _inst_4 f)) f
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))), Eq.{max (succ u2) (succ u1)} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHom.comp.{u2, u1, u1} G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.subtype.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)) (MonoidHom.rangeRestrict.{u2, u1} G _inst_1 N _inst_4 f)) f
Case conversion may be inaccurate. Consider using '#align monoid_hom.subtype_comp_range_restrict MonoidHom.subtype_comp_rangeRestrictₓ'. -/
@[to_additive]
theorem subtype_comp_rangeRestrict (f : G →* N) : f.range.Subtype.comp f.range_restrict = f :=
  ext <| f.coe_rangeRestrict
#align monoid_hom.subtype_comp_range_restrict MonoidHom.subtype_comp_rangeRestrict
#align add_monoid_hom.subtype_comp_range_restrict AddMonoidHom.subtype_comp_rangeRestrict

/- warning: monoid_hom.range_restrict_surjective -> MonoidHom.rangeRestrict_surjective is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), Function.Surjective.{succ u1, succ u2} G (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (DivInvMonoid.toMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Group.toDivInvMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Subgroup.toGroup.{u2} N _inst_4 (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)))))) (fun (_x : MonoidHom.{u1, u2} G (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (DivInvMonoid.toMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Group.toDivInvMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Subgroup.toGroup.{u2} N _inst_4 (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)))))) => G -> (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f))) (MonoidHom.hasCoeToFun.{u1, u2} G (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (DivInvMonoid.toMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Group.toDivInvMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Subgroup.toGroup.{u2} N _inst_4 (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)))))) (MonoidHom.rangeRestrict.{u1, u2} G _inst_1 N _inst_4 f))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))), Function.Surjective.{succ u2, succ u1} G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)))) G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)))) G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (MonoidHom.monoidHomClass.{u2, u1} G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)))))) (MonoidHom.rangeRestrict.{u2, u1} G _inst_1 N _inst_4 f))
Case conversion may be inaccurate. Consider using '#align monoid_hom.range_restrict_surjective MonoidHom.rangeRestrict_surjectiveₓ'. -/
@[to_additive]
theorem rangeRestrict_surjective (f : G →* N) : Function.Surjective f.range_restrict :=
  fun ⟨_, g, rfl⟩ => ⟨g, rfl⟩
#align monoid_hom.range_restrict_surjective MonoidHom.rangeRestrict_surjective
#align add_monoid_hom.range_restrict_surjective AddMonoidHom.rangeRestrict_surjective

/- warning: monoid_hom.map_range -> MonoidHom.map_range is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} {P : Type.{u3}} [_inst_4 : Group.{u2} N] [_inst_5 : Group.{u3} P] (g : MonoidHom.{u2, u3} N P (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u3} P (DivInvMonoid.toMonoid.{u3} P (Group.toDivInvMonoid.{u3} P _inst_5)))) (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), Eq.{succ u3} (Subgroup.{u3} P _inst_5) (Subgroup.map.{u2, u3} N _inst_4 P _inst_5 g (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (MonoidHom.range.{u1, u3} G _inst_1 P _inst_5 (MonoidHom.comp.{u1, u2, u3} G N P (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u3} P (DivInvMonoid.toMonoid.{u3} P (Group.toDivInvMonoid.{u3} P _inst_5))) g f))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u3}} {P : Type.{u2}} [_inst_4 : Group.{u3} N] [_inst_5 : Group.{u2} P] (g : MonoidHom.{u3, u2} N P (Monoid.toMulOneClass.{u3} N (DivInvMonoid.toMonoid.{u3} N (Group.toDivInvMonoid.{u3} N _inst_4))) (Monoid.toMulOneClass.{u2} P (DivInvMonoid.toMonoid.{u2} P (Group.toDivInvMonoid.{u2} P _inst_5)))) (f : MonoidHom.{u1, u3} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u3} N (DivInvMonoid.toMonoid.{u3} N (Group.toDivInvMonoid.{u3} N _inst_4)))), Eq.{succ u2} (Subgroup.{u2} P _inst_5) (Subgroup.map.{u3, u2} N _inst_4 P _inst_5 g (MonoidHom.range.{u1, u3} G _inst_1 N _inst_4 f)) (MonoidHom.range.{u1, u2} G _inst_1 P _inst_5 (MonoidHom.comp.{u1, u3, u2} G N P (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u3} N (DivInvMonoid.toMonoid.{u3} N (Group.toDivInvMonoid.{u3} N _inst_4))) (Monoid.toMulOneClass.{u2} P (DivInvMonoid.toMonoid.{u2} P (Group.toDivInvMonoid.{u2} P _inst_5))) g f))
Case conversion may be inaccurate. Consider using '#align monoid_hom.map_range MonoidHom.map_rangeₓ'. -/
@[to_additive]
theorem map_range (g : N →* P) (f : G →* N) : f.range.map g = (g.comp f).range := by
  rw [range_eq_map, range_eq_map] <;> exact (⊤ : Subgroup G).map_map g f
#align monoid_hom.map_range MonoidHom.map_range
#align add_monoid_hom.map_range AddMonoidHom.map_range

/- warning: monoid_hom.range_top_iff_surjective -> MonoidHom.range_top_iff_surjective is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_6 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_6)))}, Iff (Eq.{succ u2} (Subgroup.{u2} N _inst_6) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_6 f) (Top.top.{u2} (Subgroup.{u2} N _inst_6) (Subgroup.hasTop.{u2} N _inst_6))) (Function.Surjective.{succ u1, succ u2} G N (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_6)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_6)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_6)))) f))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_6 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_6)))}, Iff (Eq.{succ u2} (Subgroup.{u2} N _inst_6) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_6 f) (Top.top.{u2} (Subgroup.{u2} N _inst_6) (Subgroup.instTopSubgroup.{u2} N _inst_6))) (Function.Surjective.{succ u1, succ u2} G N (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_6)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_6)))) G N (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_6)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_6)))) G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_6))) (MonoidHom.monoidHomClass.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_6)))))) f))
Case conversion may be inaccurate. Consider using '#align monoid_hom.range_top_iff_surjective MonoidHom.range_top_iff_surjectiveₓ'. -/
@[to_additive]
theorem range_top_iff_surjective {N} [Group N] {f : G →* N} :
    f.range = (⊤ : Subgroup N) ↔ Function.Surjective f :=
  SetLike.ext'_iff.trans <| Iff.trans (by rw [coe_range, coe_top]) Set.range_iff_surjective
#align monoid_hom.range_top_iff_surjective MonoidHom.range_top_iff_surjective
#align add_monoid_hom.range_top_iff_surjective AddMonoidHom.range_top_iff_surjective

/- warning: monoid_hom.range_top_of_surjective -> MonoidHom.range_top_of_surjective is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_6 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_6)))), (Function.Surjective.{succ u1, succ u2} G N (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_6)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_6)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_6)))) f)) -> (Eq.{succ u2} (Subgroup.{u2} N _inst_6) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_6 f) (Top.top.{u2} (Subgroup.{u2} N _inst_6) (Subgroup.hasTop.{u2} N _inst_6)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_6 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_6)))), (Function.Surjective.{succ u1, succ u2} G N (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_6)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_6)))) G N (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_6)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_6)))) G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_6))) (MonoidHom.monoidHomClass.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_6)))))) f)) -> (Eq.{succ u2} (Subgroup.{u2} N _inst_6) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_6 f) (Top.top.{u2} (Subgroup.{u2} N _inst_6) (Subgroup.instTopSubgroup.{u2} N _inst_6)))
Case conversion may be inaccurate. Consider using '#align monoid_hom.range_top_of_surjective MonoidHom.range_top_of_surjectiveₓ'. -/
/-- The range of a surjective monoid homomorphism is the whole of the codomain. -/
@[to_additive "The range of a surjective `add_monoid` homomorphism is the whole of the codomain."]
theorem range_top_of_surjective {N} [Group N] (f : G →* N) (hf : Function.Surjective f) :
    f.range = (⊤ : Subgroup N) :=
  range_top_iff_surjective.2 hf
#align monoid_hom.range_top_of_surjective MonoidHom.range_top_of_surjective
#align add_monoid_hom.range_top_of_surjective AddMonoidHom.range_top_of_surjective

/- warning: monoid_hom.range_one -> MonoidHom.range_one is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N], Eq.{succ u2} (Subgroup.{u2} N _inst_4) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 (OfNat.ofNat.{max u2 u1} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) 1 (OfNat.mk.{max u2 u1} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) 1 (One.one.{max u2 u1} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (MonoidHom.hasOne.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))))))) (Bot.bot.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.hasBot.{u2} N _inst_4))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N], Eq.{succ u2} (Subgroup.{u2} N _inst_4) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 (OfNat.ofNat.{max u1 u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) 1 (One.toOfNat1.{max u1 u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (instOneMonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))))))) (Bot.bot.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.instBotSubgroup.{u2} N _inst_4))
Case conversion may be inaccurate. Consider using '#align monoid_hom.range_one MonoidHom.range_oneₓ'. -/
@[simp, to_additive]
theorem range_one : (1 : G →* N).range = ⊥ :=
  SetLike.ext fun x => by simpa using @comm _ (· = ·) _ 1 x
#align monoid_hom.range_one MonoidHom.range_one
#align add_monoid_hom.range_zero AddMonoidHom.range_zero

/- warning: subgroup.subtype_range -> Subgroup.subtype_range is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (MonoidHom.range.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H) G _inst_1 (Subgroup.subtype.{u1} G _inst_1 H)) H
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (MonoidHom.range.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H) G _inst_1 (Subgroup.subtype.{u1} G _inst_1 H)) H
Case conversion may be inaccurate. Consider using '#align subgroup.subtype_range Subgroup.subtype_rangeₓ'. -/
@[simp, to_additive]
theorem Subgroup.subtype_range (H : Subgroup G) : H.Subtype.range = H :=
  by
  rw [range_eq_map, ← SetLike.coe_set_eq, coe_map, Subgroup.coeSubtype]
  ext
  simp
#align subgroup.subtype_range Subgroup.subtype_range
#align add_subgroup.subtype_range AddSubgroup.subtype_range

/- warning: subgroup.inclusion_range -> Subgroup.inclusion_range is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1} (h_le : LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H K), Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K)) (MonoidHom.range.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K) (Subgroup.inclusion.{u1} G _inst_1 H K h_le)) (Subgroup.subgroupOf.{u1} G _inst_1 H K)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1} (h_le : LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) H K), Eq.{succ u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Subgroup.toGroup.{u1} G _inst_1 K)) (MonoidHom.range.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Subgroup.toGroup.{u1} G _inst_1 K) (Subgroup.inclusion.{u1} G _inst_1 H K h_le)) (Subgroup.subgroupOf.{u1} G _inst_1 H K)
Case conversion may be inaccurate. Consider using '#align subgroup.inclusion_range Subgroup.inclusion_rangeₓ'. -/
@[simp, to_additive]
theorem Subgroup.inclusion_range {H K : Subgroup G} (h_le : H ≤ K) :
    (inclusion h_le).range = H.subgroupOf K :=
  Subgroup.ext fun g => Set.ext_iff.mp (Set.range_inclusion h_le) g
#align subgroup.inclusion_range Subgroup.inclusion_range
#align add_subgroup.inclusion_range AddSubgroup.inclusion_range

/- warning: monoid_hom.subgroup_of_range_eq_of_le -> MonoidHom.subgroupOf_range_eq_of_le is a dubious translation:
lean 3 declaration is
  forall {G₁ : Type.{u1}} {G₂ : Type.{u2}} [_inst_6 : Group.{u1} G₁] [_inst_7 : Group.{u2} G₂] {K : Subgroup.{u2} G₂ _inst_7} (f : MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_6))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_7)))) (h : LE.le.{u2} (Subgroup.{u2} G₂ _inst_7) (Preorder.toLE.{u2} (Subgroup.{u2} G₂ _inst_7) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G₂ _inst_7) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} G₂ _inst_7) G₂ (Subgroup.setLike.{u2} G₂ _inst_7)))) (MonoidHom.range.{u1, u2} G₁ _inst_6 G₂ _inst_7 f) K), Eq.{succ u2} (Subgroup.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G₂ _inst_7) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G₂ _inst_7) G₂ (Subgroup.setLike.{u2} G₂ _inst_7)) K) (Subgroup.toGroup.{u2} G₂ _inst_7 K)) (Subgroup.subgroupOf.{u2} G₂ _inst_7 (MonoidHom.range.{u1, u2} G₁ _inst_6 G₂ _inst_7 f) K) (MonoidHom.range.{u1, u2} G₁ _inst_6 (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G₂ _inst_7) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G₂ _inst_7) G₂ (Subgroup.setLike.{u2} G₂ _inst_7)) K) (Subgroup.toGroup.{u2} G₂ _inst_7 K) (MonoidHom.codRestrict.{u1, u2, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_6))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_7))) (Subgroup.{u2} G₂ _inst_7) (Subgroup.setLike.{u2} G₂ _inst_7) (SubgroupClass.to_submonoidClass.{u2, u2} (Subgroup.{u2} G₂ _inst_7) G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_7) (Subgroup.setLike.{u2} G₂ _inst_7) (Subgroup.subgroupClass.{u2} G₂ _inst_7)) f K (fun (x : G₁) => h (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_6))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_7)))) (fun (_x : MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_6))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_7)))) => G₁ -> G₂) (MonoidHom.hasCoeToFun.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_6))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_7)))) f x) (Exists.intro.{succ u1} G₁ (fun (y : G₁) => Eq.{succ u2} G₂ (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_6))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_7)))) (fun (_x : MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_6))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_7)))) => G₁ -> G₂) (MonoidHom.hasCoeToFun.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_6))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_7)))) f y) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_6))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_7)))) (fun (_x : MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_6))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_7)))) => G₁ -> G₂) (MonoidHom.hasCoeToFun.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_6))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_7)))) f x)) x (rfl.{succ u2} G₂ (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_6))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_7)))) (fun (_x : MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_6))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_7)))) => G₁ -> G₂) (MonoidHom.hasCoeToFun.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_6))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_7)))) f x))))))
but is expected to have type
  forall {G₁ : Type.{u2}} {G₂ : Type.{u1}} [_inst_6 : Group.{u2} G₁] [_inst_7 : Group.{u1} G₂] {K : Subgroup.{u1} G₂ _inst_7} (f : MonoidHom.{u2, u1} G₁ G₂ (Monoid.toMulOneClass.{u2} G₁ (DivInvMonoid.toMonoid.{u2} G₁ (Group.toDivInvMonoid.{u2} G₁ _inst_6))) (Monoid.toMulOneClass.{u1} G₂ (DivInvMonoid.toMonoid.{u1} G₂ (Group.toDivInvMonoid.{u1} G₂ _inst_7)))) (h : LE.le.{u1} (Subgroup.{u1} G₂ _inst_7) (Preorder.toLE.{u1} (Subgroup.{u1} G₂ _inst_7) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₂ _inst_7) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G₂ _inst_7) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G₂ _inst_7) (Subgroup.instCompleteLatticeSubgroup.{u1} G₂ _inst_7))))) (MonoidHom.range.{u2, u1} G₁ _inst_6 G₂ _inst_7 f) K), Eq.{succ u1} (Subgroup.{u1} (Subtype.{succ u1} G₂ (fun (x : G₂) => Membership.mem.{u1, u1} G₂ (Subgroup.{u1} G₂ _inst_7) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G₂ _inst_7) G₂ (Subgroup.instSetLikeSubgroup.{u1} G₂ _inst_7)) x K)) (Subgroup.toGroup.{u1} G₂ _inst_7 K)) (Subgroup.subgroupOf.{u1} G₂ _inst_7 (MonoidHom.range.{u2, u1} G₁ _inst_6 G₂ _inst_7 f) K) (MonoidHom.range.{u2, u1} G₁ _inst_6 (Subtype.{succ u1} G₂ (fun (x : G₂) => Membership.mem.{u1, u1} G₂ (Subgroup.{u1} G₂ _inst_7) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G₂ _inst_7) G₂ (Subgroup.instSetLikeSubgroup.{u1} G₂ _inst_7)) x K)) (Subgroup.toGroup.{u1} G₂ _inst_7 K) (MonoidHom.codRestrict.{u2, u1, u1} G₁ G₂ (Monoid.toMulOneClass.{u2} G₁ (DivInvMonoid.toMonoid.{u2} G₁ (Group.toDivInvMonoid.{u2} G₁ _inst_6))) (Monoid.toMulOneClass.{u1} G₂ (DivInvMonoid.toMonoid.{u1} G₂ (Group.toDivInvMonoid.{u1} G₂ _inst_7))) (Subgroup.{u1} G₂ _inst_7) (Subgroup.instSetLikeSubgroup.{u1} G₂ _inst_7) (SubgroupClass.toSubmonoidClass.{u1, u1} (Subgroup.{u1} G₂ _inst_7) G₂ (Group.toDivInvMonoid.{u1} G₂ _inst_7) (Subgroup.instSetLikeSubgroup.{u1} G₂ _inst_7) (Subgroup.instSubgroupClassSubgroupToDivInvMonoidInstSetLikeSubgroup.{u1} G₂ _inst_7)) f K (fun (x : G₁) => h (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G₁ G₂ (Monoid.toMulOneClass.{u2} G₁ (DivInvMonoid.toMonoid.{u2} G₁ (Group.toDivInvMonoid.{u2} G₁ _inst_6))) (Monoid.toMulOneClass.{u1} G₂ (DivInvMonoid.toMonoid.{u1} G₂ (Group.toDivInvMonoid.{u1} G₂ _inst_7)))) G₁ (fun (_x : G₁) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₁) => G₂) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G₁ G₂ (Monoid.toMulOneClass.{u2} G₁ (DivInvMonoid.toMonoid.{u2} G₁ (Group.toDivInvMonoid.{u2} G₁ _inst_6))) (Monoid.toMulOneClass.{u1} G₂ (DivInvMonoid.toMonoid.{u1} G₂ (Group.toDivInvMonoid.{u1} G₂ _inst_7)))) G₁ G₂ (MulOneClass.toMul.{u2} G₁ (Monoid.toMulOneClass.{u2} G₁ (DivInvMonoid.toMonoid.{u2} G₁ (Group.toDivInvMonoid.{u2} G₁ _inst_6)))) (MulOneClass.toMul.{u1} G₂ (Monoid.toMulOneClass.{u1} G₂ (DivInvMonoid.toMonoid.{u1} G₂ (Group.toDivInvMonoid.{u1} G₂ _inst_7)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G₁ G₂ (Monoid.toMulOneClass.{u2} G₁ (DivInvMonoid.toMonoid.{u2} G₁ (Group.toDivInvMonoid.{u2} G₁ _inst_6))) (Monoid.toMulOneClass.{u1} G₂ (DivInvMonoid.toMonoid.{u1} G₂ (Group.toDivInvMonoid.{u1} G₂ _inst_7)))) G₁ G₂ (Monoid.toMulOneClass.{u2} G₁ (DivInvMonoid.toMonoid.{u2} G₁ (Group.toDivInvMonoid.{u2} G₁ _inst_6))) (Monoid.toMulOneClass.{u1} G₂ (DivInvMonoid.toMonoid.{u1} G₂ (Group.toDivInvMonoid.{u1} G₂ _inst_7))) (MonoidHom.monoidHomClass.{u2, u1} G₁ G₂ (Monoid.toMulOneClass.{u2} G₁ (DivInvMonoid.toMonoid.{u2} G₁ (Group.toDivInvMonoid.{u2} G₁ _inst_6))) (Monoid.toMulOneClass.{u1} G₂ (DivInvMonoid.toMonoid.{u1} G₂ (Group.toDivInvMonoid.{u1} G₂ _inst_7)))))) f x) (Exists.intro.{succ u2} G₁ (fun (y : G₁) => Eq.{succ u1} G₂ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G₁ G₂ (Monoid.toMulOneClass.{u2} G₁ (DivInvMonoid.toMonoid.{u2} G₁ (Group.toDivInvMonoid.{u2} G₁ _inst_6))) (Monoid.toMulOneClass.{u1} G₂ (DivInvMonoid.toMonoid.{u1} G₂ (Group.toDivInvMonoid.{u1} G₂ _inst_7)))) G₁ (fun (_x : G₁) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₁) => G₂) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G₁ G₂ (Monoid.toMulOneClass.{u2} G₁ (DivInvMonoid.toMonoid.{u2} G₁ (Group.toDivInvMonoid.{u2} G₁ _inst_6))) (Monoid.toMulOneClass.{u1} G₂ (DivInvMonoid.toMonoid.{u1} G₂ (Group.toDivInvMonoid.{u1} G₂ _inst_7)))) G₁ G₂ (MulOneClass.toMul.{u2} G₁ (Monoid.toMulOneClass.{u2} G₁ (DivInvMonoid.toMonoid.{u2} G₁ (Group.toDivInvMonoid.{u2} G₁ _inst_6)))) (MulOneClass.toMul.{u1} G₂ (Monoid.toMulOneClass.{u1} G₂ (DivInvMonoid.toMonoid.{u1} G₂ (Group.toDivInvMonoid.{u1} G₂ _inst_7)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G₁ G₂ (Monoid.toMulOneClass.{u2} G₁ (DivInvMonoid.toMonoid.{u2} G₁ (Group.toDivInvMonoid.{u2} G₁ _inst_6))) (Monoid.toMulOneClass.{u1} G₂ (DivInvMonoid.toMonoid.{u1} G₂ (Group.toDivInvMonoid.{u1} G₂ _inst_7)))) G₁ G₂ (Monoid.toMulOneClass.{u2} G₁ (DivInvMonoid.toMonoid.{u2} G₁ (Group.toDivInvMonoid.{u2} G₁ _inst_6))) (Monoid.toMulOneClass.{u1} G₂ (DivInvMonoid.toMonoid.{u1} G₂ (Group.toDivInvMonoid.{u1} G₂ _inst_7))) (MonoidHom.monoidHomClass.{u2, u1} G₁ G₂ (Monoid.toMulOneClass.{u2} G₁ (DivInvMonoid.toMonoid.{u2} G₁ (Group.toDivInvMonoid.{u2} G₁ _inst_6))) (Monoid.toMulOneClass.{u1} G₂ (DivInvMonoid.toMonoid.{u1} G₂ (Group.toDivInvMonoid.{u1} G₂ _inst_7)))))) f y) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G₁ G₂ (Monoid.toMulOneClass.{u2} G₁ (DivInvMonoid.toMonoid.{u2} G₁ (Group.toDivInvMonoid.{u2} G₁ _inst_6))) (Monoid.toMulOneClass.{u1} G₂ (DivInvMonoid.toMonoid.{u1} G₂ (Group.toDivInvMonoid.{u1} G₂ _inst_7)))) G₁ (fun (_x : G₁) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₁) => G₂) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G₁ G₂ (Monoid.toMulOneClass.{u2} G₁ (DivInvMonoid.toMonoid.{u2} G₁ (Group.toDivInvMonoid.{u2} G₁ _inst_6))) (Monoid.toMulOneClass.{u1} G₂ (DivInvMonoid.toMonoid.{u1} G₂ (Group.toDivInvMonoid.{u1} G₂ _inst_7)))) G₁ G₂ (MulOneClass.toMul.{u2} G₁ (Monoid.toMulOneClass.{u2} G₁ (DivInvMonoid.toMonoid.{u2} G₁ (Group.toDivInvMonoid.{u2} G₁ _inst_6)))) (MulOneClass.toMul.{u1} G₂ (Monoid.toMulOneClass.{u1} G₂ (DivInvMonoid.toMonoid.{u1} G₂ (Group.toDivInvMonoid.{u1} G₂ _inst_7)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G₁ G₂ (Monoid.toMulOneClass.{u2} G₁ (DivInvMonoid.toMonoid.{u2} G₁ (Group.toDivInvMonoid.{u2} G₁ _inst_6))) (Monoid.toMulOneClass.{u1} G₂ (DivInvMonoid.toMonoid.{u1} G₂ (Group.toDivInvMonoid.{u1} G₂ _inst_7)))) G₁ G₂ (Monoid.toMulOneClass.{u2} G₁ (DivInvMonoid.toMonoid.{u2} G₁ (Group.toDivInvMonoid.{u2} G₁ _inst_6))) (Monoid.toMulOneClass.{u1} G₂ (DivInvMonoid.toMonoid.{u1} G₂ (Group.toDivInvMonoid.{u1} G₂ _inst_7))) (MonoidHom.monoidHomClass.{u2, u1} G₁ G₂ (Monoid.toMulOneClass.{u2} G₁ (DivInvMonoid.toMonoid.{u2} G₁ (Group.toDivInvMonoid.{u2} G₁ _inst_6))) (Monoid.toMulOneClass.{u1} G₂ (DivInvMonoid.toMonoid.{u1} G₂ (Group.toDivInvMonoid.{u1} G₂ _inst_7)))))) f x)) x (rfl.{succ u1} G₂ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G₁ G₂ (Monoid.toMulOneClass.{u2} G₁ (DivInvMonoid.toMonoid.{u2} G₁ (Group.toDivInvMonoid.{u2} G₁ _inst_6))) (Monoid.toMulOneClass.{u1} G₂ (DivInvMonoid.toMonoid.{u1} G₂ (Group.toDivInvMonoid.{u1} G₂ _inst_7)))) G₁ (fun (_x : G₁) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₁) => G₂) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G₁ G₂ (Monoid.toMulOneClass.{u2} G₁ (DivInvMonoid.toMonoid.{u2} G₁ (Group.toDivInvMonoid.{u2} G₁ _inst_6))) (Monoid.toMulOneClass.{u1} G₂ (DivInvMonoid.toMonoid.{u1} G₂ (Group.toDivInvMonoid.{u1} G₂ _inst_7)))) G₁ G₂ (MulOneClass.toMul.{u2} G₁ (Monoid.toMulOneClass.{u2} G₁ (DivInvMonoid.toMonoid.{u2} G₁ (Group.toDivInvMonoid.{u2} G₁ _inst_6)))) (MulOneClass.toMul.{u1} G₂ (Monoid.toMulOneClass.{u1} G₂ (DivInvMonoid.toMonoid.{u1} G₂ (Group.toDivInvMonoid.{u1} G₂ _inst_7)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G₁ G₂ (Monoid.toMulOneClass.{u2} G₁ (DivInvMonoid.toMonoid.{u2} G₁ (Group.toDivInvMonoid.{u2} G₁ _inst_6))) (Monoid.toMulOneClass.{u1} G₂ (DivInvMonoid.toMonoid.{u1} G₂ (Group.toDivInvMonoid.{u1} G₂ _inst_7)))) G₁ G₂ (Monoid.toMulOneClass.{u2} G₁ (DivInvMonoid.toMonoid.{u2} G₁ (Group.toDivInvMonoid.{u2} G₁ _inst_6))) (Monoid.toMulOneClass.{u1} G₂ (DivInvMonoid.toMonoid.{u1} G₂ (Group.toDivInvMonoid.{u1} G₂ _inst_7))) (MonoidHom.monoidHomClass.{u2, u1} G₁ G₂ (Monoid.toMulOneClass.{u2} G₁ (DivInvMonoid.toMonoid.{u2} G₁ (Group.toDivInvMonoid.{u2} G₁ _inst_6))) (Monoid.toMulOneClass.{u1} G₂ (DivInvMonoid.toMonoid.{u1} G₂ (Group.toDivInvMonoid.{u1} G₂ _inst_7)))))) f x))))))
Case conversion may be inaccurate. Consider using '#align monoid_hom.subgroup_of_range_eq_of_le MonoidHom.subgroupOf_range_eq_of_leₓ'. -/
@[to_additive]
theorem subgroupOf_range_eq_of_le {G₁ G₂ : Type _} [Group G₁] [Group G₂] {K : Subgroup G₂}
    (f : G₁ →* G₂) (h : f.range ≤ K) :
    f.range.subgroupOf K = (f.codRestrict K fun x => h ⟨x, rfl⟩).range :=
  by
  ext k
  refine' exists_congr _
  simp [Subtype.ext_iff]
#align monoid_hom.subgroup_of_range_eq_of_le MonoidHom.subgroupOf_range_eq_of_le
#align add_monoid_hom.add_subgroup_of_range_eq_of_le AddMonoidHom.addSubgroupOf_range_eq_of_le

/- warning: monoid_hom.of_left_inverse -> MonoidHom.ofLeftInverse is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))} {g : MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))}, (Function.LeftInverse.{succ u1, succ u2} G N (coeFn.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => N -> G) (MonoidHom.hasCoeToFun.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) g) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f)) -> (MulEquiv.{u1, u2} G (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.mul.{u2} N _inst_4 (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))} {g : MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))}, (Function.LeftInverse.{succ u1, succ u2} G N (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) N (fun (_x : N) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : N) => G) _x) (MulHomClass.toFunLike.{max u1 u2, u2, u1} (MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) N G (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u2, u1} (MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (MonoidHom.monoidHomClass.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) g) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) G N (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (MonoidHom.monoidHomClass.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))))) f)) -> (MulEquiv.{u1, u2} G (Subtype.{succ u2} N (fun (x : N) => Membership.mem.{u2, u2} N (Subgroup.{u2} N _inst_4) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u2} N _inst_4)) x (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.mul.{u2} N _inst_4 (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)))
Case conversion may be inaccurate. Consider using '#align monoid_hom.of_left_inverse MonoidHom.ofLeftInverseₓ'. -/
/-- Computable alternative to `monoid_hom.of_injective`. -/
@[to_additive "Computable alternative to `add_monoid_hom.of_injective`."]
def ofLeftInverse {f : G →* N} {g : N →* G} (h : Function.LeftInverse g f) : G ≃* f.range :=
  { f.range_restrict with
    toFun := f.range_restrict
    invFun := g ∘ f.range.Subtype
    left_inv := h
    right_inv := by
      rintro ⟨x, y, rfl⟩
      apply Subtype.ext
      rw [coe_range_restrict, Function.comp_apply, Subgroup.coeSubtype, Subtype.coe_mk, h] }
#align monoid_hom.of_left_inverse MonoidHom.ofLeftInverse
#align add_monoid_hom.of_left_inverse AddMonoidHom.ofLeftInverse

/- warning: monoid_hom.of_left_inverse_apply -> MonoidHom.ofLeftInverse_apply is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))} {g : MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))} (h : Function.LeftInverse.{succ u1, succ u2} G N (coeFn.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => N -> G) (MonoidHom.hasCoeToFun.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) g) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f)) (x : G), Eq.{succ u2} N ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) N (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) N (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) N (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) N (coeSubtype.{succ u2} N (fun (x : N) => Membership.Mem.{u2, u2} N (Subgroup.{u2} N _inst_4) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) x (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (MulEquiv.{u1, u2} G (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.mul.{u2} N _inst_4 (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f))) (fun (_x : MulEquiv.{u1, u2} G (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.mul.{u2} N _inst_4 (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f))) => G -> (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f))) (MulEquiv.hasCoeToFun.{u1, u2} G (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.mul.{u2} N _inst_4 (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f))) (MonoidHom.ofLeftInverse.{u1, u2} G _inst_1 N _inst_4 f g h) x)) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f x)
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))} {g : MonoidHom.{u1, u2} N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))} (h : Function.LeftInverse.{succ u2, succ u1} G N (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (MonoidHom.{u1, u2} N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) N (fun (_x : N) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : N) => G) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (MonoidHom.{u1, u2} N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) N G (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u1, u2} (MonoidHom.{u1, u2} N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (MonoidHom.monoidHomClass.{u1, u2} N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))) g) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f)) (x : G), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) x) (Subtype.val.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Set.{u1} N) (Set.instMembershipSet.{u1} N) x (SetLike.coe.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4) (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulEquiv.{u2, u1} G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Subgroup.mul.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Subgroup.mul.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Subgroup.mul.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Subgroup.mul.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Subgroup.mul.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)))))) (MonoidHom.ofLeftInverse.{u2, u1} G _inst_1 N _inst_4 f g h) x)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f x)
Case conversion may be inaccurate. Consider using '#align monoid_hom.of_left_inverse_apply MonoidHom.ofLeftInverse_applyₓ'. -/
@[simp, to_additive]
theorem ofLeftInverse_apply {f : G →* N} {g : N →* G} (h : Function.LeftInverse g f) (x : G) :
    ↑(ofLeftInverse h x) = f x :=
  rfl
#align monoid_hom.of_left_inverse_apply MonoidHom.ofLeftInverse_apply
#align add_monoid_hom.of_left_inverse_apply AddMonoidHom.ofLeftInverse_apply

/- warning: monoid_hom.of_left_inverse_symm_apply -> MonoidHom.ofLeftInverse_symm_apply is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))} {g : MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))} (h : Function.LeftInverse.{succ u1, succ u2} G N (coeFn.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => N -> G) (MonoidHom.hasCoeToFun.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) g) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f)) (x : coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)), Eq.{succ u1} G (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (MulEquiv.{u2, u1} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) G (Subgroup.mul.{u2} N _inst_4 (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (fun (_x : MulEquiv.{u2, u1} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) G (Subgroup.mul.{u2} N _inst_4 (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) => (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) -> G) (MulEquiv.hasCoeToFun.{u2, u1} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) G (Subgroup.mul.{u2} N _inst_4 (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulEquiv.symm.{u1, u2} G (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.mul.{u2} N _inst_4 (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (MonoidHom.ofLeftInverse.{u1, u2} G _inst_1 N _inst_4 f g h)) x) (coeFn.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => N -> G) (MonoidHom.hasCoeToFun.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) g ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) N (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) N (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) N (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) N (coeSubtype.{succ u2} N (fun (x : N) => Membership.Mem.{u2, u2} N (Subgroup.{u2} N _inst_4) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) x (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)))))) x))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))} {g : MonoidHom.{u1, u2} N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))} (h : Function.LeftInverse.{succ u2, succ u1} G N (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (MonoidHom.{u1, u2} N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) N (fun (_x : N) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : N) => G) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (MonoidHom.{u1, u2} N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) N G (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u1, u2} (MonoidHom.{u1, u2} N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (MonoidHom.monoidHomClass.{u1, u2} N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))) g) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f)) (x : Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) => G) x) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (MulEquiv.{u1, u2} (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) G (Subgroup.mul.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (fun (_x : Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) => G) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (MulEquiv.{u1, u2} (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) G (Subgroup.mul.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) G (MulOneClass.toMul.{u1} (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u1, u2} (MulEquiv.{u1, u2} (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) G (Subgroup.mul.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) G (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u1, u2} (MulEquiv.{u1, u2} (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) G (Subgroup.mul.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) G (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (MulEquiv.instMulEquivClassMulEquiv.{u1, u2} (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) G (Subgroup.mul.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))))) (MulEquiv.symm.{u2, u1} G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Subgroup.mul.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)) (MonoidHom.ofLeftInverse.{u2, u1} G _inst_1 N _inst_4 f g h)) x) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (MonoidHom.{u1, u2} N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) N (fun (_x : N) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : N) => G) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (MonoidHom.{u1, u2} N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) N G (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u1, u2} (MonoidHom.{u1, u2} N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (MonoidHom.monoidHomClass.{u1, u2} N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))) g (Subtype.val.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Set.{u1} N) (Set.instMembershipSet.{u1} N) x (SetLike.coe.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4) (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) x))
Case conversion may be inaccurate. Consider using '#align monoid_hom.of_left_inverse_symm_apply MonoidHom.ofLeftInverse_symm_applyₓ'. -/
@[simp, to_additive]
theorem ofLeftInverse_symm_apply {f : G →* N} {g : N →* G} (h : Function.LeftInverse g f)
    (x : f.range) : (ofLeftInverse h).symm x = g x :=
  rfl
#align monoid_hom.of_left_inverse_symm_apply MonoidHom.ofLeftInverse_symm_apply
#align add_monoid_hom.of_left_inverse_symm_apply AddMonoidHom.ofLeftInverse_symm_apply

/- warning: monoid_hom.of_injective -> MonoidHom.ofInjective is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))}, (Function.Injective.{succ u1, succ u2} G N (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f)) -> (MulEquiv.{u1, u2} G (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.mul.{u2} N _inst_4 (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))}, (Function.Injective.{succ u1, succ u2} G N (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) G N (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (MonoidHom.monoidHomClass.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))))) f)) -> (MulEquiv.{u1, u2} G (Subtype.{succ u2} N (fun (x : N) => Membership.mem.{u2, u2} N (Subgroup.{u2} N _inst_4) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u2} N _inst_4)) x (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.mul.{u2} N _inst_4 (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)))
Case conversion may be inaccurate. Consider using '#align monoid_hom.of_injective MonoidHom.ofInjectiveₓ'. -/
/-- The range of an injective group homomorphism is isomorphic to its domain. -/
@[to_additive "The range of an injective additive group homomorphism is isomorphic to its\ndomain."]
noncomputable def ofInjective {f : G →* N} (hf : Function.Injective f) : G ≃* f.range :=
  MulEquiv.ofBijective (f.codRestrict f.range fun x => ⟨x, rfl⟩)
    ⟨fun x y h => hf (Subtype.ext_iff.mp h),
      by
      rintro ⟨x, y, rfl⟩
      exact ⟨y, rfl⟩⟩
#align monoid_hom.of_injective MonoidHom.ofInjective
#align add_monoid_hom.of_injective AddMonoidHom.ofInjective

/- warning: monoid_hom.of_injective_apply -> MonoidHom.ofInjective_apply is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))} (hf : Function.Injective.{succ u1, succ u2} G N (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f)) {x : G}, Eq.{succ u2} N ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) N (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) N (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) N (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) N (coeSubtype.{succ u2} N (fun (x : N) => Membership.Mem.{u2, u2} N (Subgroup.{u2} N _inst_4) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) x (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (MulEquiv.{u1, u2} G (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.mul.{u2} N _inst_4 (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f))) (fun (_x : MulEquiv.{u1, u2} G (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.mul.{u2} N _inst_4 (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f))) => G -> (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f))) (MulEquiv.hasCoeToFun.{u1, u2} G (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.mul.{u2} N _inst_4 (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f))) (MonoidHom.ofInjective.{u1, u2} G _inst_1 N _inst_4 f hf) x)) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f x)
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))} (hf : Function.Injective.{succ u2, succ u1} G N (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f)) {x : G}, Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) x) (Subtype.val.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Set.{u1} N) (Set.instMembershipSet.{u1} N) x (SetLike.coe.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4) (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulEquiv.{u2, u1} G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Subgroup.mul.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Subgroup.mul.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Subgroup.mul.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Subgroup.mul.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Subgroup.mul.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)))))) (MonoidHom.ofInjective.{u2, u1} G _inst_1 N _inst_4 f hf) x)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f x)
Case conversion may be inaccurate. Consider using '#align monoid_hom.of_injective_apply MonoidHom.ofInjective_applyₓ'. -/
@[to_additive]
theorem ofInjective_apply {f : G →* N} (hf : Function.Injective f) {x : G} :
    ↑(ofInjective hf x) = f x :=
  rfl
#align monoid_hom.of_injective_apply MonoidHom.ofInjective_apply
#align add_monoid_hom.of_injective_apply AddMonoidHom.ofInjective_apply

section Ker

variable {M : Type _} [MulOneClass M]

#print MonoidHom.ker /-
/-- The multiplicative kernel of a monoid homomorphism is the subgroup of elements `x : G` such that
`f x = 1` -/
@[to_additive
      "The additive kernel of an `add_monoid` homomorphism is the `add_subgroup` of elements\nsuch that `f x = 0`"]
def ker (f : G →* M) : Subgroup G :=
  { f.mker with
    inv_mem' := fun x (hx : f x = 1) =>
      calc
        f x⁻¹ = f x * f x⁻¹ := by rw [hx, one_mul]
        _ = 1 := by rw [← map_mul, mul_inv_self, map_one]
         }
#align monoid_hom.ker MonoidHom.ker
#align add_monoid_hom.ker AddMonoidHom.ker
-/

/- warning: monoid_hom.mem_ker -> MonoidHom.mem_ker is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {M : Type.{u2}} [_inst_6 : MulOneClass.{u2} M] (f : MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) _inst_6) {x : G}, Iff (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (MonoidHom.ker.{u1, u2} G _inst_1 M _inst_6 f)) (Eq.{succ u2} M (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) _inst_6) (fun (_x : MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) _inst_6) => G -> M) (MonoidHom.hasCoeToFun.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) _inst_6) f x) (OfNat.ofNat.{u2} M 1 (OfNat.mk.{u2} M 1 (One.one.{u2} M (MulOneClass.toHasOne.{u2} M _inst_6)))))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {M : Type.{u1}} [_inst_6 : MulOneClass.{u1} M] (f : MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6) {x : G}, Iff (Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x (MonoidHom.ker.{u2, u1} G _inst_1 M _inst_6 f)) (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => M) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => M) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6) G M (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} M _inst_6) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6) G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6 (MonoidHom.monoidHomClass.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6))) f x) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => M) x) 1 (One.toOfNat1.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => M) x) (MulOneClass.toOne.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => M) x) _inst_6))))
Case conversion may be inaccurate. Consider using '#align monoid_hom.mem_ker MonoidHom.mem_kerₓ'. -/
@[to_additive]
theorem mem_ker (f : G →* M) {x : G} : x ∈ f.ker ↔ f x = 1 :=
  Iff.rfl
#align monoid_hom.mem_ker MonoidHom.mem_ker
#align add_monoid_hom.mem_ker AddMonoidHom.mem_ker

/- warning: monoid_hom.coe_ker -> MonoidHom.coe_ker is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {M : Type.{u2}} [_inst_6 : MulOneClass.{u2} M] (f : MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) _inst_6), Eq.{succ u1} (Set.{u1} G) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (MonoidHom.ker.{u1, u2} G _inst_1 M _inst_6 f)) (Set.preimage.{u1, u2} G M (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) _inst_6) (fun (_x : MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) _inst_6) => G -> M) (MonoidHom.hasCoeToFun.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) _inst_6) f) (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) (OfNat.ofNat.{u2} M 1 (OfNat.mk.{u2} M 1 (One.one.{u2} M (MulOneClass.toHasOne.{u2} M _inst_6))))))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {M : Type.{u1}} [_inst_6 : MulOneClass.{u1} M] (f : MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6), Eq.{succ u2} (Set.{u2} G) (SetLike.coe.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1) (MonoidHom.ker.{u2, u1} G _inst_1 M _inst_6 f)) (Set.preimage.{u2, u1} G M (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => M) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6) G M (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} M _inst_6) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6) G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6 (MonoidHom.monoidHomClass.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6))) f) (Singleton.singleton.{u1, u1} M (Set.{u1} M) (Set.instSingletonSet.{u1} M) (OfNat.ofNat.{u1} M 1 (One.toOfNat1.{u1} M (MulOneClass.toOne.{u1} M _inst_6)))))
Case conversion may be inaccurate. Consider using '#align monoid_hom.coe_ker MonoidHom.coe_kerₓ'. -/
@[to_additive]
theorem coe_ker (f : G →* M) : (f.ker : Set G) = (f : G → M) ⁻¹' {1} :=
  rfl
#align monoid_hom.coe_ker MonoidHom.coe_ker
#align add_monoid_hom.coe_ker AddMonoidHom.coe_ker

/- warning: monoid_hom.ker_to_hom_units -> MonoidHom.ker_toHomUnits is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {M : Type.{u2}} [_inst_7 : Monoid.{u2} M] (f : MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_7)), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (MonoidHom.ker.{u1, u2} G _inst_1 (Units.{u2} M _inst_7) (Units.mulOneClass.{u2} M _inst_7) (MonoidHom.toHomUnits.{u1, u2} G M _inst_1 _inst_7 f)) (MonoidHom.ker.{u1, u2} G _inst_1 M (Monoid.toMulOneClass.{u2} M _inst_7) f)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {M : Type.{u2}} [_inst_7 : Monoid.{u2} M] (f : MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_7)), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (MonoidHom.ker.{u1, u2} G _inst_1 (Units.{u2} M _inst_7) (Units.instMulOneClassUnits.{u2} M _inst_7) (MonoidHom.toHomUnits.{u1, u2} G M _inst_1 _inst_7 f)) (MonoidHom.ker.{u1, u2} G _inst_1 M (Monoid.toMulOneClass.{u2} M _inst_7) f)
Case conversion may be inaccurate. Consider using '#align monoid_hom.ker_to_hom_units MonoidHom.ker_toHomUnitsₓ'. -/
@[simp, to_additive]
theorem ker_toHomUnits {M} [Monoid M] (f : G →* M) : f.toHomUnits.ker = f.ker :=
  by
  ext x
  simp [mem_ker, Units.ext_iff]
#align monoid_hom.ker_to_hom_units MonoidHom.ker_toHomUnits
#align add_monoid_hom.ker_to_hom_add_units AddMonoidHom.ker_toHomAddUnits

/- warning: monoid_hom.eq_iff -> MonoidHom.eq_iff is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {M : Type.{u2}} [_inst_6 : MulOneClass.{u2} M] (f : MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) _inst_6) {x : G} {y : G}, Iff (Eq.{succ u2} M (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) _inst_6) (fun (_x : MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) _inst_6) => G -> M) (MonoidHom.hasCoeToFun.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) _inst_6) f x) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) _inst_6) (fun (_x : MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) _inst_6) => G -> M) (MonoidHom.hasCoeToFun.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) _inst_6) f y)) (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) y) x) (MonoidHom.ker.{u1, u2} G _inst_1 M _inst_6 f))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {M : Type.{u1}} [_inst_6 : MulOneClass.{u1} M] (f : MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6) {x : G} {y : G}, Iff (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => M) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => M) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6) G M (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} M _inst_6) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6) G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6 (MonoidHom.monoidHomClass.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => M) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6) G M (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} M _inst_6) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6) G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6 (MonoidHom.monoidHomClass.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6))) f y)) (Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) (HMul.hMul.{u2, u2, u2} G G G (instHMul.{u2} G (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (Inv.inv.{u2} G (InvOneClass.toInv.{u2} G (DivInvOneMonoid.toInvOneClass.{u2} G (DivisionMonoid.toDivInvOneMonoid.{u2} G (Group.toDivisionMonoid.{u2} G _inst_1)))) y) x) (MonoidHom.ker.{u2, u1} G _inst_1 M _inst_6 f))
Case conversion may be inaccurate. Consider using '#align monoid_hom.eq_iff MonoidHom.eq_iffₓ'. -/
@[to_additive]
theorem eq_iff (f : G →* M) {x y : G} : f x = f y ↔ y⁻¹ * x ∈ f.ker :=
  by
  constructor <;> intro h
  · rw [mem_ker, map_mul, h, ← map_mul, inv_mul_self, map_one]
  · rw [← one_mul x, ← mul_inv_self y, mul_assoc, map_mul, f.mem_ker.1 h, mul_one]
#align monoid_hom.eq_iff MonoidHom.eq_iff
#align add_monoid_hom.eq_iff AddMonoidHom.eq_iff

/- warning: monoid_hom.decidable_mem_ker -> MonoidHom.decidableMemKer is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {M : Type.{u2}} [_inst_6 : MulOneClass.{u2} M] [_inst_7 : DecidableEq.{succ u2} M] (f : MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) _inst_6), DecidablePred.{succ u1} G (fun (_x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) _x (MonoidHom.ker.{u1, u2} G _inst_1 M _inst_6 f))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {M : Type.{u2}} [_inst_6 : MulOneClass.{u2} M] [_inst_7 : DecidableEq.{succ u2} M] (f : MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) _inst_6), DecidablePred.{succ u1} G (fun (_x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) _x (MonoidHom.ker.{u1, u2} G _inst_1 M _inst_6 f))
Case conversion may be inaccurate. Consider using '#align monoid_hom.decidable_mem_ker MonoidHom.decidableMemKerₓ'. -/
@[to_additive]
instance decidableMemKer [DecidableEq M] (f : G →* M) : DecidablePred (· ∈ f.ker) := fun x =>
  decidable_of_iff (f x = 1) f.mem_ker
#align monoid_hom.decidable_mem_ker MonoidHom.decidableMemKer
#align add_monoid_hom.decidable_mem_ker AddMonoidHom.decidableMemKer

/- warning: monoid_hom.comap_ker -> MonoidHom.comap_ker is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} {P : Type.{u3}} [_inst_4 : Group.{u2} N] [_inst_5 : Group.{u3} P] (g : MonoidHom.{u2, u3} N P (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u3} P (DivInvMonoid.toMonoid.{u3} P (Group.toDivInvMonoid.{u3} P _inst_5)))) (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f (MonoidHom.ker.{u2, u3} N _inst_4 P (Monoid.toMulOneClass.{u3} P (DivInvMonoid.toMonoid.{u3} P (Group.toDivInvMonoid.{u3} P _inst_5))) g)) (MonoidHom.ker.{u1, u3} G _inst_1 P (Monoid.toMulOneClass.{u3} P (DivInvMonoid.toMonoid.{u3} P (Group.toDivInvMonoid.{u3} P _inst_5))) (MonoidHom.comp.{u1, u2, u3} G N P (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u3} P (DivInvMonoid.toMonoid.{u3} P (Group.toDivInvMonoid.{u3} P _inst_5))) g f))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u3}} {P : Type.{u2}} [_inst_4 : Group.{u3} N] [_inst_5 : Group.{u2} P] (g : MonoidHom.{u3, u2} N P (Monoid.toMulOneClass.{u3} N (DivInvMonoid.toMonoid.{u3} N (Group.toDivInvMonoid.{u3} N _inst_4))) (Monoid.toMulOneClass.{u2} P (DivInvMonoid.toMonoid.{u2} P (Group.toDivInvMonoid.{u2} P _inst_5)))) (f : MonoidHom.{u1, u3} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u3} N (DivInvMonoid.toMonoid.{u3} N (Group.toDivInvMonoid.{u3} N _inst_4)))), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.comap.{u1, u3} G _inst_1 N _inst_4 f (MonoidHom.ker.{u3, u2} N _inst_4 P (Monoid.toMulOneClass.{u2} P (DivInvMonoid.toMonoid.{u2} P (Group.toDivInvMonoid.{u2} P _inst_5))) g)) (MonoidHom.ker.{u1, u2} G _inst_1 P (Monoid.toMulOneClass.{u2} P (DivInvMonoid.toMonoid.{u2} P (Group.toDivInvMonoid.{u2} P _inst_5))) (MonoidHom.comp.{u1, u3, u2} G N P (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u3} N (DivInvMonoid.toMonoid.{u3} N (Group.toDivInvMonoid.{u3} N _inst_4))) (Monoid.toMulOneClass.{u2} P (DivInvMonoid.toMonoid.{u2} P (Group.toDivInvMonoid.{u2} P _inst_5))) g f))
Case conversion may be inaccurate. Consider using '#align monoid_hom.comap_ker MonoidHom.comap_kerₓ'. -/
@[to_additive]
theorem comap_ker (g : N →* P) (f : G →* N) : g.ker.comap f = (g.comp f).ker :=
  rfl
#align monoid_hom.comap_ker MonoidHom.comap_ker
#align add_monoid_hom.comap_ker AddMonoidHom.comap_ker

/- warning: monoid_hom.comap_bot -> MonoidHom.comap_bot is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f (Bot.bot.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.hasBot.{u2} N _inst_4))) (MonoidHom.ker.{u1, u2} G _inst_1 N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) f)
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))), Eq.{succ u2} (Subgroup.{u2} G _inst_1) (Subgroup.comap.{u2, u1} G _inst_1 N _inst_4 f (Bot.bot.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instBotSubgroup.{u1} N _inst_4))) (MonoidHom.ker.{u2, u1} G _inst_1 N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) f)
Case conversion may be inaccurate. Consider using '#align monoid_hom.comap_bot MonoidHom.comap_botₓ'. -/
@[simp, to_additive]
theorem comap_bot (f : G →* N) : (⊥ : Subgroup N).comap f = f.ker :=
  rfl
#align monoid_hom.comap_bot MonoidHom.comap_bot
#align add_monoid_hom.comap_bot AddMonoidHom.comap_bot

/- warning: monoid_hom.ker_restrict -> MonoidHom.ker_restrict is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (K : Subgroup.{u1} G _inst_1) (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K)) (MonoidHom.ker.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K) N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (MonoidHom.restrict.{u1, u2, u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) N (Subgroup.{u1} G _inst_1) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Subgroup.setLike.{u1} G _inst_1) (SubgroupClass.to_submonoidClass.{u1, u1} (Subgroup.{u1} G _inst_1) G (Group.toDivInvMonoid.{u1} G _inst_1) (Subgroup.setLike.{u1} G _inst_1) (Subgroup.subgroupClass.{u1} G _inst_1)) f K)) (Subgroup.subgroupOf.{u1} G _inst_1 (MonoidHom.ker.{u1, u2} G _inst_1 N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) f) K)
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (K : Subgroup.{u2} G _inst_1) (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))), Eq.{succ u2} (Subgroup.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x K)) (Subgroup.toGroup.{u2} G _inst_1 K)) (MonoidHom.ker.{u2, u1} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x K)) (Subgroup.toGroup.{u2} G _inst_1 K) N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.restrict.{u2, u1, u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) N (Subgroup.{u2} G _inst_1) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.instSetLikeSubgroup.{u2} G _inst_1) (SubgroupClass.toSubmonoidClass.{u2, u2} (Subgroup.{u2} G _inst_1) G (Group.toDivInvMonoid.{u2} G _inst_1) (Subgroup.instSetLikeSubgroup.{u2} G _inst_1) (Subgroup.instSubgroupClassSubgroupToDivInvMonoidInstSetLikeSubgroup.{u2} G _inst_1)) f K)) (Subgroup.subgroupOf.{u2} G _inst_1 (MonoidHom.ker.{u2, u1} G _inst_1 N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) f) K)
Case conversion may be inaccurate. Consider using '#align monoid_hom.ker_restrict MonoidHom.ker_restrictₓ'. -/
@[simp, to_additive]
theorem ker_restrict (f : G →* N) : (f.restrict K).ker = f.ker.subgroupOf K :=
  rfl
#align monoid_hom.ker_restrict MonoidHom.ker_restrict
#align add_monoid_hom.ker_restrict AddMonoidHom.ker_restrict

/- warning: monoid_hom.ker_cod_restrict -> MonoidHom.ker_codRestrict is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {S : Type.{u3}} [_inst_7 : SetLike.{u3, u2} S N] [_inst_8 : SubmonoidClass.{u3, u2} S N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) _inst_7] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (s : S) (h : forall (x : G), Membership.Mem.{u2, u3} N S (SetLike.hasMem.{u3, u2} S N _inst_7) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f x) s), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (MonoidHom.ker.{u1, u2} G _inst_1 (coeSort.{succ u3, succ (succ u2)} S Type.{u2} (SetLike.hasCoeToSort.{u3, u2} S N _inst_7) s) (SubmonoidClass.toMulOneClass.{u2, u3} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) S _inst_7 _inst_8 s) (MonoidHom.codRestrict.{u1, u2, u3} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) S _inst_7 _inst_8 f s h)) (MonoidHom.ker.{u1, u2} G _inst_1 N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) f)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {S : Type.{u3}} [_inst_7 : SetLike.{u3, u2} S N] [_inst_8 : SubmonoidClass.{u3, u2} S N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) _inst_7] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (s : S) (h : forall (x : G), Membership.mem.{u2, u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) x) S (SetLike.instMembership.{u3, u2} S N _inst_7) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) G N (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (MonoidHom.monoidHomClass.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))))) f x) s), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (MonoidHom.ker.{u1, u2} G _inst_1 (Subtype.{succ u2} N (fun (x : N) => Membership.mem.{u2, u3} N S (SetLike.instMembership.{u3, u2} S N _inst_7) x s)) (SubmonoidClass.toMulOneClass.{u2, u3} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) S _inst_7 _inst_8 s) (MonoidHom.codRestrict.{u1, u2, u3} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) S _inst_7 _inst_8 f s h)) (MonoidHom.ker.{u1, u2} G _inst_1 N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) f)
Case conversion may be inaccurate. Consider using '#align monoid_hom.ker_cod_restrict MonoidHom.ker_codRestrictₓ'. -/
@[simp, to_additive]
theorem ker_codRestrict {S} [SetLike S N] [SubmonoidClass S N] (f : G →* N) (s : S)
    (h : ∀ x, f x ∈ s) : (f.codRestrict s h).ker = f.ker :=
  SetLike.ext fun x => Subtype.ext_iff
#align monoid_hom.ker_cod_restrict MonoidHom.ker_codRestrict
#align add_monoid_hom.ker_cod_restrict AddMonoidHom.ker_codRestrict

/- warning: monoid_hom.ker_range_restrict -> MonoidHom.ker_rangeRestrict is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (MonoidHom.ker.{u1, u2} G _inst_1 (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Monoid.toMulOneClass.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (DivInvMonoid.toMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Group.toDivInvMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Subgroup.toGroup.{u2} N _inst_4 (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f))))) (MonoidHom.rangeRestrict.{u1, u2} G _inst_1 N _inst_4 f)) (MonoidHom.ker.{u1, u2} G _inst_1 N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) f)
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))), Eq.{succ u2} (Subgroup.{u2} G _inst_1) (MonoidHom.ker.{u2, u1} G _inst_1 (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f))) (MonoidHom.rangeRestrict.{u2, u1} G _inst_1 N _inst_4 f)) (MonoidHom.ker.{u2, u1} G _inst_1 N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) f)
Case conversion may be inaccurate. Consider using '#align monoid_hom.ker_range_restrict MonoidHom.ker_rangeRestrictₓ'. -/
@[simp, to_additive]
theorem ker_rangeRestrict (f : G →* N) : ker (rangeRestrict f) = ker f :=
  ker_codRestrict _ _ _
#align monoid_hom.ker_range_restrict MonoidHom.ker_rangeRestrict
#align add_monoid_hom.ker_range_restrict AddMonoidHom.ker_rangeRestrict

/- warning: monoid_hom.ker_one -> MonoidHom.ker_one is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {M : Type.{u2}} [_inst_6 : MulOneClass.{u2} M], Eq.{succ u1} (Subgroup.{u1} G _inst_1) (MonoidHom.ker.{u1, u2} G _inst_1 M _inst_6 (OfNat.ofNat.{max u2 u1} (MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) _inst_6) 1 (OfNat.mk.{max u2 u1} (MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) _inst_6) 1 (One.one.{max u2 u1} (MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) _inst_6) (MonoidHom.hasOne.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) _inst_6))))) (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasTop.{u1} G _inst_1))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {M : Type.{u1}} [_inst_6 : MulOneClass.{u1} M], Eq.{succ u2} (Subgroup.{u2} G _inst_1) (MonoidHom.ker.{u2, u1} G _inst_1 M _inst_6 (OfNat.ofNat.{max u2 u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6) 1 (One.toOfNat1.{max u2 u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6) (instOneMonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6)))) (Top.top.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instTopSubgroup.{u2} G _inst_1))
Case conversion may be inaccurate. Consider using '#align monoid_hom.ker_one MonoidHom.ker_oneₓ'. -/
@[simp, to_additive]
theorem ker_one : (1 : G →* M).ker = ⊤ :=
  SetLike.ext fun x => eq_self_iff_true _
#align monoid_hom.ker_one MonoidHom.ker_one
#align add_monoid_hom.ker_zero AddMonoidHom.ker_zero

/- warning: monoid_hom.ker_id -> MonoidHom.ker_id is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Eq.{succ u1} (Subgroup.{u1} G _inst_1) (MonoidHom.ker.{u1, u1} G _inst_1 G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (MonoidHom.id.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Eq.{succ u1} (Subgroup.{u1} G _inst_1) (MonoidHom.ker.{u1, u1} G _inst_1 G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (MonoidHom.id.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1))
Case conversion may be inaccurate. Consider using '#align monoid_hom.ker_id MonoidHom.ker_idₓ'. -/
@[simp, to_additive]
theorem ker_id : (MonoidHom.id G).ker = ⊥ :=
  rfl
#align monoid_hom.ker_id MonoidHom.ker_id
#align add_monoid_hom.ker_id AddMonoidHom.ker_id

/- warning: monoid_hom.ker_eq_bot_iff -> MonoidHom.ker_eq_bot_iff is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {M : Type.{u2}} [_inst_6 : MulOneClass.{u2} M] (f : MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) _inst_6), Iff (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (MonoidHom.ker.{u1, u2} G _inst_1 M _inst_6 f) (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1))) (Function.Injective.{succ u1, succ u2} G M (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) _inst_6) (fun (_x : MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) _inst_6) => G -> M) (MonoidHom.hasCoeToFun.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) _inst_6) f))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {M : Type.{u1}} [_inst_6 : MulOneClass.{u1} M] (f : MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6), Iff (Eq.{succ u2} (Subgroup.{u2} G _inst_1) (MonoidHom.ker.{u2, u1} G _inst_1 M _inst_6 f) (Bot.bot.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instBotSubgroup.{u2} G _inst_1))) (Function.Injective.{succ u2, succ u1} G M (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => M) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6) G M (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} M _inst_6) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6) G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6 (MonoidHom.monoidHomClass.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) _inst_6))) f))
Case conversion may be inaccurate. Consider using '#align monoid_hom.ker_eq_bot_iff MonoidHom.ker_eq_bot_iffₓ'. -/
@[to_additive]
theorem ker_eq_bot_iff (f : G →* M) : f.ker = ⊥ ↔ Function.Injective f :=
  ⟨fun h x y hxy => by rwa [eq_iff, h, mem_bot, inv_mul_eq_one, eq_comm] at hxy, fun h =>
    bot_unique fun x hx => h (hx.trans f.map_one.symm)⟩
#align monoid_hom.ker_eq_bot_iff MonoidHom.ker_eq_bot_iff
#align add_monoid_hom.ker_eq_bot_iff AddMonoidHom.ker_eq_bot_iff

/- warning: subgroup.ker_subtype -> Subgroup.ker_subtype is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)) (MonoidHom.ker.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H) G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.subtype.{u1} G _inst_1 H)) (Bot.bot.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)) (Subgroup.hasBot.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)) (MonoidHom.ker.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H) G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.subtype.{u1} G _inst_1 H)) (Bot.bot.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)) (Subgroup.instBotSubgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))
Case conversion may be inaccurate. Consider using '#align subgroup.ker_subtype Subgroup.ker_subtypeₓ'. -/
@[simp, to_additive]
theorem Subgroup.ker_subtype (H : Subgroup G) : H.Subtype.ker = ⊥ :=
  H.Subtype.ker_eq_bot_iff.mpr Subtype.coe_injective
#align subgroup.ker_subtype Subgroup.ker_subtype
#align add_subgroup.ker_subtype AddSubgroup.ker_subtype

/- warning: subgroup.ker_inclusion -> Subgroup.ker_inclusion is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1} (h : LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H K), Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)) (MonoidHom.ker.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K)))) (Subgroup.inclusion.{u1} G _inst_1 H K h)) (Bot.bot.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)) (Subgroup.hasBot.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1} (h : LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) H K), Eq.{succ u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)) (MonoidHom.ker.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 K)) (Subgroup.inclusion.{u1} G _inst_1 H K h)) (Bot.bot.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)) (Subgroup.instBotSubgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))
Case conversion may be inaccurate. Consider using '#align subgroup.ker_inclusion Subgroup.ker_inclusionₓ'. -/
@[simp, to_additive]
theorem Subgroup.ker_inclusion {H K : Subgroup G} (h : H ≤ K) : (inclusion h).ker = ⊥ :=
  (inclusion h).ker_eq_bot_iff.mpr (Set.inclusion_injective h)
#align subgroup.ker_inclusion Subgroup.ker_inclusion
#align add_subgroup.ker_inclusion AddSubgroup.ker_inclusion

/- warning: monoid_hom.prod_map_comap_prod -> MonoidHom.prodMap_comap_prod is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {G' : Type.{u3}} {N' : Type.{u4}} [_inst_7 : Group.{u3} G'] [_inst_8 : Group.{u4} N'] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (g : MonoidHom.{u3, u4} G' N' (Monoid.toMulOneClass.{u3} G' (DivInvMonoid.toMonoid.{u3} G' (Group.toDivInvMonoid.{u3} G' _inst_7))) (Monoid.toMulOneClass.{u4} N' (DivInvMonoid.toMonoid.{u4} N' (Group.toDivInvMonoid.{u4} N' _inst_8)))) (S : Subgroup.{u2} N _inst_4) (S' : Subgroup.{u4} N' _inst_8), Eq.{succ (max u1 u3)} (Subgroup.{max u1 u3} (Prod.{u1, u3} G G') (Prod.group.{u1, u3} G G' _inst_1 _inst_7)) (Subgroup.comap.{max u1 u3, max u2 u4} (Prod.{u1, u3} G G') (Prod.group.{u1, u3} G G' _inst_1 _inst_7) (Prod.{u2, u4} N N') (Prod.group.{u2, u4} N N' _inst_4 _inst_8) (MonoidHom.prodMap.{u1, u3, u2, u4} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u3} G' (DivInvMonoid.toMonoid.{u3} G' (Group.toDivInvMonoid.{u3} G' _inst_7))) N N' (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u4} N' (DivInvMonoid.toMonoid.{u4} N' (Group.toDivInvMonoid.{u4} N' _inst_8))) f g) (Subgroup.prod.{u2, u4} N _inst_4 N' _inst_8 S S')) (Subgroup.prod.{u1, u3} G _inst_1 G' _inst_7 (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f S) (Subgroup.comap.{u3, u4} G' _inst_7 N' _inst_8 g S'))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {G' : Type.{u4}} {N' : Type.{u3}} [_inst_7 : Group.{u4} G'] [_inst_8 : Group.{u3} N'] (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (g : MonoidHom.{u4, u3} G' N' (Monoid.toMulOneClass.{u4} G' (DivInvMonoid.toMonoid.{u4} G' (Group.toDivInvMonoid.{u4} G' _inst_7))) (Monoid.toMulOneClass.{u3} N' (DivInvMonoid.toMonoid.{u3} N' (Group.toDivInvMonoid.{u3} N' _inst_8)))) (S : Subgroup.{u1} N _inst_4) (S' : Subgroup.{u3} N' _inst_8), Eq.{max (succ u2) (succ u4)} (Subgroup.{max u2 u4} (Prod.{u2, u4} G G') (Prod.instGroupProd.{u2, u4} G G' _inst_1 _inst_7)) (Subgroup.comap.{max u2 u4, max u1 u3} (Prod.{u2, u4} G G') (Prod.instGroupProd.{u2, u4} G G' _inst_1 _inst_7) (Prod.{u1, u3} N N') (Prod.instGroupProd.{u1, u3} N N' _inst_4 _inst_8) (MonoidHom.prodMap.{u2, u4, u1, u3} G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u4} G' (DivInvMonoid.toMonoid.{u4} G' (Group.toDivInvMonoid.{u4} G' _inst_7))) N N' (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u3} N' (DivInvMonoid.toMonoid.{u3} N' (Group.toDivInvMonoid.{u3} N' _inst_8))) f g) (Subgroup.prod.{u1, u3} N _inst_4 N' _inst_8 S S')) (Subgroup.prod.{u2, u4} G _inst_1 G' _inst_7 (Subgroup.comap.{u2, u1} G _inst_1 N _inst_4 f S) (Subgroup.comap.{u4, u3} G' _inst_7 N' _inst_8 g S'))
Case conversion may be inaccurate. Consider using '#align monoid_hom.prod_map_comap_prod MonoidHom.prodMap_comap_prodₓ'. -/
@[to_additive]
theorem prodMap_comap_prod {G' : Type _} {N' : Type _} [Group G'] [Group N'] (f : G →* N)
    (g : G' →* N') (S : Subgroup N) (S' : Subgroup N') :
    (S.Prod S').comap (prodMap f g) = (S.comap f).Prod (S'.comap g) :=
  SetLike.coe_injective <| Set.preimage_prod_map_prod f g _ _
#align monoid_hom.prod_map_comap_prod MonoidHom.prodMap_comap_prod
#align add_monoid_hom.sum_map_comap_sum AddMonoidHom.sumMap_comap_sum

/- warning: monoid_hom.ker_prod_map -> MonoidHom.ker_prodMap is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {G' : Type.{u3}} {N' : Type.{u4}} [_inst_7 : Group.{u3} G'] [_inst_8 : Group.{u4} N'] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (g : MonoidHom.{u3, u4} G' N' (Monoid.toMulOneClass.{u3} G' (DivInvMonoid.toMonoid.{u3} G' (Group.toDivInvMonoid.{u3} G' _inst_7))) (Monoid.toMulOneClass.{u4} N' (DivInvMonoid.toMonoid.{u4} N' (Group.toDivInvMonoid.{u4} N' _inst_8)))), Eq.{succ (max u1 u3)} (Subgroup.{max u1 u3} (Prod.{u1, u3} G G') (Prod.group.{u1, u3} G G' _inst_1 _inst_7)) (MonoidHom.ker.{max u1 u3, max u2 u4} (Prod.{u1, u3} G G') (Prod.group.{u1, u3} G G' _inst_1 _inst_7) (Prod.{u2, u4} N N') (Prod.mulOneClass.{u2, u4} N N' (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u4} N' (DivInvMonoid.toMonoid.{u4} N' (Group.toDivInvMonoid.{u4} N' _inst_8)))) (MonoidHom.prodMap.{u1, u3, u2, u4} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u3} G' (DivInvMonoid.toMonoid.{u3} G' (Group.toDivInvMonoid.{u3} G' _inst_7))) N N' (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u4} N' (DivInvMonoid.toMonoid.{u4} N' (Group.toDivInvMonoid.{u4} N' _inst_8))) f g)) (Subgroup.prod.{u1, u3} G _inst_1 G' _inst_7 (MonoidHom.ker.{u1, u2} G _inst_1 N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) f) (MonoidHom.ker.{u3, u4} G' _inst_7 N' (Monoid.toMulOneClass.{u4} N' (DivInvMonoid.toMonoid.{u4} N' (Group.toDivInvMonoid.{u4} N' _inst_8))) g))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {G' : Type.{u4}} {N' : Type.{u3}} [_inst_7 : Group.{u4} G'] [_inst_8 : Group.{u3} N'] (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (g : MonoidHom.{u4, u3} G' N' (Monoid.toMulOneClass.{u4} G' (DivInvMonoid.toMonoid.{u4} G' (Group.toDivInvMonoid.{u4} G' _inst_7))) (Monoid.toMulOneClass.{u3} N' (DivInvMonoid.toMonoid.{u3} N' (Group.toDivInvMonoid.{u3} N' _inst_8)))), Eq.{max (succ u2) (succ u4)} (Subgroup.{max u2 u4} (Prod.{u2, u4} G G') (Prod.instGroupProd.{u2, u4} G G' _inst_1 _inst_7)) (MonoidHom.ker.{max u2 u4, max u1 u3} (Prod.{u2, u4} G G') (Prod.instGroupProd.{u2, u4} G G' _inst_1 _inst_7) (Prod.{u1, u3} N N') (Prod.instMulOneClassProd.{u1, u3} N N' (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u3} N' (DivInvMonoid.toMonoid.{u3} N' (Group.toDivInvMonoid.{u3} N' _inst_8)))) (MonoidHom.prodMap.{u2, u4, u1, u3} G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u4} G' (DivInvMonoid.toMonoid.{u4} G' (Group.toDivInvMonoid.{u4} G' _inst_7))) N N' (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u3} N' (DivInvMonoid.toMonoid.{u3} N' (Group.toDivInvMonoid.{u3} N' _inst_8))) f g)) (Subgroup.prod.{u2, u4} G _inst_1 G' _inst_7 (MonoidHom.ker.{u2, u1} G _inst_1 N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) f) (MonoidHom.ker.{u4, u3} G' _inst_7 N' (Monoid.toMulOneClass.{u3} N' (DivInvMonoid.toMonoid.{u3} N' (Group.toDivInvMonoid.{u3} N' _inst_8))) g))
Case conversion may be inaccurate. Consider using '#align monoid_hom.ker_prod_map MonoidHom.ker_prodMapₓ'. -/
@[to_additive]
theorem ker_prodMap {G' : Type _} {N' : Type _} [Group G'] [Group N'] (f : G →* N) (g : G' →* N') :
    (prodMap f g).ker = f.ker.Prod g.ker := by
  rw [← comap_bot, ← comap_bot, ← comap_bot, ← prod_map_comap_prod, bot_prod_bot]
#align monoid_hom.ker_prod_map MonoidHom.ker_prodMap
#align add_monoid_hom.ker_sum_map AddMonoidHom.ker_sumMap

#print MonoidHom.normal_ker /-
@[to_additive]
instance (priority := 100) normal_ker (f : G →* M) : f.ker.Normal :=
  ⟨fun x hx y => by
    rw [mem_ker, map_mul, map_mul, f.mem_ker.1 hx, mul_one, map_mul_eq_one f (mul_inv_self y)]⟩
#align monoid_hom.normal_ker MonoidHom.normal_ker
#align add_monoid_hom.normal_ker AddMonoidHom.normal_ker
-/

end Ker

section EqLocus

variable {M : Type _} [Monoid M]

#print MonoidHom.eqLocus /-
/-- The subgroup of elements `x : G` such that `f x = g x` -/
@[to_additive "The additive subgroup of elements `x : G` such that `f x = g x`"]
def eqLocus (f g : G →* M) : Subgroup G :=
  { eqLocusM f g with inv_mem' := fun x => eq_on_inv f g }
#align monoid_hom.eq_locus MonoidHom.eqLocus
#align add_monoid_hom.eq_locus AddMonoidHom.eqLocus
-/

/- warning: monoid_hom.eq_locus_same -> MonoidHom.eqLocus_same is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (MonoidHom.eqLocus.{u1, u2} G _inst_1 N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)) f f) (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasTop.{u1} G _inst_1))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))), Eq.{succ u2} (Subgroup.{u2} G _inst_1) (MonoidHom.eqLocus.{u2, u1} G _inst_1 N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)) f f) (Top.top.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instTopSubgroup.{u2} G _inst_1))
Case conversion may be inaccurate. Consider using '#align monoid_hom.eq_locus_same MonoidHom.eqLocus_sameₓ'. -/
@[simp, to_additive]
theorem eqLocus_same (f : G →* N) : f.eqLocus f = ⊤ :=
  SetLike.ext fun _ => eq_self_iff_true _
#align monoid_hom.eq_locus_same MonoidHom.eqLocus_same
#align add_monoid_hom.eq_locus_same AddMonoidHom.eqLocus_same

/- warning: monoid_hom.eq_on_closure -> MonoidHom.eqOn_closure is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {M : Type.{u2}} [_inst_6 : Monoid.{u2} M] {f : MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)} {g : MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)} {s : Set.{u1} G}, (Set.EqOn.{u1, u2} G M (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)) (fun (_x : MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)) => G -> M) (MonoidHom.hasCoeToFun.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)) f) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)) (fun (_x : MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)) => G -> M) (MonoidHom.hasCoeToFun.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)) g) s) -> (Set.EqOn.{u1, u2} G M (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)) (fun (_x : MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)) => G -> M) (MonoidHom.hasCoeToFun.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)) f) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)) (fun (_x : MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)) => G -> M) (MonoidHom.hasCoeToFun.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)) g) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.closure.{u1} G _inst_1 s)))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {M : Type.{u1}} [_inst_6 : Monoid.{u1} M] {f : MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)} {g : MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)} {s : Set.{u2} G}, (Set.EqOn.{u2, u1} G M (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => M) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)) G M (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_6)) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)) G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6) (MonoidHom.monoidHomClass.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)))) f) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => M) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)) G M (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_6)) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)) G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6) (MonoidHom.monoidHomClass.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)))) g) s) -> (Set.EqOn.{u2, u1} G M (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => M) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)) G M (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_6)) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)) G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6) (MonoidHom.monoidHomClass.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)))) f) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => M) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)) G M (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_6)) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)) G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6) (MonoidHom.monoidHomClass.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)))) g) (SetLike.coe.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1) (Subgroup.closure.{u2} G _inst_1 s)))
Case conversion may be inaccurate. Consider using '#align monoid_hom.eq_on_closure MonoidHom.eqOn_closureₓ'. -/
/-- If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. -/
@[to_additive
      "If two monoid homomorphisms are equal on a set, then they are equal on its subgroup\nclosure."]
theorem eqOn_closure {f g : G →* M} {s : Set G} (h : Set.EqOn f g s) : Set.EqOn f g (closure s) :=
  show closure s ≤ f.eqLocus g from (closure_le _).2 h
#align monoid_hom.eq_on_closure MonoidHom.eqOn_closure
#align add_monoid_hom.eq_on_closure AddMonoidHom.eqOn_closure

/- warning: monoid_hom.eq_of_eq_on_top -> MonoidHom.eq_of_eqOn_top is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {M : Type.{u2}} [_inst_6 : Monoid.{u2} M] {f : MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)} {g : MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)}, (Set.EqOn.{u1, u2} G M (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)) (fun (_x : MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)) => G -> M) (MonoidHom.hasCoeToFun.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)) f) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)) (fun (_x : MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)) => G -> M) (MonoidHom.hasCoeToFun.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)) g) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasTop.{u1} G _inst_1)))) -> (Eq.{max (succ u2) (succ u1)} (MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)) f g)
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {M : Type.{u1}} [_inst_6 : Monoid.{u1} M] {f : MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)} {g : MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)}, (Set.EqOn.{u2, u1} G M (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => M) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)) G M (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_6)) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)) G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6) (MonoidHom.monoidHomClass.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)))) f) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => M) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)) G M (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_6)) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)) G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6) (MonoidHom.monoidHomClass.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)))) g) (SetLike.coe.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1) (Top.top.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instTopSubgroup.{u2} G _inst_1)))) -> (Eq.{max (succ u2) (succ u1)} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)) f g)
Case conversion may be inaccurate. Consider using '#align monoid_hom.eq_of_eq_on_top MonoidHom.eq_of_eqOn_topₓ'. -/
@[to_additive]
theorem eq_of_eqOn_top {f g : G →* M} (h : Set.EqOn f g (⊤ : Subgroup G)) : f = g :=
  ext fun x => h trivial
#align monoid_hom.eq_of_eq_on_top MonoidHom.eq_of_eqOn_top
#align add_monoid_hom.eq_of_eq_on_top AddMonoidHom.eq_of_eqOn_top

/- warning: monoid_hom.eq_of_eq_on_dense -> MonoidHom.eq_of_eqOn_dense is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {M : Type.{u2}} [_inst_6 : Monoid.{u2} M] {s : Set.{u1} G}, (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.closure.{u1} G _inst_1 s) (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasTop.{u1} G _inst_1))) -> (forall {f : MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)} {g : MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)}, (Set.EqOn.{u1, u2} G M (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)) (fun (_x : MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)) => G -> M) (MonoidHom.hasCoeToFun.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)) f) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)) (fun (_x : MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)) => G -> M) (MonoidHom.hasCoeToFun.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)) g) s) -> (Eq.{max (succ u2) (succ u1)} (MonoidHom.{u1, u2} G M (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} M _inst_6)) f g))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {M : Type.{u1}} [_inst_6 : Monoid.{u1} M] {s : Set.{u2} G}, (Eq.{succ u2} (Subgroup.{u2} G _inst_1) (Subgroup.closure.{u2} G _inst_1 s) (Top.top.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instTopSubgroup.{u2} G _inst_1))) -> (forall {f : MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)} {g : MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)}, (Set.EqOn.{u2, u1} G M (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => M) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)) G M (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_6)) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)) G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6) (MonoidHom.monoidHomClass.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)))) f) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => M) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)) G M (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_6)) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)) G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6) (MonoidHom.monoidHomClass.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)))) g) s) -> (Eq.{max (succ u2) (succ u1)} (MonoidHom.{u2, u1} G M (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} M _inst_6)) f g))
Case conversion may be inaccurate. Consider using '#align monoid_hom.eq_of_eq_on_dense MonoidHom.eq_of_eqOn_denseₓ'. -/
@[to_additive]
theorem eq_of_eqOn_dense {s : Set G} (hs : closure s = ⊤) {f g : G →* M} (h : s.EqOn f g) : f = g :=
  eq_of_eqOn_top <| hs ▸ eqOn_closure h
#align monoid_hom.eq_of_eq_on_dense MonoidHom.eq_of_eqOn_dense
#align add_monoid_hom.eq_of_eq_on_dense AddMonoidHom.eq_of_eqOn_dense

end EqLocus

/- warning: monoid_hom.closure_preimage_le -> MonoidHom.closure_preimage_le is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (s : Set.{u2} N), LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.closure.{u1} G _inst_1 (Set.preimage.{u1, u2} G N (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f) s)) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f (Subgroup.closure.{u2} N _inst_4 s))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (s : Set.{u1} N), LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))))) (Subgroup.closure.{u2} G _inst_1 (Set.preimage.{u2, u1} G N (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f) s)) (Subgroup.comap.{u2, u1} G _inst_1 N _inst_4 f (Subgroup.closure.{u1} N _inst_4 s))
Case conversion may be inaccurate. Consider using '#align monoid_hom.closure_preimage_le MonoidHom.closure_preimage_leₓ'. -/
@[to_additive]
theorem closure_preimage_le (f : G →* N) (s : Set N) : closure (f ⁻¹' s) ≤ (closure s).comap f :=
  (closure_le _).2 fun x hx => by rw [SetLike.mem_coe, mem_comap] <;> exact subset_closure hx
#align monoid_hom.closure_preimage_le MonoidHom.closure_preimage_le
#align add_monoid_hom.closure_preimage_le AddMonoidHom.closure_preimage_le

/- warning: monoid_hom.map_closure -> MonoidHom.map_closure is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (s : Set.{u1} G), Eq.{succ u2} (Subgroup.{u2} N _inst_4) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f (Subgroup.closure.{u1} G _inst_1 s)) (Subgroup.closure.{u2} N _inst_4 (Set.image.{u1, u2} G N (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f) s))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (s : Set.{u2} G), Eq.{succ u1} (Subgroup.{u1} N _inst_4) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f (Subgroup.closure.{u2} G _inst_1 s)) (Subgroup.closure.{u1} N _inst_4 (Set.image.{u2, u1} G N (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f) s))
Case conversion may be inaccurate. Consider using '#align monoid_hom.map_closure MonoidHom.map_closureₓ'. -/
/-- The image under a monoid homomorphism of the subgroup generated by a set equals the subgroup
generated by the image of the set. -/
@[to_additive
      "The image under an `add_monoid` hom of the `add_subgroup` generated by a set equals\nthe `add_subgroup` generated by the image of the set."]
theorem map_closure (f : G →* N) (s : Set G) : (closure s).map f = closure (f '' s) :=
  Set.image_preimage.l_comm_of_u_comm (Subgroup.gc_map_comap f) (Subgroup.gi N).gc
    (Subgroup.gi G).gc fun t => rfl
#align monoid_hom.map_closure MonoidHom.map_closure
#align add_monoid_hom.map_closure AddMonoidHom.map_closure

end MonoidHom

namespace Subgroup

variable {N : Type _} [Group N] (H : Subgroup G)

/- warning: subgroup.normal.map -> Subgroup.Normal.map is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {H : Subgroup.{u1} G _inst_1}, (Subgroup.Normal.{u1} G _inst_1 H) -> (forall (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), (Function.Surjective.{succ u1, succ u2} G N (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f)) -> (Subgroup.Normal.{u2} N _inst_4 (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H)))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {H : Subgroup.{u2} G _inst_1}, (Subgroup.Normal.{u2} G _inst_1 H) -> (forall (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))), (Function.Surjective.{succ u2, succ u1} G N (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f)) -> (Subgroup.Normal.{u1} N _inst_4 (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H)))
Case conversion may be inaccurate. Consider using '#align subgroup.normal.map Subgroup.Normal.mapₓ'. -/
@[to_additive]
theorem Normal.map {H : Subgroup G} (h : H.Normal) (f : G →* N) (hf : Function.Surjective f) :
    (H.map f).Normal :=
  by
  rw [← normalizer_eq_top, ← top_le_iff, ← f.range_top_of_surjective hf, f.range_eq_map, ←
    normalizer_eq_top.2 h]
  exact le_normalizer_map _
#align subgroup.normal.map Subgroup.Normal.map
#align add_subgroup.normal.map AddSubgroup.Normal.map

/- warning: subgroup.map_eq_bot_iff -> Subgroup.map_eq_bot_iff is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (H : Subgroup.{u1} G _inst_1) {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))}, Iff (Eq.{succ u2} (Subgroup.{u2} N _inst_4) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H) (Bot.bot.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.hasBot.{u2} N _inst_4))) (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H (MonoidHom.ker.{u1, u2} G _inst_1 N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) f))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (H : Subgroup.{u2} G _inst_1) {f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))}, Iff (Eq.{succ u1} (Subgroup.{u1} N _inst_4) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H) (Bot.bot.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instBotSubgroup.{u1} N _inst_4))) (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))))) H (MonoidHom.ker.{u2, u1} G _inst_1 N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) f))
Case conversion may be inaccurate. Consider using '#align subgroup.map_eq_bot_iff Subgroup.map_eq_bot_iffₓ'. -/
@[to_additive]
theorem map_eq_bot_iff {f : G →* N} : H.map f = ⊥ ↔ H ≤ f.ker :=
  (gc_map_comap f).l_eq_bot
#align subgroup.map_eq_bot_iff Subgroup.map_eq_bot_iff
#align add_subgroup.map_eq_bot_iff AddSubgroup.map_eq_bot_iff

/- warning: subgroup.map_eq_bot_iff_of_injective -> Subgroup.map_eq_bot_iff_of_injective is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (H : Subgroup.{u1} G _inst_1) {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))}, (Function.Injective.{succ u1, succ u2} G N (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f)) -> (Iff (Eq.{succ u2} (Subgroup.{u2} N _inst_4) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H) (Bot.bot.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.hasBot.{u2} N _inst_4))) (Eq.{succ u1} (Subgroup.{u1} G _inst_1) H (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1))))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (H : Subgroup.{u2} G _inst_1) {f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))}, (Function.Injective.{succ u2, succ u1} G N (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f)) -> (Iff (Eq.{succ u1} (Subgroup.{u1} N _inst_4) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H) (Bot.bot.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instBotSubgroup.{u1} N _inst_4))) (Eq.{succ u2} (Subgroup.{u2} G _inst_1) H (Bot.bot.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instBotSubgroup.{u2} G _inst_1))))
Case conversion may be inaccurate. Consider using '#align subgroup.map_eq_bot_iff_of_injective Subgroup.map_eq_bot_iff_of_injectiveₓ'. -/
@[to_additive]
theorem map_eq_bot_iff_of_injective {f : G →* N} (hf : Function.Injective f) :
    H.map f = ⊥ ↔ H = ⊥ := by rw [map_eq_bot_iff, f.ker_eq_bot_iff.mpr hf, le_bot_iff]
#align subgroup.map_eq_bot_iff_of_injective Subgroup.map_eq_bot_iff_of_injective
#align add_subgroup.map_eq_bot_iff_of_injective AddSubgroup.map_eq_bot_iff_of_injective

end Subgroup

namespace Subgroup

open MonoidHom

variable {N : Type _} [Group N] (f : G →* N)

/- warning: subgroup.map_le_range -> Subgroup.map_le_range is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (H : Subgroup.{u1} G _inst_1), LE.le.{u2} (Subgroup.{u2} N _inst_4) (Preorder.toLE.{u2} (Subgroup.{u2} N _inst_4) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} N _inst_4) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)))) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (H : Subgroup.{u2} G _inst_1), LE.le.{u1} (Subgroup.{u1} N _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} N _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} N _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} N _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u1} N _inst_4))))) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H) (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)
Case conversion may be inaccurate. Consider using '#align subgroup.map_le_range Subgroup.map_le_rangeₓ'. -/
@[to_additive]
theorem map_le_range (H : Subgroup G) : map f H ≤ f.range :=
  (range_eq_map f).symm ▸ map_mono le_top
#align subgroup.map_le_range Subgroup.map_le_range
#align add_subgroup.map_le_range AddSubgroup.map_le_range

/- warning: subgroup.map_subtype_le -> Subgroup.map_subtype_le is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} (K : Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)), LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.map.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H) G _inst_1 (Subgroup.subtype.{u1} G _inst_1 H) K) H
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} (K : Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)), LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (Subgroup.map.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H) G _inst_1 (Subgroup.subtype.{u1} G _inst_1 H) K) H
Case conversion may be inaccurate. Consider using '#align subgroup.map_subtype_le Subgroup.map_subtype_leₓ'. -/
@[to_additive]
theorem map_subtype_le {H : Subgroup G} (K : Subgroup H) : K.map H.Subtype ≤ H :=
  (K.map_le_range H.Subtype).trans (le_of_eq H.subtype_range)
#align subgroup.map_subtype_le Subgroup.map_subtype_le
#align add_subgroup.map_subtype_le AddSubgroup.map_subtype_le

/- warning: subgroup.ker_le_comap -> Subgroup.ker_le_comap is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (H : Subgroup.{u2} N _inst_4), LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (MonoidHom.ker.{u1, u2} G _inst_1 N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) f) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (H : Subgroup.{u2} N _inst_4), LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (MonoidHom.ker.{u1, u2} G _inst_1 N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) f) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f H)
Case conversion may be inaccurate. Consider using '#align subgroup.ker_le_comap Subgroup.ker_le_comapₓ'. -/
@[to_additive]
theorem ker_le_comap (H : Subgroup N) : f.ker ≤ comap f H :=
  comap_bot f ▸ comap_mono bot_le
#align subgroup.ker_le_comap Subgroup.ker_le_comap
#align add_subgroup.ker_le_comap AddSubgroup.ker_le_comap

/- warning: subgroup.map_comap_le -> Subgroup.map_comap_le is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (H : Subgroup.{u2} N _inst_4), LE.le.{u2} (Subgroup.{u2} N _inst_4) (Preorder.toLE.{u2} (Subgroup.{u2} N _inst_4) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} N _inst_4) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)))) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f H)) H
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (H : Subgroup.{u2} N _inst_4), LE.le.{u2} (Subgroup.{u2} N _inst_4) (Preorder.toLE.{u2} (Subgroup.{u2} N _inst_4) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} N _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} N _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u2} N _inst_4))))) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f H)) H
Case conversion may be inaccurate. Consider using '#align subgroup.map_comap_le Subgroup.map_comap_leₓ'. -/
@[to_additive]
theorem map_comap_le (H : Subgroup N) : map f (comap f H) ≤ H :=
  (gc_map_comap f).l_u_le _
#align subgroup.map_comap_le Subgroup.map_comap_le
#align add_subgroup.map_comap_le AddSubgroup.map_comap_le

/- warning: subgroup.le_comap_map -> Subgroup.le_comap_map is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (H : Subgroup.{u1} G _inst_1), LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (H : Subgroup.{u2} G _inst_1), LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))))) H (Subgroup.comap.{u2, u1} G _inst_1 N _inst_4 f (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H))
Case conversion may be inaccurate. Consider using '#align subgroup.le_comap_map Subgroup.le_comap_mapₓ'. -/
@[to_additive]
theorem le_comap_map (H : Subgroup G) : H ≤ comap f (map f H) :=
  (gc_map_comap f).le_u_l _
#align subgroup.le_comap_map Subgroup.le_comap_map
#align add_subgroup.le_comap_map AddSubgroup.le_comap_map

/- warning: subgroup.map_comap_eq -> Subgroup.map_comap_eq is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (H : Subgroup.{u2} N _inst_4), Eq.{succ u2} (Subgroup.{u2} N _inst_4) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f H)) (Inf.inf.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.hasInf.{u2} N _inst_4) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f) H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (H : Subgroup.{u2} N _inst_4), Eq.{succ u2} (Subgroup.{u2} N _inst_4) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f H)) (Inf.inf.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.instInfSubgroup.{u2} N _inst_4) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f) H)
Case conversion may be inaccurate. Consider using '#align subgroup.map_comap_eq Subgroup.map_comap_eqₓ'. -/
@[to_additive]
theorem map_comap_eq (H : Subgroup N) : map f (comap f H) = f.range ⊓ H :=
  SetLike.ext' <| by
    rw [coe_map, coe_comap, Set.image_preimage_eq_inter_range, coe_inf, coe_range, Set.inter_comm]
#align subgroup.map_comap_eq Subgroup.map_comap_eq
#align add_subgroup.map_comap_eq AddSubgroup.map_comap_eq

/- warning: subgroup.comap_map_eq -> Subgroup.comap_map_eq is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (H : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H)) (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) H (MonoidHom.ker.{u1, u2} G _inst_1 N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) f))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (H : Subgroup.{u2} G _inst_1), Eq.{succ u2} (Subgroup.{u2} G _inst_1) (Subgroup.comap.{u2, u1} G _inst_1 N _inst_4 f (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H)) (Sup.sup.{u2} (Subgroup.{u2} G _inst_1) (SemilatticeSup.toSup.{u2} (Subgroup.{u2} G _inst_1) (Lattice.toSemilatticeSup.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toLattice.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1)))) H (MonoidHom.ker.{u2, u1} G _inst_1 N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) f))
Case conversion may be inaccurate. Consider using '#align subgroup.comap_map_eq Subgroup.comap_map_eqₓ'. -/
@[to_additive]
theorem comap_map_eq (H : Subgroup G) : comap f (map f H) = H ⊔ f.ker :=
  by
  refine' le_antisymm _ (sup_le (le_comap_map _ _) (ker_le_comap _ _))
  intro x hx; simp only [exists_prop, mem_map, mem_comap] at hx
  rcases hx with ⟨y, hy, hy'⟩
  rw [← mul_inv_cancel_left y x]
  exact mul_mem_sup hy (by simp [mem_ker, hy'])
#align subgroup.comap_map_eq Subgroup.comap_map_eq
#align add_subgroup.comap_map_eq AddSubgroup.comap_map_eq

/- warning: subgroup.map_comap_eq_self -> Subgroup.map_comap_eq_self is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))} {H : Subgroup.{u2} N _inst_4}, (LE.le.{u2} (Subgroup.{u2} N _inst_4) (Preorder.toLE.{u2} (Subgroup.{u2} N _inst_4) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} N _inst_4) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)))) H (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) -> (Eq.{succ u2} (Subgroup.{u2} N _inst_4) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f H)) H)
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))} {H : Subgroup.{u1} N _inst_4}, (LE.le.{u1} (Subgroup.{u1} N _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} N _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} N _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} N _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u1} N _inst_4))))) H (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)) -> (Eq.{succ u1} (Subgroup.{u1} N _inst_4) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f (Subgroup.comap.{u2, u1} G _inst_1 N _inst_4 f H)) H)
Case conversion may be inaccurate. Consider using '#align subgroup.map_comap_eq_self Subgroup.map_comap_eq_selfₓ'. -/
@[to_additive]
theorem map_comap_eq_self {f : G →* N} {H : Subgroup N} (h : H ≤ f.range) : map f (comap f H) = H :=
  by rwa [map_comap_eq, inf_eq_right]
#align subgroup.map_comap_eq_self Subgroup.map_comap_eq_self
#align add_subgroup.map_comap_eq_self AddSubgroup.map_comap_eq_self

/- warning: subgroup.map_comap_eq_self_of_surjective -> Subgroup.map_comap_eq_self_of_surjective is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))}, (Function.Surjective.{succ u1, succ u2} G N (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f)) -> (forall (H : Subgroup.{u2} N _inst_4), Eq.{succ u2} (Subgroup.{u2} N _inst_4) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f H)) H)
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))}, (Function.Surjective.{succ u2, succ u1} G N (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f)) -> (forall (H : Subgroup.{u1} N _inst_4), Eq.{succ u1} (Subgroup.{u1} N _inst_4) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f (Subgroup.comap.{u2, u1} G _inst_1 N _inst_4 f H)) H)
Case conversion may be inaccurate. Consider using '#align subgroup.map_comap_eq_self_of_surjective Subgroup.map_comap_eq_self_of_surjectiveₓ'. -/
@[to_additive]
theorem map_comap_eq_self_of_surjective {f : G →* N} (h : Function.Surjective f) (H : Subgroup N) :
    map f (comap f H) = H :=
  map_comap_eq_self ((range_top_of_surjective _ h).symm ▸ le_top)
#align subgroup.map_comap_eq_self_of_surjective Subgroup.map_comap_eq_self_of_surjective
#align add_subgroup.map_comap_eq_self_of_surjective AddSubgroup.map_comap_eq_self_of_surjective

/- warning: subgroup.comap_le_comap_of_le_range -> Subgroup.comap_le_comap_of_le_range is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))} {K : Subgroup.{u2} N _inst_4} {L : Subgroup.{u2} N _inst_4}, (LE.le.{u2} (Subgroup.{u2} N _inst_4) (Preorder.toLE.{u2} (Subgroup.{u2} N _inst_4) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} N _inst_4) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)))) K (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) -> (Iff (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f K) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f L)) (LE.le.{u2} (Subgroup.{u2} N _inst_4) (Preorder.toLE.{u2} (Subgroup.{u2} N _inst_4) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} N _inst_4) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)))) K L))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))} {K : Subgroup.{u1} N _inst_4} {L : Subgroup.{u1} N _inst_4}, (LE.le.{u1} (Subgroup.{u1} N _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} N _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} N _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} N _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u1} N _inst_4))))) K (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)) -> (Iff (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))))) (Subgroup.comap.{u2, u1} G _inst_1 N _inst_4 f K) (Subgroup.comap.{u2, u1} G _inst_1 N _inst_4 f L)) (LE.le.{u1} (Subgroup.{u1} N _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} N _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} N _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} N _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u1} N _inst_4))))) K L))
Case conversion may be inaccurate. Consider using '#align subgroup.comap_le_comap_of_le_range Subgroup.comap_le_comap_of_le_rangeₓ'. -/
@[to_additive]
theorem comap_le_comap_of_le_range {f : G →* N} {K L : Subgroup N} (hf : K ≤ f.range) :
    K.comap f ≤ L.comap f ↔ K ≤ L :=
  ⟨(map_comap_eq_self hf).ge.trans ∘ map_le_iff_le_comap.mpr, comap_mono⟩
#align subgroup.comap_le_comap_of_le_range Subgroup.comap_le_comap_of_le_range
#align add_subgroup.comap_le_comap_of_le_range AddSubgroup.comap_le_comap_of_le_range

/- warning: subgroup.comap_le_comap_of_surjective -> Subgroup.comap_le_comap_of_surjective is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))} {K : Subgroup.{u2} N _inst_4} {L : Subgroup.{u2} N _inst_4}, (Function.Surjective.{succ u1, succ u2} G N (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f)) -> (Iff (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f K) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f L)) (LE.le.{u2} (Subgroup.{u2} N _inst_4) (Preorder.toLE.{u2} (Subgroup.{u2} N _inst_4) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} N _inst_4) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)))) K L))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))} {K : Subgroup.{u1} N _inst_4} {L : Subgroup.{u1} N _inst_4}, (Function.Surjective.{succ u2, succ u1} G N (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f)) -> (Iff (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))))) (Subgroup.comap.{u2, u1} G _inst_1 N _inst_4 f K) (Subgroup.comap.{u2, u1} G _inst_1 N _inst_4 f L)) (LE.le.{u1} (Subgroup.{u1} N _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} N _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} N _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} N _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u1} N _inst_4))))) K L))
Case conversion may be inaccurate. Consider using '#align subgroup.comap_le_comap_of_surjective Subgroup.comap_le_comap_of_surjectiveₓ'. -/
@[to_additive]
theorem comap_le_comap_of_surjective {f : G →* N} {K L : Subgroup N} (hf : Function.Surjective f) :
    K.comap f ≤ L.comap f ↔ K ≤ L :=
  comap_le_comap_of_le_range (le_top.trans (f.range_top_of_surjective hf).ge)
#align subgroup.comap_le_comap_of_surjective Subgroup.comap_le_comap_of_surjective
#align add_subgroup.comap_le_comap_of_surjective AddSubgroup.comap_le_comap_of_surjective

/- warning: subgroup.comap_lt_comap_of_surjective -> Subgroup.comap_lt_comap_of_surjective is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))} {K : Subgroup.{u2} N _inst_4} {L : Subgroup.{u2} N _inst_4}, (Function.Surjective.{succ u1, succ u2} G N (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f)) -> (Iff (LT.lt.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLT.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f K) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f L)) (LT.lt.{u2} (Subgroup.{u2} N _inst_4) (Preorder.toLT.{u2} (Subgroup.{u2} N _inst_4) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} N _inst_4) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)))) K L))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))} {K : Subgroup.{u1} N _inst_4} {L : Subgroup.{u1} N _inst_4}, (Function.Surjective.{succ u2, succ u1} G N (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f)) -> (Iff (LT.lt.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLT.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))))) (Subgroup.comap.{u2, u1} G _inst_1 N _inst_4 f K) (Subgroup.comap.{u2, u1} G _inst_1 N _inst_4 f L)) (LT.lt.{u1} (Subgroup.{u1} N _inst_4) (Preorder.toLT.{u1} (Subgroup.{u1} N _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} N _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} N _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u1} N _inst_4))))) K L))
Case conversion may be inaccurate. Consider using '#align subgroup.comap_lt_comap_of_surjective Subgroup.comap_lt_comap_of_surjectiveₓ'. -/
@[to_additive]
theorem comap_lt_comap_of_surjective {f : G →* N} {K L : Subgroup N} (hf : Function.Surjective f) :
    K.comap f < L.comap f ↔ K < L := by simp_rw [lt_iff_le_not_le, comap_le_comap_of_surjective hf]
#align subgroup.comap_lt_comap_of_surjective Subgroup.comap_lt_comap_of_surjective
#align add_subgroup.comap_lt_comap_of_surjective AddSubgroup.comap_lt_comap_of_surjective

/- warning: subgroup.comap_injective -> Subgroup.comap_injective is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))}, (Function.Surjective.{succ u1, succ u2} G N (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f)) -> (Function.Injective.{succ u2, succ u1} (Subgroup.{u2} N _inst_4) (Subgroup.{u1} G _inst_1) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))}, (Function.Surjective.{succ u2, succ u1} G N (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f)) -> (Function.Injective.{succ u1, succ u2} (Subgroup.{u1} N _inst_4) (Subgroup.{u2} G _inst_1) (Subgroup.comap.{u2, u1} G _inst_1 N _inst_4 f))
Case conversion may be inaccurate. Consider using '#align subgroup.comap_injective Subgroup.comap_injectiveₓ'. -/
@[to_additive]
theorem comap_injective {f : G →* N} (h : Function.Surjective f) : Function.Injective (comap f) :=
  fun K L => by simp only [le_antisymm_iff, comap_le_comap_of_surjective h, imp_self]
#align subgroup.comap_injective Subgroup.comap_injective
#align add_subgroup.comap_injective AddSubgroup.comap_injective

/- warning: subgroup.comap_map_eq_self -> Subgroup.comap_map_eq_self is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))} {H : Subgroup.{u1} G _inst_1}, (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (MonoidHom.ker.{u1, u2} G _inst_1 N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) f) H) -> (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H)) H)
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))} {H : Subgroup.{u2} G _inst_1}, (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))))) (MonoidHom.ker.{u2, u1} G _inst_1 N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) f) H) -> (Eq.{succ u2} (Subgroup.{u2} G _inst_1) (Subgroup.comap.{u2, u1} G _inst_1 N _inst_4 f (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H)) H)
Case conversion may be inaccurate. Consider using '#align subgroup.comap_map_eq_self Subgroup.comap_map_eq_selfₓ'. -/
@[to_additive]
theorem comap_map_eq_self {f : G →* N} {H : Subgroup G} (h : f.ker ≤ H) : comap f (map f H) = H :=
  by rwa [comap_map_eq, sup_eq_left]
#align subgroup.comap_map_eq_self Subgroup.comap_map_eq_self
#align add_subgroup.comap_map_eq_self AddSubgroup.comap_map_eq_self

/- warning: subgroup.comap_map_eq_self_of_injective -> Subgroup.comap_map_eq_self_of_injective is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))}, (Function.Injective.{succ u1, succ u2} G N (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f)) -> (forall (H : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H)) H)
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))}, (Function.Injective.{succ u2, succ u1} G N (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f)) -> (forall (H : Subgroup.{u2} G _inst_1), Eq.{succ u2} (Subgroup.{u2} G _inst_1) (Subgroup.comap.{u2, u1} G _inst_1 N _inst_4 f (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H)) H)
Case conversion may be inaccurate. Consider using '#align subgroup.comap_map_eq_self_of_injective Subgroup.comap_map_eq_self_of_injectiveₓ'. -/
@[to_additive]
theorem comap_map_eq_self_of_injective {f : G →* N} (h : Function.Injective f) (H : Subgroup G) :
    comap f (map f H) = H :=
  comap_map_eq_self (((ker_eq_bot_iff _).mpr h).symm ▸ bot_le)
#align subgroup.comap_map_eq_self_of_injective Subgroup.comap_map_eq_self_of_injective
#align add_subgroup.comap_map_eq_self_of_injective AddSubgroup.comap_map_eq_self_of_injective

/- warning: subgroup.map_le_map_iff -> Subgroup.map_le_map_iff is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))} {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1}, Iff (LE.le.{u2} (Subgroup.{u2} N _inst_4) (Preorder.toLE.{u2} (Subgroup.{u2} N _inst_4) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} N _inst_4) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)))) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f K)) (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) K (MonoidHom.ker.{u1, u2} G _inst_1 N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) f)))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))} {H : Subgroup.{u2} G _inst_1} {K : Subgroup.{u2} G _inst_1}, Iff (LE.le.{u1} (Subgroup.{u1} N _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} N _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} N _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} N _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u1} N _inst_4))))) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f K)) (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))))) H (Sup.sup.{u2} (Subgroup.{u2} G _inst_1) (SemilatticeSup.toSup.{u2} (Subgroup.{u2} G _inst_1) (Lattice.toSemilatticeSup.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toLattice.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1)))) K (MonoidHom.ker.{u2, u1} G _inst_1 N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) f)))
Case conversion may be inaccurate. Consider using '#align subgroup.map_le_map_iff Subgroup.map_le_map_iffₓ'. -/
@[to_additive]
theorem map_le_map_iff {f : G →* N} {H K : Subgroup G} : H.map f ≤ K.map f ↔ H ≤ K ⊔ f.ker := by
  rw [map_le_iff_le_comap, comap_map_eq]
#align subgroup.map_le_map_iff Subgroup.map_le_map_iff
#align add_subgroup.map_le_map_iff AddSubgroup.map_le_map_iff

/- warning: subgroup.map_le_map_iff' -> Subgroup.map_le_map_iff' is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))} {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1}, Iff (LE.le.{u2} (Subgroup.{u2} N _inst_4) (Preorder.toLE.{u2} (Subgroup.{u2} N _inst_4) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} N _inst_4) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)))) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f K)) (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) H (MonoidHom.ker.{u1, u2} G _inst_1 N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) f)) (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) K (MonoidHom.ker.{u1, u2} G _inst_1 N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) f)))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))} {H : Subgroup.{u2} G _inst_1} {K : Subgroup.{u2} G _inst_1}, Iff (LE.le.{u1} (Subgroup.{u1} N _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} N _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} N _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} N _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u1} N _inst_4))))) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f K)) (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))))) (Sup.sup.{u2} (Subgroup.{u2} G _inst_1) (SemilatticeSup.toSup.{u2} (Subgroup.{u2} G _inst_1) (Lattice.toSemilatticeSup.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toLattice.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1)))) H (MonoidHom.ker.{u2, u1} G _inst_1 N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) f)) (Sup.sup.{u2} (Subgroup.{u2} G _inst_1) (SemilatticeSup.toSup.{u2} (Subgroup.{u2} G _inst_1) (Lattice.toSemilatticeSup.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toLattice.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1)))) K (MonoidHom.ker.{u2, u1} G _inst_1 N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) f)))
Case conversion may be inaccurate. Consider using '#align subgroup.map_le_map_iff' Subgroup.map_le_map_iff'ₓ'. -/
@[to_additive]
theorem map_le_map_iff' {f : G →* N} {H K : Subgroup G} :
    H.map f ≤ K.map f ↔ H ⊔ f.ker ≤ K ⊔ f.ker := by
  simp only [map_le_map_iff, sup_le_iff, le_sup_right, and_true_iff]
#align subgroup.map_le_map_iff' Subgroup.map_le_map_iff'
#align add_subgroup.map_le_map_iff' AddSubgroup.map_le_map_iff'

/- warning: subgroup.map_eq_map_iff -> Subgroup.map_eq_map_iff is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))} {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1}, Iff (Eq.{succ u2} (Subgroup.{u2} N _inst_4) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f K)) (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) H (MonoidHom.ker.{u1, u2} G _inst_1 N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) f)) (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) K (MonoidHom.ker.{u1, u2} G _inst_1 N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) f)))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))} {H : Subgroup.{u2} G _inst_1} {K : Subgroup.{u2} G _inst_1}, Iff (Eq.{succ u1} (Subgroup.{u1} N _inst_4) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f K)) (Eq.{succ u2} (Subgroup.{u2} G _inst_1) (Sup.sup.{u2} (Subgroup.{u2} G _inst_1) (SemilatticeSup.toSup.{u2} (Subgroup.{u2} G _inst_1) (Lattice.toSemilatticeSup.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toLattice.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1)))) H (MonoidHom.ker.{u2, u1} G _inst_1 N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) f)) (Sup.sup.{u2} (Subgroup.{u2} G _inst_1) (SemilatticeSup.toSup.{u2} (Subgroup.{u2} G _inst_1) (Lattice.toSemilatticeSup.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toLattice.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1)))) K (MonoidHom.ker.{u2, u1} G _inst_1 N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) f)))
Case conversion may be inaccurate. Consider using '#align subgroup.map_eq_map_iff Subgroup.map_eq_map_iffₓ'. -/
@[to_additive]
theorem map_eq_map_iff {f : G →* N} {H K : Subgroup G} :
    H.map f = K.map f ↔ H ⊔ f.ker = K ⊔ f.ker := by simp only [le_antisymm_iff, map_le_map_iff']
#align subgroup.map_eq_map_iff Subgroup.map_eq_map_iff
#align add_subgroup.map_eq_map_iff AddSubgroup.map_eq_map_iff

/- warning: subgroup.map_eq_range_iff -> Subgroup.map_eq_range_iff is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))} {H : Subgroup.{u1} G _inst_1}, Iff (Eq.{succ u2} (Subgroup.{u2} N _inst_4) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H) (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) (Codisjoint.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (BoundedOrder.toOrderTop.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (CompleteLattice.toBoundedOrder.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))) H (MonoidHom.ker.{u1, u2} G _inst_1 N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) f))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))} {H : Subgroup.{u2} G _inst_1}, Iff (Eq.{succ u1} (Subgroup.{u1} N _inst_4) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H) (MonoidHom.range.{u2, u1} G _inst_1 N _inst_4 f)) (Codisjoint.{u2} (Subgroup.{u2} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))) (BoundedOrder.toOrderTop.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))))) (CompleteLattice.toBoundedOrder.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))) H (MonoidHom.ker.{u2, u1} G _inst_1 N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) f))
Case conversion may be inaccurate. Consider using '#align subgroup.map_eq_range_iff Subgroup.map_eq_range_iffₓ'. -/
@[to_additive]
theorem map_eq_range_iff {f : G →* N} {H : Subgroup G} : H.map f = f.range ↔ Codisjoint H f.ker :=
  by rw [f.range_eq_map, map_eq_map_iff, codisjoint_iff, top_sup_eq]
#align subgroup.map_eq_range_iff Subgroup.map_eq_range_iff
#align add_subgroup.map_eq_range_iff AddSubgroup.map_eq_range_iff

/- warning: subgroup.map_le_map_iff_of_injective -> Subgroup.map_le_map_iff_of_injective is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))}, (Function.Injective.{succ u1, succ u2} G N (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f)) -> (forall {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1}, Iff (LE.le.{u2} (Subgroup.{u2} N _inst_4) (Preorder.toLE.{u2} (Subgroup.{u2} N _inst_4) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} N _inst_4) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)))) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f K)) (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H K))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))}, (Function.Injective.{succ u2, succ u1} G N (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f)) -> (forall {H : Subgroup.{u2} G _inst_1} {K : Subgroup.{u2} G _inst_1}, Iff (LE.le.{u1} (Subgroup.{u1} N _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} N _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} N _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} N _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} N _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u1} N _inst_4))))) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f K)) (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))))) H K))
Case conversion may be inaccurate. Consider using '#align subgroup.map_le_map_iff_of_injective Subgroup.map_le_map_iff_of_injectiveₓ'. -/
@[to_additive]
theorem map_le_map_iff_of_injective {f : G →* N} (hf : Function.Injective f) {H K : Subgroup G} :
    H.map f ≤ K.map f ↔ H ≤ K := by rw [map_le_iff_le_comap, comap_map_eq_self_of_injective hf]
#align subgroup.map_le_map_iff_of_injective Subgroup.map_le_map_iff_of_injective
#align add_subgroup.map_le_map_iff_of_injective AddSubgroup.map_le_map_iff_of_injective

/- warning: subgroup.map_subtype_le_map_subtype -> Subgroup.map_subtype_le_map_subtype is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {G' : Subgroup.{u1} G _inst_1} {H : Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) G') (Subgroup.toGroup.{u1} G _inst_1 G')} {K : Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) G') (Subgroup.toGroup.{u1} G _inst_1 G')}, Iff (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.map.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) G') (Subgroup.toGroup.{u1} G _inst_1 G') G _inst_1 (Subgroup.subtype.{u1} G _inst_1 G') H) (Subgroup.map.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) G') (Subgroup.toGroup.{u1} G _inst_1 G') G _inst_1 (Subgroup.subtype.{u1} G _inst_1 G') K)) (LE.le.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) G') (Subgroup.toGroup.{u1} G _inst_1 G')) (Preorder.toLE.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) G') (Subgroup.toGroup.{u1} G _inst_1 G')) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) G') (Subgroup.toGroup.{u1} G _inst_1 G')) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) G') (Subgroup.toGroup.{u1} G _inst_1 G')) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) G') (Subgroup.setLike.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) G') (Subgroup.toGroup.{u1} G _inst_1 G'))))) H K)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {G' : Subgroup.{u1} G _inst_1} {H : Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x G')) (Subgroup.toGroup.{u1} G _inst_1 G')} {K : Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x G')) (Subgroup.toGroup.{u1} G _inst_1 G')}, Iff (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (Subgroup.map.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x G')) (Subgroup.toGroup.{u1} G _inst_1 G') G _inst_1 (Subgroup.subtype.{u1} G _inst_1 G') H) (Subgroup.map.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x G')) (Subgroup.toGroup.{u1} G _inst_1 G') G _inst_1 (Subgroup.subtype.{u1} G _inst_1 G') K)) (LE.le.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x G')) (Subgroup.toGroup.{u1} G _inst_1 G')) (Preorder.toLE.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x G')) (Subgroup.toGroup.{u1} G _inst_1 G')) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x G')) (Subgroup.toGroup.{u1} G _inst_1 G')) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x G')) (Subgroup.toGroup.{u1} G _inst_1 G')) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x G')) (Subgroup.toGroup.{u1} G _inst_1 G')) (Subgroup.instCompleteLatticeSubgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x G')) (Subgroup.toGroup.{u1} G _inst_1 G')))))) H K)
Case conversion may be inaccurate. Consider using '#align subgroup.map_subtype_le_map_subtype Subgroup.map_subtype_le_map_subtypeₓ'. -/
@[simp, to_additive]
theorem map_subtype_le_map_subtype {G' : Subgroup G} {H K : Subgroup G'} :
    H.map G'.Subtype ≤ K.map G'.Subtype ↔ H ≤ K :=
  map_le_map_iff_of_injective Subtype.coe_injective
#align subgroup.map_subtype_le_map_subtype Subgroup.map_subtype_le_map_subtype
#align add_subgroup.map_subtype_le_map_subtype AddSubgroup.map_subtype_le_map_subtype

/- warning: subgroup.map_injective -> Subgroup.map_injective is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))}, (Function.Injective.{succ u1, succ u2} G N (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f)) -> (Function.Injective.{succ u1, succ u2} (Subgroup.{u1} G _inst_1) (Subgroup.{u2} N _inst_4) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))}, (Function.Injective.{succ u2, succ u1} G N (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f)) -> (Function.Injective.{succ u2, succ u1} (Subgroup.{u2} G _inst_1) (Subgroup.{u1} N _inst_4) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f))
Case conversion may be inaccurate. Consider using '#align subgroup.map_injective Subgroup.map_injectiveₓ'. -/
@[to_additive]
theorem map_injective {f : G →* N} (h : Function.Injective f) : Function.Injective (map f) :=
  Function.LeftInverse.injective <| comap_map_eq_self_of_injective h
#align subgroup.map_injective Subgroup.map_injective
#align add_subgroup.map_injective AddSubgroup.map_injective

/- warning: subgroup.map_eq_comap_of_inverse -> Subgroup.map_eq_comap_of_inverse is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))} {g : MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))}, (Function.LeftInverse.{succ u1, succ u2} G N (coeFn.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => N -> G) (MonoidHom.hasCoeToFun.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) g) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f)) -> (Function.RightInverse.{succ u1, succ u2} G N (coeFn.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => N -> G) (MonoidHom.hasCoeToFun.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) g) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f)) -> (forall (H : Subgroup.{u1} G _inst_1), Eq.{succ u2} (Subgroup.{u2} N _inst_4) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H) (Subgroup.comap.{u2, u1} N _inst_4 G _inst_1 g H))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] {f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))} {g : MonoidHom.{u1, u2} N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))}, (Function.LeftInverse.{succ u2, succ u1} G N (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (MonoidHom.{u1, u2} N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) N (fun (_x : N) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : N) => G) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (MonoidHom.{u1, u2} N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) N G (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u1, u2} (MonoidHom.{u1, u2} N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (MonoidHom.monoidHomClass.{u1, u2} N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))) g) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f)) -> (Function.RightInverse.{succ u2, succ u1} G N (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (MonoidHom.{u1, u2} N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) N (fun (_x : N) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : N) => G) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (MonoidHom.{u1, u2} N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) N G (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u1, u2} (MonoidHom.{u1, u2} N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (MonoidHom.monoidHomClass.{u1, u2} N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))) g) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f)) -> (forall (H : Subgroup.{u2} G _inst_1), Eq.{succ u1} (Subgroup.{u1} N _inst_4) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H) (Subgroup.comap.{u1, u2} N _inst_4 G _inst_1 g H))
Case conversion may be inaccurate. Consider using '#align subgroup.map_eq_comap_of_inverse Subgroup.map_eq_comap_of_inverseₓ'. -/
@[to_additive]
theorem map_eq_comap_of_inverse {f : G →* N} {g : N →* G} (hl : Function.LeftInverse g f)
    (hr : Function.RightInverse g f) (H : Subgroup G) : map f H = comap g H :=
  SetLike.ext' <| by rw [coe_map, coe_comap, Set.image_eq_preimage_of_inverse hl hr]
#align subgroup.map_eq_comap_of_inverse Subgroup.map_eq_comap_of_inverse
#align add_subgroup.map_eq_comap_of_inverse AddSubgroup.map_eq_comap_of_inverse

/- warning: subgroup.map_injective_of_ker_le -> Subgroup.map_injective_of_ker_le is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1}, (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (MonoidHom.ker.{u1, u2} G _inst_1 N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) f) H) -> (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (MonoidHom.ker.{u1, u2} G _inst_1 N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) f) K) -> (Eq.{succ u2} (Subgroup.{u2} N _inst_4) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f K)) -> (Eq.{succ u1} (Subgroup.{u1} G _inst_1) H K)
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) {H : Subgroup.{u2} G _inst_1} {K : Subgroup.{u2} G _inst_1}, (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))))) (MonoidHom.ker.{u2, u1} G _inst_1 N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) f) H) -> (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))))) (MonoidHom.ker.{u2, u1} G _inst_1 N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) f) K) -> (Eq.{succ u1} (Subgroup.{u1} N _inst_4) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f K)) -> (Eq.{succ u2} (Subgroup.{u2} G _inst_1) H K)
Case conversion may be inaccurate. Consider using '#align subgroup.map_injective_of_ker_le Subgroup.map_injective_of_ker_leₓ'. -/
/-- Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`. -/
@[to_additive "Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`."]
theorem map_injective_of_ker_le {H K : Subgroup G} (hH : f.ker ≤ H) (hK : f.ker ≤ K)
    (hf : map f H = map f K) : H = K :=
  by
  apply_fun comap f  at hf
  rwa [comap_map_eq, comap_map_eq, sup_of_le_left hH, sup_of_le_left hK] at hf
#align subgroup.map_injective_of_ker_le Subgroup.map_injective_of_ker_le
#align add_subgroup.map_injective_of_ker_le AddSubgroup.map_injective_of_ker_le

/- warning: subgroup.closure_preimage_eq_top -> Subgroup.closure_preimage_eq_top is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (s : Set.{u1} G), Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 s)) (Subgroup.toGroup.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 s))) (Subgroup.closure.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 s)) (Subgroup.toGroup.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 s)) (Set.preimage.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 s)) G (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 s)) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 s)) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 s)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 s)) (Subgroup.toGroup.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 s))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 s)) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 s)) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 s)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 s)) (Subgroup.toGroup.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 s))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 s)) -> G) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 s)) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 s)) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 s)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 s)) (Subgroup.toGroup.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 s))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.subtype.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 s))) s)) (Top.top.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 s)) (Subgroup.toGroup.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 s))) (Subgroup.hasTop.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.closure.{u1} G _inst_1 s)) (Subgroup.toGroup.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 s))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (s : Set.{u1} G), Eq.{succ u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 s))) (Subgroup.toGroup.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 s))) (Subgroup.closure.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 s))) (Subgroup.toGroup.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 s)) (Set.preimage.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 s))) G (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 s))) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 s))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 s))) (fun (_x : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 s))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 s))) => G) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 s))) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 s))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 s))) G (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 s))) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 s)))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 s))) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 s))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 s))) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 s))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (MonoidHom.monoidHomClass.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 s))) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 s))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (Subgroup.subtype.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 s))) s)) (Top.top.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 s))) (Subgroup.toGroup.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 s))) (Subgroup.instTopSubgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 s))) (Subgroup.toGroup.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 s))))
Case conversion may be inaccurate. Consider using '#align subgroup.closure_preimage_eq_top Subgroup.closure_preimage_eq_topₓ'. -/
@[to_additive]
theorem closure_preimage_eq_top (s : Set G) : closure ((closure s).Subtype ⁻¹' s) = ⊤ :=
  by
  apply map_injective (closure s).subtype_injective
  rwa [MonoidHom.map_closure, ← MonoidHom.range_eq_map, subtype_range,
    Set.image_preimage_eq_of_subset]
  rw [coeSubtype, Subtype.range_coe_subtype]
  exact subset_closure
#align subgroup.closure_preimage_eq_top Subgroup.closure_preimage_eq_top
#align add_subgroup.closure_preimage_eq_top AddSubgroup.closure_preimage_eq_top

/- warning: subgroup.comap_sup_eq_of_le_range -> Subgroup.comap_sup_eq_of_le_range is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) {H : Subgroup.{u2} N _inst_4} {K : Subgroup.{u2} N _inst_4}, (LE.le.{u2} (Subgroup.{u2} N _inst_4) (Preorder.toLE.{u2} (Subgroup.{u2} N _inst_4) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} N _inst_4) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)))) H (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) -> (LE.le.{u2} (Subgroup.{u2} N _inst_4) (Preorder.toLE.{u2} (Subgroup.{u2} N _inst_4) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} N _inst_4) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)))) K (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) -> (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f H) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f K)) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f (Sup.sup.{u2} (Subgroup.{u2} N _inst_4) (SemilatticeSup.toHasSup.{u2} (Subgroup.{u2} N _inst_4) (Lattice.toSemilatticeSup.{u2} (Subgroup.{u2} N _inst_4) (CompleteLattice.toLattice.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.completeLattice.{u2} N _inst_4)))) H K)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) {H : Subgroup.{u2} N _inst_4} {K : Subgroup.{u2} N _inst_4}, (LE.le.{u2} (Subgroup.{u2} N _inst_4) (Preorder.toLE.{u2} (Subgroup.{u2} N _inst_4) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} N _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} N _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u2} N _inst_4))))) H (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) -> (LE.le.{u2} (Subgroup.{u2} N _inst_4) (Preorder.toLE.{u2} (Subgroup.{u2} N _inst_4) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} N _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} N _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u2} N _inst_4))))) K (MonoidHom.range.{u1, u2} G _inst_1 N _inst_4 f)) -> (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f H) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f K)) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f (Sup.sup.{u2} (Subgroup.{u2} N _inst_4) (SemilatticeSup.toSup.{u2} (Subgroup.{u2} N _inst_4) (Lattice.toSemilatticeSup.{u2} (Subgroup.{u2} N _inst_4) (CompleteLattice.toLattice.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u2} N _inst_4)))) H K)))
Case conversion may be inaccurate. Consider using '#align subgroup.comap_sup_eq_of_le_range Subgroup.comap_sup_eq_of_le_rangeₓ'. -/
@[to_additive]
theorem comap_sup_eq_of_le_range {H K : Subgroup N} (hH : H ≤ f.range) (hK : K ≤ f.range) :
    comap f H ⊔ comap f K = comap f (H ⊔ K) :=
  map_injective_of_ker_le f ((ker_le_comap f H).trans le_sup_left) (ker_le_comap f (H ⊔ K))
    (by
      rw [map_comap_eq, map_sup, map_comap_eq, map_comap_eq, inf_eq_right.mpr hH,
        inf_eq_right.mpr hK, inf_eq_right.mpr (sup_le hH hK)])
#align subgroup.comap_sup_eq_of_le_range Subgroup.comap_sup_eq_of_le_range
#align add_subgroup.comap_sup_eq_of_le_range AddSubgroup.comap_sup_eq_of_le_range

/- warning: subgroup.comap_sup_eq -> Subgroup.comap_sup_eq is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (H : Subgroup.{u2} N _inst_4) (K : Subgroup.{u2} N _inst_4), (Function.Surjective.{succ u1, succ u2} G N (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f)) -> (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f H) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f K)) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f (Sup.sup.{u2} (Subgroup.{u2} N _inst_4) (SemilatticeSup.toHasSup.{u2} (Subgroup.{u2} N _inst_4) (Lattice.toSemilatticeSup.{u2} (Subgroup.{u2} N _inst_4) (CompleteLattice.toLattice.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.completeLattice.{u2} N _inst_4)))) H K)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (H : Subgroup.{u2} N _inst_4) (K : Subgroup.{u2} N _inst_4), (Function.Surjective.{succ u1, succ u2} G N (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) G N (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (MonoidHom.monoidHomClass.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))))) f)) -> (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f H) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f K)) (Subgroup.comap.{u1, u2} G _inst_1 N _inst_4 f (Sup.sup.{u2} (Subgroup.{u2} N _inst_4) (SemilatticeSup.toSup.{u2} (Subgroup.{u2} N _inst_4) (Lattice.toSemilatticeSup.{u2} (Subgroup.{u2} N _inst_4) (CompleteLattice.toLattice.{u2} (Subgroup.{u2} N _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u2} N _inst_4)))) H K)))
Case conversion may be inaccurate. Consider using '#align subgroup.comap_sup_eq Subgroup.comap_sup_eqₓ'. -/
@[to_additive]
theorem comap_sup_eq (H K : Subgroup N) (hf : Function.Surjective f) :
    comap f H ⊔ comap f K = comap f (H ⊔ K) :=
  comap_sup_eq_of_le_range f (le_top.trans (ge_of_eq (f.range_top_of_surjective hf)))
    (le_top.trans (ge_of_eq (f.range_top_of_surjective hf)))
#align subgroup.comap_sup_eq Subgroup.comap_sup_eq
#align add_subgroup.comap_sup_eq AddSubgroup.comap_sup_eq

/- warning: subgroup.sup_subgroup_of_eq -> Subgroup.sup_subgroupOf_eq is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1} {L : Subgroup.{u1} G _inst_1}, (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H L) -> (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) K L) -> (Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) L) (Subgroup.toGroup.{u1} G _inst_1 L)) (Sup.sup.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) L) (Subgroup.toGroup.{u1} G _inst_1 L)) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) L) (Subgroup.toGroup.{u1} G _inst_1 L)) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) L) (Subgroup.toGroup.{u1} G _inst_1 L)) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) L) (Subgroup.toGroup.{u1} G _inst_1 L)) (Subgroup.completeLattice.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) L) (Subgroup.toGroup.{u1} G _inst_1 L))))) (Subgroup.subgroupOf.{u1} G _inst_1 H L) (Subgroup.subgroupOf.{u1} G _inst_1 K L)) (Subgroup.subgroupOf.{u1} G _inst_1 (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) H K) L))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1} {L : Subgroup.{u1} G _inst_1}, (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) H L) -> (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) K L) -> (Eq.{succ u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x L)) (Subgroup.toGroup.{u1} G _inst_1 L)) (Sup.sup.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x L)) (Subgroup.toGroup.{u1} G _inst_1 L)) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x L)) (Subgroup.toGroup.{u1} G _inst_1 L)) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x L)) (Subgroup.toGroup.{u1} G _inst_1 L)) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x L)) (Subgroup.toGroup.{u1} G _inst_1 L)) (Subgroup.instCompleteLatticeSubgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x L)) (Subgroup.toGroup.{u1} G _inst_1 L))))) (Subgroup.subgroupOf.{u1} G _inst_1 H L) (Subgroup.subgroupOf.{u1} G _inst_1 K L)) (Subgroup.subgroupOf.{u1} G _inst_1 (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) H K) L))
Case conversion may be inaccurate. Consider using '#align subgroup.sup_subgroup_of_eq Subgroup.sup_subgroupOf_eqₓ'. -/
@[to_additive]
theorem sup_subgroupOf_eq {H K L : Subgroup G} (hH : H ≤ L) (hK : K ≤ L) :
    H.subgroupOf L ⊔ K.subgroupOf L = (H ⊔ K).subgroupOf L :=
  comap_sup_eq_of_le_range L.Subtype (hH.trans L.subtype_range.ge) (hK.trans L.subtype_range.ge)
#align subgroup.sup_subgroup_of_eq Subgroup.sup_subgroupOf_eq
#align add_subgroup.sup_add_subgroup_of_eq AddSubgroup.sup_addSubgroupOf_eq

/- warning: subgroup.codisjoint_subgroup_of_sup -> Subgroup.codisjoint_subgroupOf_sup is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (K : Subgroup.{u1} G _inst_1), Codisjoint.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) H K)) (Subgroup.toGroup.{u1} G _inst_1 (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) H K))) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) H K)) (Subgroup.toGroup.{u1} G _inst_1 (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) H K))) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) H K)) (Subgroup.setLike.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) H K)) (Subgroup.toGroup.{u1} G _inst_1 (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) H K)))) (BoundedOrder.toOrderTop.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) H K)) (Subgroup.toGroup.{u1} G _inst_1 (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) H K))) (Preorder.toLE.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) H K)) (Subgroup.toGroup.{u1} G _inst_1 (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) H K))) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) H K)) (Subgroup.toGroup.{u1} G _inst_1 (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) H K))) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) H K)) (Subgroup.toGroup.{u1} G _inst_1 (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) H K))) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) H K)) (Subgroup.setLike.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) H K)) (Subgroup.toGroup.{u1} G _inst_1 (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) H K)))))) (CompleteLattice.toBoundedOrder.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) H K)) (Subgroup.toGroup.{u1} G _inst_1 (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) H K))) (Subgroup.completeLattice.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) H K)) (Subgroup.toGroup.{u1} G _inst_1 (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) H K))))) (Subgroup.subgroupOf.{u1} G _inst_1 H (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) H K)) (Subgroup.subgroupOf.{u1} G _inst_1 K (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) H K))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (K : Subgroup.{u1} G _inst_1), Codisjoint.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) H K))) (Subgroup.toGroup.{u1} G _inst_1 (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) H K))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) H K))) (Subgroup.toGroup.{u1} G _inst_1 (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) H K))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) H K))) (Subgroup.toGroup.{u1} G _inst_1 (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) H K))) (Subgroup.instCompleteLatticeSubgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) H K))) (Subgroup.toGroup.{u1} G _inst_1 (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) H K))))) (BoundedOrder.toOrderTop.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) H K))) (Subgroup.toGroup.{u1} G _inst_1 (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) H K))) (Preorder.toLE.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) H K))) (Subgroup.toGroup.{u1} G _inst_1 (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) H K))) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) H K))) (Subgroup.toGroup.{u1} G _inst_1 (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) H K))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) H K))) (Subgroup.toGroup.{u1} G _inst_1 (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) H K))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) H K))) (Subgroup.toGroup.{u1} G _inst_1 (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) H K))) (Subgroup.instCompleteLatticeSubgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) H K))) (Subgroup.toGroup.{u1} G _inst_1 (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) H K))))))) (CompleteLattice.toBoundedOrder.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) H K))) (Subgroup.toGroup.{u1} G _inst_1 (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) H K))) (Subgroup.instCompleteLatticeSubgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) H K))) (Subgroup.toGroup.{u1} G _inst_1 (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) H K))))) (Subgroup.subgroupOf.{u1} G _inst_1 H (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) H K)) (Subgroup.subgroupOf.{u1} G _inst_1 K (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) H K))
Case conversion may be inaccurate. Consider using '#align subgroup.codisjoint_subgroup_of_sup Subgroup.codisjoint_subgroupOf_supₓ'. -/
@[to_additive]
theorem codisjoint_subgroupOf_sup (H K : Subgroup G) :
    Codisjoint (H.subgroupOf (H ⊔ K)) (K.subgroupOf (H ⊔ K)) :=
  by
  rw [codisjoint_iff, sup_subgroup_of_eq, subgroup_of_self]
  exacts[le_sup_left, le_sup_right]
#align subgroup.codisjoint_subgroup_of_sup Subgroup.codisjoint_subgroupOf_sup
#align add_subgroup.codisjoint_add_subgroup_of_sup AddSubgroup.codisjoint_addSubgroupOf_sup

/- warning: subgroup.equiv_map_of_injective -> Subgroup.equivMapOfInjective is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (H : Subgroup.{u1} G _inst_1) (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), (Function.Injective.{succ u1, succ u2} G N (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f)) -> (MulEquiv.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H)) (Subgroup.mul.{u1} G _inst_1 H) (Subgroup.mul.{u2} N _inst_4 (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (H : Subgroup.{u1} G _inst_1) (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))), (Function.Injective.{succ u1, succ u2} G N (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) G N (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (MonoidHom.monoidHomClass.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))))) f)) -> (MulEquiv.{u1, u2} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subtype.{succ u2} N (fun (x : N) => Membership.mem.{u2, u2} N (Subgroup.{u2} N _inst_4) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u2} N _inst_4)) x (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H))) (Subgroup.mul.{u1} G _inst_1 H) (Subgroup.mul.{u2} N _inst_4 (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H)))
Case conversion may be inaccurate. Consider using '#align subgroup.equiv_map_of_injective Subgroup.equivMapOfInjectiveₓ'. -/
/-- A subgroup is isomorphic to its image under an injective function. If you have an isomorphism,
use `mul_equiv.subgroup_map` for better definitional equalities. -/
@[to_additive
      "An additive subgroup is isomorphic to its image under an injective function. If you\nhave an isomorphism, use `add_equiv.add_subgroup_map` for better definitional equalities."]
noncomputable def equivMapOfInjective (H : Subgroup G) (f : G →* N) (hf : Function.Injective f) :
    H ≃* H.map f :=
  { Equiv.Set.image f H hf with map_mul' := fun _ _ => Subtype.ext (f.map_mul _ _) }
#align subgroup.equiv_map_of_injective Subgroup.equivMapOfInjective
#align add_subgroup.equiv_map_of_injective AddSubgroup.equivMapOfInjective

/- warning: subgroup.coe_equiv_map_of_injective_apply -> Subgroup.coe_equivMapOfInjective_apply is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (H : Subgroup.{u1} G _inst_1) (f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (hf : Function.Injective.{succ u1, succ u2} G N (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f)) (h : coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H), Eq.{succ u2} N ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H)) N (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H)) N (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H)) N (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H)) N (coeSubtype.{succ u2} N (fun (x : N) => Membership.Mem.{u2, u2} N (Subgroup.{u2} N _inst_4) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) x (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (MulEquiv.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H)) (Subgroup.mul.{u1} G _inst_1 H) (Subgroup.mul.{u2} N _inst_4 (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H))) (fun (_x : MulEquiv.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H)) (Subgroup.mul.{u1} G _inst_1 H) (Subgroup.mul.{u2} N _inst_4 (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H))) => (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) -> (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H))) (MulEquiv.hasCoeToFun.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H)) (Subgroup.mul.{u1} G _inst_1 H) (Subgroup.mul.{u2} N _inst_4 (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H))) (Subgroup.equivMapOfInjective.{u1, u2} G _inst_1 N _inst_4 H f hf) h)) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H))))) h))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (H : Subgroup.{u2} G _inst_1) (f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (hf : Function.Injective.{succ u2, succ u1} G N (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f)) (h : Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)), Eq.{succ u1} N (Subtype.val.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Set.{u1} N) (Set.instMembershipSet.{u1} N) x (SetLike.coe.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulEquiv.{u2, u1} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H))) (Subgroup.mul.{u2} G _inst_1 H) (Subgroup.mul.{u1} N _inst_4 (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H))) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (fun (_x : Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) => Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H))) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H))) (Subgroup.mul.{u2} G _inst_1 H) (Subgroup.mul.{u1} N _inst_4 (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H))) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H))) (MulOneClass.toMul.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Submonoid.toMulOneClass.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Subgroup.toSubmonoid.{u2} G _inst_1 H))) (MulOneClass.toMul.{u1} (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H))) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H))) (Subgroup.mul.{u2} G _inst_1 H) (Subgroup.mul.{u1} N _inst_4 (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H))) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H))) (Submonoid.toMulOneClass.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Subgroup.toSubmonoid.{u2} G _inst_1 H)) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H))) (Subgroup.mul.{u2} G _inst_1 H) (Subgroup.mul.{u1} N _inst_4 (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H))) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H))) (Submonoid.toMulOneClass.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Subgroup.toSubmonoid.{u2} G _inst_1 H)) (Submonoid.toMulOneClass.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Subgroup.toSubmonoid.{u1} N _inst_4 (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Subgroup.{u1} N _inst_4) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u1} N _inst_4)) x (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H))) (Subgroup.mul.{u2} G _inst_1 H) (Subgroup.mul.{u1} N _inst_4 (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H)))))) (Subgroup.equivMapOfInjective.{u2, u1} G _inst_1 N _inst_4 H f hf) h)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f (Subtype.val.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Set.{u2} G) (Set.instMembershipSet.{u2} G) x (SetLike.coe.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1) H)) h))
Case conversion may be inaccurate. Consider using '#align subgroup.coe_equiv_map_of_injective_apply Subgroup.coe_equivMapOfInjective_applyₓ'. -/
@[simp, to_additive]
theorem coe_equivMapOfInjective_apply (H : Subgroup G) (f : G →* N) (hf : Function.Injective f)
    (h : H) : (equivMapOfInjective H f hf h : N) = f h :=
  rfl
#align subgroup.coe_equiv_map_of_injective_apply Subgroup.coe_equivMapOfInjective_apply
#align add_subgroup.coe_equiv_map_of_injective_apply AddSubgroup.coe_equivMapOfInjective_apply

/- warning: subgroup.comap_normalizer_eq_of_surjective -> Subgroup.comap_normalizer_eq_of_surjective is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (H : Subgroup.{u1} G _inst_1) {f : MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))}, (Function.Surjective.{succ u2, succ u1} N G (coeFn.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => N -> G) (MonoidHom.hasCoeToFun.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) f)) -> (Eq.{succ u2} (Subgroup.{u2} N _inst_4) (Subgroup.comap.{u2, u1} N _inst_4 G _inst_1 f (Subgroup.normalizer.{u1} G _inst_1 H)) (Subgroup.normalizer.{u2} N _inst_4 (Subgroup.comap.{u2, u1} N _inst_4 G _inst_1 f H)))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (H : Subgroup.{u2} G _inst_1) {f : MonoidHom.{u1, u2} N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))}, (Function.Surjective.{succ u1, succ u2} N G (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (MonoidHom.{u1, u2} N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) N (fun (_x : N) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : N) => G) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (MonoidHom.{u1, u2} N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) N G (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u1, u2} (MonoidHom.{u1, u2} N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (MonoidHom.monoidHomClass.{u1, u2} N G (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))) f)) -> (Eq.{succ u1} (Subgroup.{u1} N _inst_4) (Subgroup.comap.{u1, u2} N _inst_4 G _inst_1 f (Subgroup.normalizer.{u2} G _inst_1 H)) (Subgroup.normalizer.{u1} N _inst_4 (Subgroup.comap.{u1, u2} N _inst_4 G _inst_1 f H)))
Case conversion may be inaccurate. Consider using '#align subgroup.comap_normalizer_eq_of_surjective Subgroup.comap_normalizer_eq_of_surjectiveₓ'. -/
/-- The preimage of the normalizer is equal to the normalizer of the preimage of a surjective
  function. -/
@[to_additive
      "The preimage of the normalizer is equal to the normalizer of the preimage of\na surjective function."]
theorem comap_normalizer_eq_of_surjective (H : Subgroup G) {f : N →* G}
    (hf : Function.Surjective f) : H.normalizer.comap f = (H.comap f).normalizer :=
  le_antisymm (le_normalizer_comap f)
    (by
      intro x hx
      simp only [mem_comap, mem_normalizer_iff] at *
      intro n
      rcases hf n with ⟨y, rfl⟩
      simp [hx y])
#align subgroup.comap_normalizer_eq_of_surjective Subgroup.comap_normalizer_eq_of_surjective
#align add_subgroup.comap_normalizer_eq_of_surjective AddSubgroup.comap_normalizer_eq_of_surjective

/- warning: subgroup.comap_normalizer_eq_of_injective_of_le_range -> Subgroup.comap_normalizer_eq_of_injective_of_le_range is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_5 : Group.{u2} N] (H : Subgroup.{u1} G _inst_1) {f : MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_5))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))}, (Function.Injective.{succ u2, succ u1} N G (coeFn.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_5))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_5))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => N -> G) (MonoidHom.hasCoeToFun.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_5))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) f)) -> (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.normalizer.{u1} G _inst_1 H) (MonoidHom.range.{u2, u1} N _inst_5 G _inst_1 f)) -> (Eq.{succ u2} (Subgroup.{u2} N _inst_5) (Subgroup.comap.{u2, u1} N _inst_5 G _inst_1 f (Subgroup.normalizer.{u1} G _inst_1 H)) (Subgroup.normalizer.{u2} N _inst_5 (Subgroup.comap.{u2, u1} N _inst_5 G _inst_1 f H)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_5 : Group.{u2} N] (H : Subgroup.{u1} G _inst_1) {f : MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_5))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))}, (Function.Injective.{succ u2, succ u1} N G (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_5))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) N (fun (_x : N) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : N) => G) _x) (MulHomClass.toFunLike.{max u1 u2, u2, u1} (MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_5))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) N G (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_5)))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u2, u1} (MonoidHom.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_5))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_5))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (MonoidHom.monoidHomClass.{u2, u1} N G (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_5))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) f)) -> (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (Subgroup.normalizer.{u1} G _inst_1 H) (MonoidHom.range.{u2, u1} N _inst_5 G _inst_1 f)) -> (Eq.{succ u2} (Subgroup.{u2} N _inst_5) (Subgroup.comap.{u2, u1} N _inst_5 G _inst_1 f (Subgroup.normalizer.{u1} G _inst_1 H)) (Subgroup.normalizer.{u2} N _inst_5 (Subgroup.comap.{u2, u1} N _inst_5 G _inst_1 f H)))
Case conversion may be inaccurate. Consider using '#align subgroup.comap_normalizer_eq_of_injective_of_le_range Subgroup.comap_normalizer_eq_of_injective_of_le_rangeₓ'. -/
@[to_additive]
theorem comap_normalizer_eq_of_injective_of_le_range {N : Type _} [Group N] (H : Subgroup G)
    {f : N →* G} (hf : Function.Injective f) (h : H.normalizer ≤ f.range) :
    comap f H.normalizer = (comap f H).normalizer :=
  by
  apply Subgroup.map_injective hf
  rw [map_comap_eq_self h]
  apply le_antisymm
  · refine' le_trans (le_of_eq _) (map_mono (le_normalizer_comap _))
    rw [map_comap_eq_self h]
  · refine' le_trans (le_normalizer_map f) (le_of_eq _)
    rw [map_comap_eq_self (le_trans le_normalizer h)]
#align subgroup.comap_normalizer_eq_of_injective_of_le_range Subgroup.comap_normalizer_eq_of_injective_of_le_range
#align add_subgroup.comap_normalizer_eq_of_injective_of_le_range AddSubgroup.comap_normalizer_eq_of_injective_of_le_range

/- warning: subgroup.subgroup_of_normalizer_eq -> Subgroup.subgroupOf_normalizer_eq is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {N : Subgroup.{u1} G _inst_1}, (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.normalizer.{u1} G _inst_1 H) N) -> (Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) N) (Subgroup.toGroup.{u1} G _inst_1 N)) (Subgroup.subgroupOf.{u1} G _inst_1 (Subgroup.normalizer.{u1} G _inst_1 H) N) (Subgroup.normalizer.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) N) (Subgroup.toGroup.{u1} G _inst_1 N) (Subgroup.subgroupOf.{u1} G _inst_1 H N)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {N : Subgroup.{u1} G _inst_1}, (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (Subgroup.normalizer.{u1} G _inst_1 H) N) -> (Eq.{succ u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x N)) (Subgroup.toGroup.{u1} G _inst_1 N)) (Subgroup.subgroupOf.{u1} G _inst_1 (Subgroup.normalizer.{u1} G _inst_1 H) N) (Subgroup.normalizer.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x N)) (Subgroup.toGroup.{u1} G _inst_1 N) (Subgroup.subgroupOf.{u1} G _inst_1 H N)))
Case conversion may be inaccurate. Consider using '#align subgroup.subgroup_of_normalizer_eq Subgroup.subgroupOf_normalizer_eqₓ'. -/
@[to_additive]
theorem subgroupOf_normalizer_eq {H N : Subgroup G} (h : H.normalizer ≤ N) :
    H.normalizer.subgroupOf N = (H.subgroupOf N).normalizer :=
  by
  apply comap_normalizer_eq_of_injective_of_le_range
  exact Subtype.coe_injective
  simpa
#align subgroup.subgroup_of_normalizer_eq Subgroup.subgroupOf_normalizer_eq
#align add_subgroup.add_subgroup_of_normalizer_eq AddSubgroup.addSubgroupOf_normalizer_eq

/- warning: subgroup.map_equiv_normalizer_eq -> Subgroup.map_equiv_normalizer_eq is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (H : Subgroup.{u1} G _inst_1) (f : MulEquiv.{u1, u2} G N (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} N (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))))), Eq.{succ u2} (Subgroup.{u2} N _inst_4) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 (MulEquiv.toMonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) f) (Subgroup.normalizer.{u1} G _inst_1 H)) (Subgroup.normalizer.{u2} N _inst_4 (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 (MulEquiv.toMonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4))) f) H))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (H : Subgroup.{u2} G _inst_1) (f : MulEquiv.{u2, u1} G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))))), Eq.{succ u1} (Subgroup.{u1} N _inst_4) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 (MulEquiv.toMonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) f) (Subgroup.normalizer.{u2} G _inst_1 H)) (Subgroup.normalizer.{u1} N _inst_4 (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 (MulEquiv.toMonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) f) H))
Case conversion may be inaccurate. Consider using '#align subgroup.map_equiv_normalizer_eq Subgroup.map_equiv_normalizer_eqₓ'. -/
/-- The image of the normalizer is equal to the normalizer of the image of an isomorphism. -/
@[to_additive
      "The image of the normalizer is equal to the normalizer of the image of an\nisomorphism."]
theorem map_equiv_normalizer_eq (H : Subgroup G) (f : G ≃* N) :
    H.normalizer.map f.toMonoidHom = (H.map f.toMonoidHom).normalizer :=
  by
  ext x
  simp only [mem_normalizer_iff, mem_map_equiv]
  rw [f.to_equiv.forall_congr]
  simp
#align subgroup.map_equiv_normalizer_eq Subgroup.map_equiv_normalizer_eq
#align add_subgroup.map_equiv_normalizer_eq AddSubgroup.map_equiv_normalizer_eq

/- warning: subgroup.map_normalizer_eq_of_bijective -> Subgroup.map_normalizer_eq_of_bijective is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (H : Subgroup.{u1} G _inst_1) {f : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))}, (Function.Bijective.{succ u1, succ u2} G N (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) (fun (_x : MonoidHom.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) => G -> N) (MonoidHom.hasCoeToFun.{u1, u2} G N (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} N (DivInvMonoid.toMonoid.{u2} N (Group.toDivInvMonoid.{u2} N _inst_4)))) f)) -> (Eq.{succ u2} (Subgroup.{u2} N _inst_4) (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f (Subgroup.normalizer.{u1} G _inst_1 H)) (Subgroup.normalizer.{u2} N _inst_4 (Subgroup.map.{u1, u2} G _inst_1 N _inst_4 f H)))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {N : Type.{u1}} [_inst_4 : Group.{u1} N] (H : Subgroup.{u2} G _inst_1) {f : MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))}, (Function.Bijective.{succ u2, succ u1} G N (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => N) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))) G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4))) (MonoidHom.monoidHomClass.{u2, u1} G N (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} N (DivInvMonoid.toMonoid.{u1} N (Group.toDivInvMonoid.{u1} N _inst_4)))))) f)) -> (Eq.{succ u1} (Subgroup.{u1} N _inst_4) (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f (Subgroup.normalizer.{u2} G _inst_1 H)) (Subgroup.normalizer.{u1} N _inst_4 (Subgroup.map.{u2, u1} G _inst_1 N _inst_4 f H)))
Case conversion may be inaccurate. Consider using '#align subgroup.map_normalizer_eq_of_bijective Subgroup.map_normalizer_eq_of_bijectiveₓ'. -/
/-- The image of the normalizer is equal to the normalizer of the image of a bijective
  function. -/
@[to_additive
      "The image of the normalizer is equal to the normalizer of the image of a bijective\n  function."]
theorem map_normalizer_eq_of_bijective (H : Subgroup G) {f : G →* N} (hf : Function.Bijective f) :
    H.normalizer.map f = (H.map f).normalizer :=
  map_equiv_normalizer_eq H (MulEquiv.ofBijective f hf)
#align subgroup.map_normalizer_eq_of_bijective Subgroup.map_normalizer_eq_of_bijective
#align add_subgroup.map_normalizer_eq_of_bijective AddSubgroup.map_normalizer_eq_of_bijective

end Subgroup

namespace MonoidHom

variable {G₁ G₂ G₃ : Type _} [Group G₁] [Group G₂] [Group G₃]

variable (f : G₁ →* G₂) (f_inv : G₂ → G₁)

/- warning: monoid_hom.lift_of_right_inverse_aux -> MonoidHom.liftOfRightInverseAux is a dubious translation:
lean 3 declaration is
  forall {G₁ : Type.{u1}} {G₂ : Type.{u2}} {G₃ : Type.{u3}} [_inst_4 : Group.{u1} G₁] [_inst_5 : Group.{u2} G₂] [_inst_6 : Group.{u3} G₃] (f : MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (f_inv : G₂ -> G₁), (Function.RightInverse.{succ u1, succ u2} G₁ G₂ f_inv (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (fun (_x : MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) => G₁ -> G₂) (MonoidHom.hasCoeToFun.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) f)) -> (forall (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))), (LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g)) -> (MonoidHom.{u2, u3} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))))
but is expected to have type
  forall {G₁ : Type.{u1}} {G₂ : Type.{u2}} {G₃ : Type.{u3}} [_inst_4 : Group.{u1} G₁] [_inst_5 : Group.{u2} G₂] [_inst_6 : Group.{u3} G₃] (f : MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (f_inv : G₂ -> G₁), (Function.RightInverse.{succ u1, succ u2} G₁ G₂ f_inv (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ (fun (_x : G₁) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₁) => G₂) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ G₂ (MulOneClass.toMul.{u1} G₁ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4)))) (MulOneClass.toMul.{u2} G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (MonoidHom.monoidHomClass.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))))) f)) -> (forall (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))), (LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G₁ _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G₁ _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u1} G₁ _inst_4))))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g)) -> (MonoidHom.{u2, u3} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))))
Case conversion may be inaccurate. Consider using '#align monoid_hom.lift_of_right_inverse_aux MonoidHom.liftOfRightInverseAuxₓ'. -/
/-- Auxiliary definition used to define `lift_of_right_inverse` -/
@[to_additive "Auxiliary definition used to define `lift_of_right_inverse`"]
def liftOfRightInverseAux (hf : Function.RightInverse f_inv f) (g : G₁ →* G₃) (hg : f.ker ≤ g.ker) :
    G₂ →* G₃ where
  toFun b := g (f_inv b)
  map_one' := hg (hf 1)
  map_mul' := by
    intro x y
    rw [← g.map_mul, ← mul_inv_eq_one, ← g.map_inv, ← g.map_mul, ← g.mem_ker]
    apply hg
    rw [f.mem_ker, f.map_mul, f.map_inv, mul_inv_eq_one, f.map_mul]
    simp only [hf _]
#align monoid_hom.lift_of_right_inverse_aux MonoidHom.liftOfRightInverseAux
#align add_monoid_hom.lift_of_right_inverse_aux AddMonoidHom.liftOfRightInverseAux

/- warning: monoid_hom.lift_of_right_inverse_aux_comp_apply -> MonoidHom.liftOfRightInverseAux_comp_apply is a dubious translation:
lean 3 declaration is
  forall {G₁ : Type.{u1}} {G₂ : Type.{u2}} {G₃ : Type.{u3}} [_inst_4 : Group.{u1} G₁] [_inst_5 : Group.{u2} G₂] [_inst_6 : Group.{u3} G₃] (f : MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (f_inv : G₂ -> G₁) (hf : Function.RightInverse.{succ u1, succ u2} G₁ G₂ f_inv (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (fun (_x : MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) => G₁ -> G₂) (MonoidHom.hasCoeToFun.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) f)) (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (hg : LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g)) (x : G₁), Eq.{succ u3} G₃ (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (MonoidHom.{u2, u3} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (_x : MonoidHom.{u2, u3} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => G₂ -> G₃) (MonoidHom.hasCoeToFun.{u2, u3} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (MonoidHom.liftOfRightInverseAux.{u1, u2, u3} G₁ G₂ G₃ _inst_4 _inst_5 _inst_6 f f_inv hf g hg) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (fun (_x : MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) => G₁ -> G₂) (MonoidHom.hasCoeToFun.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) f x)) (coeFn.{max (succ u3) (succ u1), max (succ u1) (succ u3)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (_x : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => G₁ -> G₃) (MonoidHom.hasCoeToFun.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) g x)
but is expected to have type
  forall {G₁ : Type.{u3}} {G₂ : Type.{u2}} {G₃ : Type.{u1}} [_inst_4 : Group.{u3} G₁] [_inst_5 : Group.{u2} G₂] [_inst_6 : Group.{u1} G₃] (f : MonoidHom.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (f_inv : G₂ -> G₁) (hf : Function.RightInverse.{succ u3, succ u2} G₁ G₂ f_inv (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (MonoidHom.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ (fun (_x : G₁) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₁) => G₂) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ G₂ (MulOneClass.toMul.{u3} G₁ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4)))) (MulOneClass.toMul.{u2} G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (MonoidHom.monoidHomClass.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))))) f)) (g : MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (hg : LE.le.{u3} (Subgroup.{u3} G₁ _inst_4) (Preorder.toLE.{u3} (Subgroup.{u3} G₁ _inst_4) (PartialOrder.toPreorder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Subgroup.{u3} G₁ _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u3} G₁ _inst_4))))) (MonoidHom.ker.{u3, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u3, u1} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) g)) (x : G₁), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₂) => G₃) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (MonoidHom.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ (fun (a : G₁) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₁) => G₂) a) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ G₂ (MulOneClass.toMul.{u3} G₁ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4)))) (MulOneClass.toMul.{u2} G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (MonoidHom.monoidHomClass.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))))) f x)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) G₂ (fun (_x : G₂) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₂) => G₃) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) G₂ G₃ (MulOneClass.toMul.{u2} G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (MulOneClass.toMul.{u1} G₃ (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) (MonoidHom.monoidHomClass.{u2, u1} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))))) (MonoidHom.liftOfRightInverseAux.{u3, u2, u1} G₁ G₂ G₃ _inst_4 _inst_5 _inst_6 f f_inv hf g hg) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (MonoidHom.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ (fun (_x : G₁) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₁) => G₂) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ G₂ (MulOneClass.toMul.{u3} G₁ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4)))) (MulOneClass.toMul.{u2} G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (MonoidHom.monoidHomClass.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))))) f x)) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) G₁ (fun (_x : G₁) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₁) => G₃) _x) (MulHomClass.toFunLike.{max u3 u1, u3, u1} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) G₁ G₃ (MulOneClass.toMul.{u3} G₁ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4)))) (MulOneClass.toMul.{u1} G₃ (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (MonoidHomClass.toMulHomClass.{max u3 u1, u3, u1} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) (MonoidHom.monoidHomClass.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))))) g x)
Case conversion may be inaccurate. Consider using '#align monoid_hom.lift_of_right_inverse_aux_comp_apply MonoidHom.liftOfRightInverseAux_comp_applyₓ'. -/
@[simp, to_additive]
theorem liftOfRightInverseAux_comp_apply (hf : Function.RightInverse f_inv f) (g : G₁ →* G₃)
    (hg : f.ker ≤ g.ker) (x : G₁) : (f.liftOfRightInverseAux f_inv hf g hg) (f x) = g x :=
  by
  dsimp [lift_of_right_inverse_aux]
  rw [← mul_inv_eq_one, ← g.map_inv, ← g.map_mul, ← g.mem_ker]
  apply hg
  rw [f.mem_ker, f.map_mul, f.map_inv, mul_inv_eq_one]
  simp only [hf _]
#align monoid_hom.lift_of_right_inverse_aux_comp_apply MonoidHom.liftOfRightInverseAux_comp_apply
#align add_monoid_hom.lift_of_right_inverse_aux_comp_apply AddMonoidHom.liftOfRightInverseAux_comp_apply

/- warning: monoid_hom.lift_of_right_inverse -> MonoidHom.liftOfRightInverse is a dubious translation:
lean 3 declaration is
  forall {G₁ : Type.{u1}} {G₂ : Type.{u2}} {G₃ : Type.{u3}} [_inst_4 : Group.{u1} G₁] [_inst_5 : Group.{u2} G₂] [_inst_6 : Group.{u3} G₃] (f : MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (f_inv : G₂ -> G₁), (Function.RightInverse.{succ u1, succ u2} G₁ G₂ f_inv (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (fun (_x : MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) => G₁ -> G₂) (MonoidHom.hasCoeToFun.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) f)) -> (Equiv.{max 1 (succ u3) (succ u1), max (succ u3) (succ u2)} (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g))) (MonoidHom.{u2, u3} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))))
but is expected to have type
  forall {G₁ : Type.{u1}} {G₂ : Type.{u2}} {G₃ : Type.{u3}} [_inst_4 : Group.{u1} G₁] [_inst_5 : Group.{u2} G₂] [_inst_6 : Group.{u3} G₃] (f : MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (f_inv : G₂ -> G₁), (Function.RightInverse.{succ u1, succ u2} G₁ G₂ f_inv (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ (fun (_x : G₁) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₁) => G₂) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ G₂ (MulOneClass.toMul.{u1} G₁ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4)))) (MulOneClass.toMul.{u2} G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (MonoidHom.monoidHomClass.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))))) f)) -> (Equiv.{max 1 (succ u1) (succ u3), max (succ u3) (succ u2)} (Subtype.{max (succ u1) (succ u3)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G₁ _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G₁ _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u1} G₁ _inst_4))))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g))) (MonoidHom.{u2, u3} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))))
Case conversion may be inaccurate. Consider using '#align monoid_hom.lift_of_right_inverse MonoidHom.liftOfRightInverseₓ'. -/
/-- `lift_of_right_inverse f hf g hg` is the unique group homomorphism `φ`

* such that `φ.comp f = g` (`monoid_hom.lift_of_right_inverse_comp`),
* where `f : G₁ →+* G₂` has a right_inverse `f_inv` (`hf`),
* and `g : G₂ →+* G₃` satisfies `hg : f.ker ≤ g.ker`.

See `monoid_hom.eq_lift_of_right_inverse` for the uniqueness lemma.

```
   G₁.
   |  \
 f |   \ g
   |    \
   v     \⌟
   G₂----> G₃
      ∃!φ
```
 -/
@[to_additive
      "`lift_of_right_inverse f f_inv hf g hg` is the unique additive group homomorphism `φ`\n\n* such that `φ.comp f = g` (`add_monoid_hom.lift_of_right_inverse_comp`),\n* where `f : G₁ →+ G₂` has a right_inverse `f_inv` (`hf`),\n* and `g : G₂ →+ G₃` satisfies `hg : f.ker ≤ g.ker`.\n\nSee `add_monoid_hom.eq_lift_of_right_inverse` for the uniqueness lemma.\n\n```\n   G₁.\n   |  \\\n f |   \\ g\n   |    \\\n   v     \\⌟\n   G₂----> G₃\n      ∃!φ\n```"]
def liftOfRightInverse (hf : Function.RightInverse f_inv f) :
    { g : G₁ →* G₃ // f.ker ≤ g.ker } ≃ (G₂ →* G₃)
    where
  toFun g := f.liftOfRightInverseAux f_inv hf g.1 g.2
  invFun φ := ⟨φ.comp f, fun x hx => (mem_ker _).mpr <| by simp [(mem_ker _).mp hx]⟩
  left_inv g := by
    ext
    simp only [comp_apply, lift_of_right_inverse_aux_comp_apply, Subtype.coe_mk, Subtype.val_eq_coe]
  right_inv φ := by
    ext b
    simp [lift_of_right_inverse_aux, hf b]
#align monoid_hom.lift_of_right_inverse MonoidHom.liftOfRightInverse
#align add_monoid_hom.lift_of_right_inverse AddMonoidHom.liftOfRightInverse

/- warning: monoid_hom.lift_of_surjective -> MonoidHom.liftOfSurjective is a dubious translation:
lean 3 declaration is
  forall {G₁ : Type.{u1}} {G₂ : Type.{u2}} {G₃ : Type.{u3}} [_inst_4 : Group.{u1} G₁] [_inst_5 : Group.{u2} G₂] [_inst_6 : Group.{u3} G₃] (f : MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))), (Function.Surjective.{succ u1, succ u2} G₁ G₂ (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (fun (_x : MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) => G₁ -> G₂) (MonoidHom.hasCoeToFun.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) f)) -> (Equiv.{max 1 (succ u3) (succ u1), max (succ u3) (succ u2)} (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g))) (MonoidHom.{u2, u3} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))))
but is expected to have type
  forall {G₁ : Type.{u1}} {G₂ : Type.{u2}} {G₃ : Type.{u3}} [_inst_4 : Group.{u1} G₁] [_inst_5 : Group.{u2} G₂] [_inst_6 : Group.{u3} G₃] (f : MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))), (Function.Surjective.{succ u1, succ u2} G₁ G₂ (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ (fun (_x : G₁) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₁) => G₂) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ G₂ (MulOneClass.toMul.{u1} G₁ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4)))) (MulOneClass.toMul.{u2} G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (MonoidHom.monoidHomClass.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))))) f)) -> (Equiv.{max 1 (succ u1) (succ u3), max (succ u3) (succ u2)} (Subtype.{max (succ u1) (succ u3)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G₁ _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G₁ _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u1} G₁ _inst_4))))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g))) (MonoidHom.{u2, u3} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))))
Case conversion may be inaccurate. Consider using '#align monoid_hom.lift_of_surjective MonoidHom.liftOfSurjectiveₓ'. -/
/-- A non-computable version of `monoid_hom.lift_of_right_inverse` for when no computable right
inverse is available, that uses `function.surj_inv`. -/
@[simp,
  to_additive
      "A non-computable version of `add_monoid_hom.lift_of_right_inverse` for when no\ncomputable right inverse is available."]
noncomputable abbrev liftOfSurjective (hf : Function.Surjective f) :
    { g : G₁ →* G₃ // f.ker ≤ g.ker } ≃ (G₂ →* G₃) :=
  f.liftOfRightInverse (Function.surjInv hf) (Function.rightInverse_surjInv hf)
#align monoid_hom.lift_of_surjective MonoidHom.liftOfSurjective
#align add_monoid_hom.lift_of_surjective AddMonoidHom.liftOfSurjective

/- warning: monoid_hom.lift_of_right_inverse_comp_apply -> MonoidHom.liftOfRightInverse_comp_apply is a dubious translation:
lean 3 declaration is
  forall {G₁ : Type.{u1}} {G₂ : Type.{u2}} {G₃ : Type.{u3}} [_inst_4 : Group.{u1} G₁] [_inst_5 : Group.{u2} G₂] [_inst_6 : Group.{u3} G₃] (f : MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (f_inv : G₂ -> G₁) (hf : Function.RightInverse.{succ u1, succ u2} G₁ G₂ f_inv (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (fun (_x : MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) => G₁ -> G₂) (MonoidHom.hasCoeToFun.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) f)) (g : Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g))) (x : G₁), Eq.{succ u3} G₃ (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (MonoidHom.{u2, u3} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (_x : MonoidHom.{u2, u3} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => G₂ -> G₃) (MonoidHom.hasCoeToFun.{u2, u3} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (coeFn.{max 1 (max (max 1 (succ u3) (succ u1)) (succ u3) (succ u2)) (max (succ u3) (succ u2)) 1 (succ u3) (succ u1), max (max 1 (succ u3) (succ u1)) (succ u3) (succ u2)} (Equiv.{max 1 (succ u3) (succ u1), max (succ u3) (succ u2)} (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g))) (MonoidHom.{u2, u3} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))))) (fun (_x : Equiv.{max 1 (succ u3) (succ u1), max (succ u3) (succ u2)} (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g))) (MonoidHom.{u2, u3} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))))) => (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g))) -> (MonoidHom.{u2, u3} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))))) (Equiv.hasCoeToFun.{max 1 (succ u3) (succ u1), max (succ u3) (succ u2)} (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g))) (MonoidHom.{u2, u3} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))))) (MonoidHom.liftOfRightInverse.{u1, u2, u3} G₁ G₂ G₃ _inst_4 _inst_5 _inst_6 f f_inv hf) g) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (fun (_x : MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) => G₁ -> G₂) (MonoidHom.hasCoeToFun.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) f x)) (coeFn.{max 1 (succ u3) (succ u1), max (succ u1) (succ u3)} (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g))) (fun (x : Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g))) => G₁ -> G₃) (coeFnTrans.{max (succ u1) (succ u3), max 1 (succ u3) (succ u1), max (succ u3) (succ u1)} (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g))) (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (_x : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => G₁ -> G₃) (MonoidHom.hasCoeToFun.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (coeBaseAux.{max 1 (succ u3) (succ u1), max (succ u3) (succ u1)} (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g))) (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (coeSubtype.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g))))) g x)
but is expected to have type
  forall {G₁ : Type.{u3}} {G₂ : Type.{u2}} {G₃ : Type.{u1}} [_inst_4 : Group.{u3} G₁] [_inst_5 : Group.{u2} G₂] [_inst_6 : Group.{u1} G₃] (f : MonoidHom.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (f_inv : G₂ -> G₁) (hf : Function.RightInverse.{succ u3, succ u2} G₁ G₂ f_inv (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (MonoidHom.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ (fun (_x : G₁) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₁) => G₂) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ G₂ (MulOneClass.toMul.{u3} G₁ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4)))) (MulOneClass.toMul.{u2} G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (MonoidHom.monoidHomClass.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))))) f)) (g : Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (fun (g : MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) => LE.le.{u3} (Subgroup.{u3} G₁ _inst_4) (Preorder.toLE.{u3} (Subgroup.{u3} G₁ _inst_4) (PartialOrder.toPreorder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Subgroup.{u3} G₁ _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u3} G₁ _inst_4))))) (MonoidHom.ker.{u3, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u3, u1} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) g))) (x : G₁), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₂) => G₃) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (MonoidHom.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ (fun (a : G₁) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₁) => G₂) a) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ G₂ (MulOneClass.toMul.{u3} G₁ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4)))) (MulOneClass.toMul.{u2} G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (MonoidHom.monoidHomClass.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))))) f x)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (fun (g : MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) => LE.le.{u3} (Subgroup.{u3} G₁ _inst_4) (Preorder.toLE.{u3} (Subgroup.{u3} G₁ _inst_4) (PartialOrder.toPreorder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Subgroup.{u3} G₁ _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u3} G₁ _inst_4))))) (MonoidHom.ker.{u3, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u3, u1} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) g))) => MonoidHom.{u2, u1} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) g) G₂ (fun (_x : G₂) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₂) => G₃) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (fun (g : MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) => LE.le.{u3} (Subgroup.{u3} G₁ _inst_4) (Preorder.toLE.{u3} (Subgroup.{u3} G₁ _inst_4) (PartialOrder.toPreorder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Subgroup.{u3} G₁ _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u3} G₁ _inst_4))))) (MonoidHom.ker.{u3, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u3, u1} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) g))) => MonoidHom.{u2, u1} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) g) G₂ G₃ (MulOneClass.toMul.{u2} G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (MulOneClass.toMul.{u1} G₃ (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (fun (g : MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) => LE.le.{u3} (Subgroup.{u3} G₁ _inst_4) (Preorder.toLE.{u3} (Subgroup.{u3} G₁ _inst_4) (PartialOrder.toPreorder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Subgroup.{u3} G₁ _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u3} G₁ _inst_4))))) (MonoidHom.ker.{u3, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u3, u1} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) g))) => MonoidHom.{u2, u1} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) g) G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) (MonoidHom.monoidHomClass.{u2, u1} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))))) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u1), max (succ u2) (succ u1)} (Equiv.{max 1 (succ u3) (succ u1), max (succ u1) (succ u2)} (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (fun (g : MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) => LE.le.{u3} (Subgroup.{u3} G₁ _inst_4) (Preorder.toLE.{u3} (Subgroup.{u3} G₁ _inst_4) (PartialOrder.toPreorder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Subgroup.{u3} G₁ _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u3} G₁ _inst_4))))) (MonoidHom.ker.{u3, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u3, u1} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) g))) (MonoidHom.{u2, u1} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))))) (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (fun (g : MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) => LE.le.{u3} (Subgroup.{u3} G₁ _inst_4) (Preorder.toLE.{u3} (Subgroup.{u3} G₁ _inst_4) (PartialOrder.toPreorder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Subgroup.{u3} G₁ _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u3} G₁ _inst_4))))) (MonoidHom.ker.{u3, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u3, u1} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) g))) (fun (_x : Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (fun (g : MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) => LE.le.{u3} (Subgroup.{u3} G₁ _inst_4) (Preorder.toLE.{u3} (Subgroup.{u3} G₁ _inst_4) (PartialOrder.toPreorder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Subgroup.{u3} G₁ _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u3} G₁ _inst_4))))) (MonoidHom.ker.{u3, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u3, u1} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) g))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (fun (g : MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) => LE.le.{u3} (Subgroup.{u3} G₁ _inst_4) (Preorder.toLE.{u3} (Subgroup.{u3} G₁ _inst_4) (PartialOrder.toPreorder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Subgroup.{u3} G₁ _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u3} G₁ _inst_4))))) (MonoidHom.ker.{u3, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u3, u1} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) g))) => MonoidHom.{u2, u1} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u1), max (succ u2) (succ u1)} (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (fun (g : MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) => LE.le.{u3} (Subgroup.{u3} G₁ _inst_4) (Preorder.toLE.{u3} (Subgroup.{u3} G₁ _inst_4) (PartialOrder.toPreorder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Subgroup.{u3} G₁ _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u3} G₁ _inst_4))))) (MonoidHom.ker.{u3, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u3, u1} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) g))) (MonoidHom.{u2, u1} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))))) (MonoidHom.liftOfRightInverse.{u3, u2, u1} G₁ G₂ G₃ _inst_4 _inst_5 _inst_6 f f_inv hf) g) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (MonoidHom.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ (fun (_x : G₁) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₁) => G₂) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ G₂ (MulOneClass.toMul.{u3} G₁ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4)))) (MulOneClass.toMul.{u2} G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (MonoidHom.monoidHomClass.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))))) f x)) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) G₁ (fun (x : G₁) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₁) => G₃) x) (MulHomClass.toFunLike.{max u3 u1, u3, u1} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) G₁ G₃ (MulOneClass.toMul.{u3} G₁ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4)))) (MulOneClass.toMul.{u1} G₃ (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (MonoidHomClass.toMulHomClass.{max u3 u1, u3, u1} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) (MonoidHom.monoidHomClass.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))))) (Subtype.val.{max (succ u3) (succ u1)} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (fun (g : MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) => LE.le.{u3} (Subgroup.{u3} G₁ _inst_4) (Preorder.toLE.{u3} (Subgroup.{u3} G₁ _inst_4) (PartialOrder.toPreorder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Subgroup.{u3} G₁ _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u3} G₁ _inst_4))))) (MonoidHom.ker.{u3, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u3, u1} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) g)) g) x)
Case conversion may be inaccurate. Consider using '#align monoid_hom.lift_of_right_inverse_comp_apply MonoidHom.liftOfRightInverse_comp_applyₓ'. -/
@[simp, to_additive]
theorem liftOfRightInverse_comp_apply (hf : Function.RightInverse f_inv f)
    (g : { g : G₁ →* G₃ // f.ker ≤ g.ker }) (x : G₁) :
    (f.liftOfRightInverse f_inv hf g) (f x) = g x :=
  f.liftOfRightInverseAux_comp_apply f_inv hf g.1 g.2 x
#align monoid_hom.lift_of_right_inverse_comp_apply MonoidHom.liftOfRightInverse_comp_apply
#align add_monoid_hom.lift_of_right_inverse_comp_apply AddMonoidHom.liftOfRightInverse_comp_apply

/- warning: monoid_hom.lift_of_right_inverse_comp -> MonoidHom.liftOfRightInverse_comp is a dubious translation:
lean 3 declaration is
  forall {G₁ : Type.{u1}} {G₂ : Type.{u2}} {G₃ : Type.{u3}} [_inst_4 : Group.{u1} G₁] [_inst_5 : Group.{u2} G₂] [_inst_6 : Group.{u3} G₃] (f : MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (f_inv : G₂ -> G₁) (hf : Function.RightInverse.{succ u1, succ u2} G₁ G₂ f_inv (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (fun (_x : MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) => G₁ -> G₂) (MonoidHom.hasCoeToFun.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) f)) (g : Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g))), Eq.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (MonoidHom.comp.{u1, u2, u3} G₁ G₂ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) (coeFn.{max 1 (max (max 1 (succ u3) (succ u1)) (succ u3) (succ u2)) (max (succ u3) (succ u2)) 1 (succ u3) (succ u1), max (max 1 (succ u3) (succ u1)) (succ u3) (succ u2)} (Equiv.{max 1 (succ u3) (succ u1), max (succ u3) (succ u2)} (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g))) (MonoidHom.{u2, u3} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))))) (fun (_x : Equiv.{max 1 (succ u3) (succ u1), max (succ u3) (succ u2)} (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g))) (MonoidHom.{u2, u3} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))))) => (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g))) -> (MonoidHom.{u2, u3} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))))) (Equiv.hasCoeToFun.{max 1 (succ u3) (succ u1), max (succ u3) (succ u2)} (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g))) (MonoidHom.{u2, u3} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))))) (MonoidHom.liftOfRightInverse.{u1, u2, u3} G₁ G₂ G₃ _inst_4 _inst_5 _inst_6 f f_inv hf) g) f) ((fun (a : Sort.{max 1 (succ u3) (succ u1)}) (b : Sort.{max (succ u3) (succ u1)}) [self : HasLiftT.{max 1 (succ u3) (succ u1), max (succ u3) (succ u1)} a b] => self.0) (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g))) (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (HasLiftT.mk.{max 1 (succ u3) (succ u1), max (succ u3) (succ u1)} (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g))) (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (CoeTCₓ.coe.{max 1 (succ u3) (succ u1), max (succ u3) (succ u1)} (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g))) (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (coeBase.{max 1 (succ u3) (succ u1), max (succ u3) (succ u1)} (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g))) (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (coeSubtype.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g)))))) g)
but is expected to have type
  forall {G₁ : Type.{u3}} {G₂ : Type.{u2}} {G₃ : Type.{u1}} [_inst_4 : Group.{u3} G₁] [_inst_5 : Group.{u2} G₂] [_inst_6 : Group.{u1} G₃] (f : MonoidHom.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (f_inv : G₂ -> G₁) (hf : Function.RightInverse.{succ u3, succ u2} G₁ G₂ f_inv (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (MonoidHom.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ (fun (_x : G₁) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₁) => G₂) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ G₂ (MulOneClass.toMul.{u3} G₁ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4)))) (MulOneClass.toMul.{u2} G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (MonoidHom.monoidHomClass.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))))) f)) (g : Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (fun (g : MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) => LE.le.{u3} (Subgroup.{u3} G₁ _inst_4) (Preorder.toLE.{u3} (Subgroup.{u3} G₁ _inst_4) (PartialOrder.toPreorder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Subgroup.{u3} G₁ _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u3} G₁ _inst_4))))) (MonoidHom.ker.{u3, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u3, u1} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) g))), Eq.{max (succ u3) (succ u1)} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (MonoidHom.comp.{u3, u2, u1} G₁ G₂ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u1), max (succ u2) (succ u1)} (Equiv.{max 1 (succ u3) (succ u1), max (succ u1) (succ u2)} (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (fun (g : MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) => LE.le.{u3} (Subgroup.{u3} G₁ _inst_4) (Preorder.toLE.{u3} (Subgroup.{u3} G₁ _inst_4) (PartialOrder.toPreorder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Subgroup.{u3} G₁ _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u3} G₁ _inst_4))))) (MonoidHom.ker.{u3, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u3, u1} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) g))) (MonoidHom.{u2, u1} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))))) (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (fun (g : MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) => LE.le.{u3} (Subgroup.{u3} G₁ _inst_4) (Preorder.toLE.{u3} (Subgroup.{u3} G₁ _inst_4) (PartialOrder.toPreorder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Subgroup.{u3} G₁ _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u3} G₁ _inst_4))))) (MonoidHom.ker.{u3, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u3, u1} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) g))) (fun (_x : Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (fun (g : MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) => LE.le.{u3} (Subgroup.{u3} G₁ _inst_4) (Preorder.toLE.{u3} (Subgroup.{u3} G₁ _inst_4) (PartialOrder.toPreorder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Subgroup.{u3} G₁ _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u3} G₁ _inst_4))))) (MonoidHom.ker.{u3, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u3, u1} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) g))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (fun (g : MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) => LE.le.{u3} (Subgroup.{u3} G₁ _inst_4) (Preorder.toLE.{u3} (Subgroup.{u3} G₁ _inst_4) (PartialOrder.toPreorder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Subgroup.{u3} G₁ _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u3} G₁ _inst_4))))) (MonoidHom.ker.{u3, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u3, u1} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) g))) => MonoidHom.{u2, u1} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u1), max (succ u2) (succ u1)} (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (fun (g : MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) => LE.le.{u3} (Subgroup.{u3} G₁ _inst_4) (Preorder.toLE.{u3} (Subgroup.{u3} G₁ _inst_4) (PartialOrder.toPreorder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Subgroup.{u3} G₁ _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u3} G₁ _inst_4))))) (MonoidHom.ker.{u3, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u3, u1} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) g))) (MonoidHom.{u2, u1} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))))) (MonoidHom.liftOfRightInverse.{u3, u2, u1} G₁ G₂ G₃ _inst_4 _inst_5 _inst_6 f f_inv hf) g) f) (Subtype.val.{max (succ u3) (succ u1)} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (fun (g : MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) => LE.le.{u3} (Subgroup.{u3} G₁ _inst_4) (Preorder.toLE.{u3} (Subgroup.{u3} G₁ _inst_4) (PartialOrder.toPreorder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Subgroup.{u3} G₁ _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u3} G₁ _inst_4))))) (MonoidHom.ker.{u3, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u3, u1} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) g)) g)
Case conversion may be inaccurate. Consider using '#align monoid_hom.lift_of_right_inverse_comp MonoidHom.liftOfRightInverse_compₓ'. -/
@[simp, to_additive]
theorem liftOfRightInverse_comp (hf : Function.RightInverse f_inv f)
    (g : { g : G₁ →* G₃ // f.ker ≤ g.ker }) : (f.liftOfRightInverse f_inv hf g).comp f = g :=
  MonoidHom.ext <| f.liftOfRightInverse_comp_apply f_inv hf g
#align monoid_hom.lift_of_right_inverse_comp MonoidHom.liftOfRightInverse_comp
#align add_monoid_hom.lift_of_right_inverse_comp AddMonoidHom.liftOfRightInverse_comp

/- warning: monoid_hom.eq_lift_of_right_inverse -> MonoidHom.eq_liftOfRightInverse is a dubious translation:
lean 3 declaration is
  forall {G₁ : Type.{u1}} {G₂ : Type.{u2}} {G₃ : Type.{u3}} [_inst_4 : Group.{u1} G₁] [_inst_5 : Group.{u2} G₂] [_inst_6 : Group.{u3} G₃] (f : MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (f_inv : G₂ -> G₁) (hf : Function.RightInverse.{succ u1, succ u2} G₁ G₂ f_inv (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (fun (_x : MonoidHom.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) => G₁ -> G₂) (MonoidHom.hasCoeToFun.{u1, u2} G₁ G₂ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) f)) (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (hg : LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g)) (h : MonoidHom.{u2, u3} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))), (Eq.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (MonoidHom.comp.{u1, u2, u3} G₁ G₂ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) h f) g) -> (Eq.{max (succ u3) (succ u2)} (MonoidHom.{u2, u3} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) h (coeFn.{max 1 (max (max 1 (succ u3) (succ u1)) (succ u3) (succ u2)) (max (succ u3) (succ u2)) 1 (succ u3) (succ u1), max (max 1 (succ u3) (succ u1)) (succ u3) (succ u2)} (Equiv.{max 1 (succ u3) (succ u1), max (succ u3) (succ u2)} (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g))) (MonoidHom.{u2, u3} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))))) (fun (_x : Equiv.{max 1 (succ u3) (succ u1), max (succ u3) (succ u2)} (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g))) (MonoidHom.{u2, u3} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))))) => (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g))) -> (MonoidHom.{u2, u3} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))))) (Equiv.hasCoeToFun.{max 1 (succ u3) (succ u1), max (succ u3) (succ u2)} (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g))) (MonoidHom.{u2, u3} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))))) (MonoidHom.liftOfRightInverse.{u1, u2, u3} G₁ G₂ G₃ _inst_4 _inst_5 _inst_6 f f_inv hf) (Subtype.mk.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) (fun (g : MonoidHom.{u1, u3} G₁ G₃ (Monoid.toMulOneClass.{u1} G₁ (DivInvMonoid.toMonoid.{u1} G₁ (Group.toDivInvMonoid.{u1} G₁ _inst_4))) (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6)))) => LE.le.{u1} (Subgroup.{u1} G₁ _inst_4) (Preorder.toLE.{u1} (Subgroup.{u1} G₁ _inst_4) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G₁ _inst_4) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G₁ _inst_4) G₁ (Subgroup.setLike.{u1} G₁ _inst_4)))) (MonoidHom.ker.{u1, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u1, u3} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u3} G₃ (DivInvMonoid.toMonoid.{u3} G₃ (Group.toDivInvMonoid.{u3} G₃ _inst_6))) g)) g hg)))
but is expected to have type
  forall {G₁ : Type.{u3}} {G₂ : Type.{u2}} {G₃ : Type.{u1}} [_inst_4 : Group.{u3} G₁] [_inst_5 : Group.{u2} G₂] [_inst_6 : Group.{u1} G₃] (f : MonoidHom.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (f_inv : G₂ -> G₁) (hf : Function.RightInverse.{succ u3, succ u2} G₁ G₂ f_inv (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (MonoidHom.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ (fun (_x : G₁) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₁) => G₂) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ G₂ (MulOneClass.toMul.{u3} G₁ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4)))) (MulOneClass.toMul.{u2} G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))) G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (MonoidHom.monoidHomClass.{u3, u2} G₁ G₂ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5)))))) f)) (g : MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (hg : LE.le.{u3} (Subgroup.{u3} G₁ _inst_4) (Preorder.toLE.{u3} (Subgroup.{u3} G₁ _inst_4) (PartialOrder.toPreorder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Subgroup.{u3} G₁ _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u3} G₁ _inst_4))))) (MonoidHom.ker.{u3, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u3, u1} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) g)) (h : MonoidHom.{u2, u1} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))), (Eq.{max (succ u3) (succ u1)} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (MonoidHom.comp.{u3, u2, u1} G₁ G₂ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) h f) g) -> (Eq.{max (succ u2) (succ u1)} (MonoidHom.{u2, u1} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) h (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u1), max (succ u2) (succ u1)} (Equiv.{max 1 (succ u3) (succ u1), max (succ u1) (succ u2)} (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (fun (g : MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) => LE.le.{u3} (Subgroup.{u3} G₁ _inst_4) (Preorder.toLE.{u3} (Subgroup.{u3} G₁ _inst_4) (PartialOrder.toPreorder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Subgroup.{u3} G₁ _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u3} G₁ _inst_4))))) (MonoidHom.ker.{u3, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u3, u1} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) g))) (MonoidHom.{u2, u1} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))))) (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (fun (g : MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) => LE.le.{u3} (Subgroup.{u3} G₁ _inst_4) (Preorder.toLE.{u3} (Subgroup.{u3} G₁ _inst_4) (PartialOrder.toPreorder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Subgroup.{u3} G₁ _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u3} G₁ _inst_4))))) (MonoidHom.ker.{u3, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u3, u1} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) g))) (fun (_x : Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (fun (g : MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) => LE.le.{u3} (Subgroup.{u3} G₁ _inst_4) (Preorder.toLE.{u3} (Subgroup.{u3} G₁ _inst_4) (PartialOrder.toPreorder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Subgroup.{u3} G₁ _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u3} G₁ _inst_4))))) (MonoidHom.ker.{u3, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u3, u1} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) g))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (fun (g : MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) => LE.le.{u3} (Subgroup.{u3} G₁ _inst_4) (Preorder.toLE.{u3} (Subgroup.{u3} G₁ _inst_4) (PartialOrder.toPreorder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Subgroup.{u3} G₁ _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u3} G₁ _inst_4))))) (MonoidHom.ker.{u3, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u3, u1} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) g))) => MonoidHom.{u2, u1} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u1), max (succ u2) (succ u1)} (Subtype.{max (succ u3) (succ u1)} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (fun (g : MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) => LE.le.{u3} (Subgroup.{u3} G₁ _inst_4) (Preorder.toLE.{u3} (Subgroup.{u3} G₁ _inst_4) (PartialOrder.toPreorder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Subgroup.{u3} G₁ _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u3} G₁ _inst_4))))) (MonoidHom.ker.{u3, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u3, u1} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) g))) (MonoidHom.{u2, u1} G₂ G₃ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))))) (MonoidHom.liftOfRightInverse.{u3, u2, u1} G₁ G₂ G₃ _inst_4 _inst_5 _inst_6 f f_inv hf) (Subtype.mk.{max (succ u3) (succ u1)} (MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) (fun (g : MonoidHom.{u3, u1} G₁ G₃ (Monoid.toMulOneClass.{u3} G₁ (DivInvMonoid.toMonoid.{u3} G₁ (Group.toDivInvMonoid.{u3} G₁ _inst_4))) (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6)))) => LE.le.{u3} (Subgroup.{u3} G₁ _inst_4) (Preorder.toLE.{u3} (Subgroup.{u3} G₁ _inst_4) (PartialOrder.toPreorder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u3} (Subgroup.{u3} G₁ _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Subgroup.{u3} G₁ _inst_4) (Subgroup.instCompleteLatticeSubgroup.{u3} G₁ _inst_4))))) (MonoidHom.ker.{u3, u2} G₁ _inst_4 G₂ (Monoid.toMulOneClass.{u2} G₂ (DivInvMonoid.toMonoid.{u2} G₂ (Group.toDivInvMonoid.{u2} G₂ _inst_5))) f) (MonoidHom.ker.{u3, u1} G₁ _inst_4 G₃ (Monoid.toMulOneClass.{u1} G₃ (DivInvMonoid.toMonoid.{u1} G₃ (Group.toDivInvMonoid.{u1} G₃ _inst_6))) g)) g hg)))
Case conversion may be inaccurate. Consider using '#align monoid_hom.eq_lift_of_right_inverse MonoidHom.eq_liftOfRightInverseₓ'. -/
@[to_additive]
theorem eq_liftOfRightInverse (hf : Function.RightInverse f_inv f) (g : G₁ →* G₃)
    (hg : f.ker ≤ g.ker) (h : G₂ →* G₃) (hh : h.comp f = g) :
    h = f.liftOfRightInverse f_inv hf ⟨g, hg⟩ :=
  by
  simp_rw [← hh]
  exact ((f.lift_of_right_inverse f_inv hf).apply_symm_apply _).symm
#align monoid_hom.eq_lift_of_right_inverse MonoidHom.eq_liftOfRightInverse
#align add_monoid_hom.eq_lift_of_right_inverse AddMonoidHom.eq_liftOfRightInverse

end MonoidHom

variable {N : Type _} [Group N]

#print Subgroup.Normal.comap /-
-- Here `H.normal` is an explicit argument so we can use dot notation with `comap`.
@[to_additive]
theorem Subgroup.Normal.comap {H : Subgroup N} (hH : H.Normal) (f : G →* N) : (H.comap f).Normal :=
  ⟨fun _ => by simp (config := { contextual := true }) [Subgroup.mem_comap, hH.conj_mem]⟩
#align subgroup.normal.comap Subgroup.Normal.comap
#align add_subgroup.normal.comap AddSubgroup.Normal.comap
-/

#print Subgroup.normal_comap /-
@[to_additive]
instance (priority := 100) Subgroup.normal_comap {H : Subgroup N} [nH : H.Normal] (f : G →* N) :
    (H.comap f).Normal :=
  nH.comap _
#align subgroup.normal_comap Subgroup.normal_comap
#align add_subgroup.normal_comap AddSubgroup.normal_comap
-/

/- warning: subgroup.normal.subgroup_of -> Subgroup.Normal.subgroupOf is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, (Subgroup.Normal.{u1} G _inst_1 H) -> (forall (K : Subgroup.{u1} G _inst_1), Subgroup.Normal.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K) (Subgroup.subgroupOf.{u1} G _inst_1 H K))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1}, (Subgroup.Normal.{u1} G _inst_1 H) -> (forall (K : Subgroup.{u1} G _inst_1), Subgroup.Normal.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Subgroup.toGroup.{u1} G _inst_1 K) (Subgroup.subgroupOf.{u1} G _inst_1 H K))
Case conversion may be inaccurate. Consider using '#align subgroup.normal.subgroup_of Subgroup.Normal.subgroupOfₓ'. -/
-- Here `H.normal` is an explicit argument so we can use dot notation with `subgroup_of`.
@[to_additive]
theorem Subgroup.Normal.subgroupOf {H : Subgroup G} (hH : H.Normal) (K : Subgroup G) :
    (H.subgroupOf K).Normal :=
  hH.comap _
#align subgroup.normal.subgroup_of Subgroup.Normal.subgroupOf
#align add_subgroup.normal.add_subgroup_of AddSubgroup.Normal.addSubgroupOf

/- warning: subgroup.normal_subgroup_of -> Subgroup.normal_subgroupOf is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {N : Subgroup.{u1} G _inst_1} [_inst_5 : Subgroup.Normal.{u1} G _inst_1 N], Subgroup.Normal.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H) (Subgroup.subgroupOf.{u1} G _inst_1 N H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {N : Subgroup.{u1} G _inst_1} [_inst_5 : Subgroup.Normal.{u1} G _inst_1 N], Subgroup.Normal.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H) (Subgroup.subgroupOf.{u1} G _inst_1 N H)
Case conversion may be inaccurate. Consider using '#align subgroup.normal_subgroup_of Subgroup.normal_subgroupOfₓ'. -/
@[to_additive]
instance (priority := 100) Subgroup.normal_subgroupOf {H N : Subgroup G} [N.Normal] :
    (N.subgroupOf H).Normal :=
  Subgroup.normal_comap _
#align subgroup.normal_subgroup_of Subgroup.normal_subgroupOf
#align add_subgroup.normal_add_subgroup_of AddSubgroup.normal_addSubgroupOf

namespace MonoidHom

/- warning: monoid_hom.subgroup_comap -> MonoidHom.subgroupComap is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} {G' : Type.{u2}} [_inst_1 : Group.{u1} G] [_inst_2 : Group.{u2} G'] (f : MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (H' : Subgroup.{u2} G' _inst_2), MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.comap.{u1, u2} G _inst_1 G' _inst_2 f H')) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) H') (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.comap.{u1, u2} G _inst_1 G' _inst_2 f H')) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.comap.{u1, u2} G _inst_1 G' _inst_2 f H')) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Subgroup.comap.{u1, u2} G _inst_1 G' _inst_2 f H')) (Subgroup.toGroup.{u1} G _inst_1 (Subgroup.comap.{u1, u2} G _inst_1 G' _inst_2 f H'))))) (Monoid.toMulOneClass.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) H') (DivInvMonoid.toMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) H') (Group.toDivInvMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) H') (Subgroup.toGroup.{u2} G' _inst_2 H'))))
but is expected to have type
  forall {G : Type.{u1}} {G' : Type.{u2}} [_inst_1 : Group.{u1} G] [_inst_2 : Group.{u2} G'] (f : MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (H' : Subgroup.{u2} G' _inst_2), MonoidHom.{u1, u2} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.comap.{u1, u2} G _inst_1 G' _inst_2 f H'))) (Subtype.{succ u2} G' (fun (x : G') => Membership.mem.{u2, u2} G' (Subgroup.{u2} G' _inst_2) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u2} G' _inst_2)) x H')) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (Subgroup.comap.{u1, u2} G _inst_1 G' _inst_2 f H'))) (Submonoid.toMulOneClass.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (Subgroup.toSubmonoid.{u2} G' _inst_2 H'))
Case conversion may be inaccurate. Consider using '#align monoid_hom.subgroup_comap MonoidHom.subgroupComapₓ'. -/
/-- The `monoid_hom` from the preimage of a subgroup to itself. -/
@[to_additive "the `add_monoid_hom` from the preimage of an additive subgroup to itself.", simps]
def subgroupComap (f : G →* G') (H' : Subgroup G') : H'.comap f →* H' :=
  f.submonoidComap H'.toSubmonoid
#align monoid_hom.subgroup_comap MonoidHom.subgroupComap
#align add_monoid_hom.add_subgroup_comap AddMonoidHom.addSubgroupComap

/- warning: monoid_hom.subgroup_map -> MonoidHom.subgroupMap is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} {G' : Type.{u2}} [_inst_1 : Group.{u1} G] [_inst_2 : Group.{u2} G'] (f : MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (H : Subgroup.{u1} G _inst_1), MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f H)) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))) (Monoid.toMulOneClass.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f H)) (DivInvMonoid.toMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f H)) (Group.toDivInvMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f H)) (Subgroup.toGroup.{u2} G' _inst_2 (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f H)))))
but is expected to have type
  forall {G : Type.{u1}} {G' : Type.{u2}} [_inst_1 : Group.{u1} G] [_inst_2 : Group.{u2} G'] (f : MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (H : Subgroup.{u1} G _inst_1), MonoidHom.{u1, u2} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subtype.{succ u2} G' (fun (x : G') => Membership.mem.{u2, u2} G' (Subgroup.{u2} G' _inst_2) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u2} G' _inst_2)) x (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f H))) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 H)) (Submonoid.toMulOneClass.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (Subgroup.toSubmonoid.{u2} G' _inst_2 (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f H)))
Case conversion may be inaccurate. Consider using '#align monoid_hom.subgroup_map MonoidHom.subgroupMapₓ'. -/
/-- The `monoid_hom` from a subgroup to its image. -/
@[to_additive "the `add_monoid_hom` from an additive subgroup to its image", simps]
def subgroupMap (f : G →* G') (H : Subgroup G) : H →* H.map f :=
  f.submonoidMap H.toSubmonoid
#align monoid_hom.subgroup_map MonoidHom.subgroupMap
#align add_monoid_hom.add_subgroup_map AddMonoidHom.addSubgroupMap

/- warning: monoid_hom.subgroup_map_surjective -> MonoidHom.subgroupMap_surjective is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} {G' : Type.{u2}} [_inst_1 : Group.{u1} G] [_inst_2 : Group.{u2} G'] (f : MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (H : Subgroup.{u1} G _inst_1), Function.Surjective.{succ u1, succ u2} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f H)) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f H)) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))) (Monoid.toMulOneClass.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f H)) (DivInvMonoid.toMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f H)) (Group.toDivInvMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f H)) (Subgroup.toGroup.{u2} G' _inst_2 (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f H)))))) (fun (_x : MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f H)) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))) (Monoid.toMulOneClass.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f H)) (DivInvMonoid.toMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f H)) (Group.toDivInvMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f H)) (Subgroup.toGroup.{u2} G' _inst_2 (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f H)))))) => (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) -> (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f H))) (MonoidHom.hasCoeToFun.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f H)) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))) (Monoid.toMulOneClass.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f H)) (DivInvMonoid.toMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f H)) (Group.toDivInvMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f H)) (Subgroup.toGroup.{u2} G' _inst_2 (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f H)))))) (MonoidHom.subgroupMap.{u1, u2} G G' _inst_1 _inst_2 f H))
but is expected to have type
  forall {G : Type.{u2}} {G' : Type.{u1}} [_inst_1 : Group.{u2} G] [_inst_2 : Group.{u1} G'] (f : MonoidHom.{u2, u1} G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) (H : Subgroup.{u2} G _inst_1), Function.Surjective.{succ u2, succ u1} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 f H))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 f H))) (Submonoid.toMulOneClass.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Subgroup.toSubmonoid.{u2} G _inst_1 H)) (Submonoid.toMulOneClass.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (Subgroup.toSubmonoid.{u1} G' _inst_2 (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 f H)))) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (fun (_x : Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) => Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 f H))) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 f H))) (Submonoid.toMulOneClass.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Subgroup.toSubmonoid.{u2} G _inst_1 H)) (Submonoid.toMulOneClass.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (Subgroup.toSubmonoid.{u1} G' _inst_2 (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 f H)))) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 f H))) (MulOneClass.toMul.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Submonoid.toMulOneClass.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Subgroup.toSubmonoid.{u2} G _inst_1 H))) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 f H))) (Submonoid.toMulOneClass.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (Subgroup.toSubmonoid.{u1} G' _inst_2 (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 f H)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 f H))) (Submonoid.toMulOneClass.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Subgroup.toSubmonoid.{u2} G _inst_1 H)) (Submonoid.toMulOneClass.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (Subgroup.toSubmonoid.{u1} G' _inst_2 (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 f H)))) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 f H))) (Submonoid.toMulOneClass.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Subgroup.toSubmonoid.{u2} G _inst_1 H)) (Submonoid.toMulOneClass.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (Subgroup.toSubmonoid.{u1} G' _inst_2 (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 f H))) (MonoidHom.monoidHomClass.{u2, u1} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 f H))) (Submonoid.toMulOneClass.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Subgroup.toSubmonoid.{u2} G _inst_1 H)) (Submonoid.toMulOneClass.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (Subgroup.toSubmonoid.{u1} G' _inst_2 (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 f H)))))) (MonoidHom.subgroupMap.{u2, u1} G G' _inst_1 _inst_2 f H))
Case conversion may be inaccurate. Consider using '#align monoid_hom.subgroup_map_surjective MonoidHom.subgroupMap_surjectiveₓ'. -/
@[to_additive]
theorem subgroupMap_surjective (f : G →* G') (H : Subgroup G) :
    Function.Surjective (f.subgroupMap H) :=
  f.submonoidMap_surjective H.toSubmonoid
#align monoid_hom.subgroup_map_surjective MonoidHom.subgroupMap_surjective
#align add_monoid_hom.add_subgroup_map_surjective AddMonoidHom.addSubgroupMap_surjective

end MonoidHom

namespace MulEquiv

variable {H K : Subgroup G}

/- warning: mul_equiv.subgroup_congr -> MulEquiv.subgroupCongr is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1}, (Eq.{succ u1} (Subgroup.{u1} G _inst_1) H K) -> (MulEquiv.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.mul.{u1} G _inst_1 H) (Subgroup.mul.{u1} G _inst_1 K))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1}, (Eq.{succ u1} (Subgroup.{u1} G _inst_1) H K) -> (MulEquiv.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Subgroup.mul.{u1} G _inst_1 H) (Subgroup.mul.{u1} G _inst_1 K))
Case conversion may be inaccurate. Consider using '#align mul_equiv.subgroup_congr MulEquiv.subgroupCongrₓ'. -/
/-- Makes the identity isomorphism from a proof two subgroups of a multiplicative
    group are equal. -/
@[to_additive
      "Makes the identity additive isomorphism from a proof\ntwo subgroups of an additive group are equal."]
def subgroupCongr (h : H = K) : H ≃* K :=
  { Equiv.setCongr <| congr_arg _ h with map_mul' := fun _ _ => rfl }
#align mul_equiv.subgroup_congr MulEquiv.subgroupCongr
#align add_equiv.add_subgroup_congr AddEquiv.addSubgroupCongr

/- warning: mul_equiv.subgroup_map -> MulEquiv.subgroupMap is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} {G' : Type.{u2}} [_inst_1 : Group.{u1} G] [_inst_2 : Group.{u2} G'] (e : MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (H : Subgroup.{u1} G _inst_1), MulEquiv.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) (Subgroup.mul.{u1} G _inst_1 H) (Subgroup.mul.{u2} G' _inst_2 (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H))
but is expected to have type
  forall {G : Type.{u1}} {G' : Type.{u2}} [_inst_1 : Group.{u1} G] [_inst_2 : Group.{u2} G'] (e : MulEquiv.{u1, u2} G G' (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (H : Subgroup.{u1} G _inst_1), MulEquiv.{u1, u2} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subtype.{succ u2} G' (fun (x : G') => Membership.mem.{u2, u2} G' (Subgroup.{u2} G' _inst_2) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u2} G' _inst_2)) x (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u1, u2} G G' (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))))) e) H))) (Subgroup.mul.{u1} G _inst_1 H) (Subgroup.mul.{u2} G' _inst_2 (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u1, u2} G G' (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))))) e) H))
Case conversion may be inaccurate. Consider using '#align mul_equiv.subgroup_map MulEquiv.subgroupMapₓ'. -/
/-- A subgroup is isomorphic to its image under an isomorphism. If you only have an injective map,
use `subgroup.equiv_map_of_injective`. -/
@[to_additive
      "An additive subgroup is isomorphic to its image under an an isomorphism. If you only\nhave an injective map, use `add_subgroup.equiv_map_of_injective`."]
def subgroupMap (e : G ≃* G') (H : Subgroup G) : H ≃* H.map (e : G →* G') :=
  MulEquiv.submonoidMap (e : G ≃* G') H.toSubmonoid
#align mul_equiv.subgroup_map MulEquiv.subgroupMap
#align add_equiv.add_subgroup_map AddEquiv.addSubgroupMap

/- warning: mul_equiv.coe_subgroup_map_apply -> MulEquiv.coe_subgroupMap_apply is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} {G' : Type.{u2}} [_inst_1 : Group.{u1} G] [_inst_2 : Group.{u2} G'] (e : MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (H : Subgroup.{u1} G _inst_1) (g : coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H), Eq.{succ u2} G' ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (coeSubtype.{succ u2} G' (fun (x : G') => Membership.Mem.{u2, u2} G' (Subgroup.{u2} G' _inst_2) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) x (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (MulEquiv.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) (Subgroup.mul.{u1} G _inst_1 H) (Subgroup.mul.{u2} G' _inst_2 (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H))) (fun (_x : MulEquiv.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) (Subgroup.mul.{u1} G _inst_1 H) (Subgroup.mul.{u2} G' _inst_2 (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H))) => (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) -> (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H))) (MulEquiv.hasCoeToFun.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) (Subgroup.mul.{u1} G _inst_1 H) (Subgroup.mul.{u2} G' _inst_2 (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H))) (MulEquiv.subgroupMap.{u1, u2} G G' _inst_1 _inst_2 e H) g)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (fun (_x : MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) => G -> G') (MulEquiv.hasCoeToFun.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) e ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H))))) g))
but is expected to have type
  forall {G : Type.{u2}} {G' : Type.{u1}} [_inst_1 : Group.{u2} G] [_inst_2 : Group.{u1} G'] (e : MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (H : Subgroup.{u2} G _inst_1) (g : Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)), Eq.{succ u1} G' (Subtype.val.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Set.{u1} G') (Set.instMembershipSet.{u1} G') x (SetLike.coe.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2) (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulEquiv.{u2, u1} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (Subgroup.mul.{u2} G _inst_1 H) (Subgroup.mul.{u1} G' _inst_2 (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (fun (_x : Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) => Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (Subgroup.mul.{u2} G _inst_1 H) (Subgroup.mul.{u1} G' _inst_2 (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (MulOneClass.toMul.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Submonoid.toMulOneClass.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Subgroup.toSubmonoid.{u2} G _inst_1 H))) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (Submonoid.toMulOneClass.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (Subgroup.toSubmonoid.{u1} G' _inst_2 (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (Subgroup.mul.{u2} G _inst_1 H) (Subgroup.mul.{u1} G' _inst_2 (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (Submonoid.toMulOneClass.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Subgroup.toSubmonoid.{u2} G _inst_1 H)) (Submonoid.toMulOneClass.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (Subgroup.toSubmonoid.{u1} G' _inst_2 (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (Subgroup.mul.{u2} G _inst_1 H) (Subgroup.mul.{u1} G' _inst_2 (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (Submonoid.toMulOneClass.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Subgroup.toSubmonoid.{u2} G _inst_1 H)) (Submonoid.toMulOneClass.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (Subgroup.toSubmonoid.{u1} G' _inst_2 (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (Subgroup.mul.{u2} G _inst_1 H) (Subgroup.mul.{u1} G' _inst_2 (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H)))))) (MulEquiv.subgroupMap.{u2, u1} G G' _inst_1 _inst_2 e H) g)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => G') _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))))) e (Subtype.val.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Set.{u2} G) (Set.instMembershipSet.{u2} G) x (SetLike.coe.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1) H)) g))
Case conversion may be inaccurate. Consider using '#align mul_equiv.coe_subgroup_map_apply MulEquiv.coe_subgroupMap_applyₓ'. -/
@[simp, to_additive]
theorem coe_subgroupMap_apply (e : G ≃* G') (H : Subgroup G) (g : H) :
    ((subgroupMap e H g : H.map (e : G →* G')) : G') = e g :=
  rfl
#align mul_equiv.coe_subgroup_map_apply MulEquiv.coe_subgroupMap_apply
#align add_equiv.coe_add_subgroup_map_apply AddEquiv.coe_addSubgroupMap_apply

/- warning: mul_equiv.subgroup_map_symm_apply -> MulEquiv.subgroupMap_symm_apply is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} {G' : Type.{u2}} [_inst_1 : Group.{u1} G] [_inst_2 : Group.{u2} G'] (e : MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (H : Subgroup.{u1} G _inst_1) (g : coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)), Eq.{succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (MulEquiv.{u2, u1} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.mul.{u2} G' _inst_2 (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) (Subgroup.mul.{u1} G _inst_1 H)) (fun (_x : MulEquiv.{u2, u1} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.mul.{u2} G' _inst_2 (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) (Subgroup.mul.{u1} G _inst_1 H)) => (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) -> (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H)) (MulEquiv.hasCoeToFun.{u2, u1} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.mul.{u2} G' _inst_2 (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) (Subgroup.mul.{u1} G _inst_1 H)) (MulEquiv.symm.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) (Subgroup.mul.{u1} G _inst_1 H) (Subgroup.mul.{u2} G' _inst_2 (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) (MulEquiv.subgroupMap.{u1, u2} G G' _inst_1 _inst_2 e H)) g) (Subtype.mk.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (MulEquiv.{u2, u1} G' G (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (fun (_x : MulEquiv.{u2, u1} G' G (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) => G' -> G) (MulEquiv.hasCoeToFun.{u2, u1} G' G (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulEquiv.symm.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) e) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (coeSubtype.{succ u2} G' (fun (x : G') => Membership.Mem.{u2, u2} G' (Subgroup.{u2} G' _inst_2) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) x (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)))))) g)) (Iff.mp (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (MulEquiv.{u2, u1} G' G (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (fun (_x : MulEquiv.{u2, u1} G' G (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) => G' -> G) (MulEquiv.hasCoeToFun.{u2, u1} G' G (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulEquiv.symm.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) e) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (coeSubtype.{succ u2} G' (fun (x : G') => Membership.Mem.{u2, u2} G' (Subgroup.{u2} G' _inst_2) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) x (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)))))) g)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H)) (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (MulEquiv.{u2, u1} G' G (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (fun (_x : MulEquiv.{u2, u1} G' G (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) => G' -> G) (MulEquiv.hasCoeToFun.{u2, u1} G' G (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulEquiv.symm.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) e) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (coeSubtype.{succ u2} G' (fun (x : G') => Membership.Mem.{u2, u2} G' (Subgroup.{u2} G' _inst_2) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) x (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)))))) g)) H) (SetLike.mem_coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1) H (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (MulEquiv.{u2, u1} G' G (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (fun (_x : MulEquiv.{u2, u1} G' G (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) => G' -> G) (MulEquiv.hasCoeToFun.{u2, u1} G' G (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulEquiv.symm.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) e) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (coeSubtype.{succ u2} G' (fun (x : G') => Membership.Mem.{u2, u2} G' (Subgroup.{u2} G' _inst_2) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) x (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)))))) g))) (Iff.mp (Membership.Mem.{u2, u2} G' (Set.{u2} G') (Set.hasMem.{u2} G') ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (coeSubtype.{succ u2} G' (fun (x : G') => Membership.Mem.{u2, u2} G' (Subgroup.{u2} G' _inst_2) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) x (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)))))) g) (Set.image.{u1, u2} G G' (coeFn.{max 1 (max (succ u1) (succ u2)) (succ u2) (succ u1), max (succ u1) (succ u2)} (Equiv.{succ u1, succ u2} G G') (fun (_x : Equiv.{succ u1, succ u2} G G') => G -> G') (Equiv.hasCoeToFun.{succ u1, succ u2} G G') (MulEquiv.toEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) e)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H))) (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) (coeFn.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2), max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} G' G) (fun (_x : Equiv.{succ u2, succ u1} G' G) => G' -> G) (Equiv.hasCoeToFun.{succ u2, succ u1} G' G) (Equiv.symm.{succ u1, succ u2} G G' (MulEquiv.toEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) e)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (coeSubtype.{succ u2} G' (fun (x : G') => Membership.Mem.{u2, u2} G' (Subgroup.{u2} G' _inst_2) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) x (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)))))) g)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H)) (Set.mem_image_equiv.{u1, u2} G G' ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H) (MulEquiv.toEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) e) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) G' (coeSubtype.{succ u2} G' (fun (x : G') => Membership.Mem.{u2, u2} G' (Subgroup.{u2} G' _inst_2) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) x (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)))))) g)) (Subtype.property.{succ u2} G' (fun (x : G') => Membership.Mem.{u2, u2} G' (Subgroup.{u2} G' _inst_2) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) x (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) g))))
but is expected to have type
  forall {G : Type.{u2}} {G' : Type.{u1}} [_inst_1 : Group.{u2} G] [_inst_2 : Group.{u1} G'] (e : MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (H : Subgroup.{u2} G _inst_1) (g : Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) => Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) g) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (MulEquiv.{u1, u2} (Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subgroup.mul.{u1} G' _inst_2 (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H)) (Subgroup.mul.{u2} G _inst_1 H)) (Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (fun (_x : Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) => Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (MulEquiv.{u1, u2} (Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subgroup.mul.{u1} G' _inst_2 (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H)) (Subgroup.mul.{u2} G _inst_1 H)) (Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (Submonoid.toMulOneClass.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (Subgroup.toSubmonoid.{u1} G' _inst_2 (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H)))) (MulOneClass.toMul.{u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Submonoid.toMulOneClass.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Subgroup.toSubmonoid.{u2} G _inst_1 H))) (MonoidHomClass.toMulHomClass.{max u2 u1, u1, u2} (MulEquiv.{u1, u2} (Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subgroup.mul.{u1} G' _inst_2 (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H)) (Subgroup.mul.{u2} G _inst_1 H)) (Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Submonoid.toMulOneClass.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (Subgroup.toSubmonoid.{u1} G' _inst_2 (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (Submonoid.toMulOneClass.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Subgroup.toSubmonoid.{u2} G _inst_1 H)) (MulEquivClass.instMonoidHomClass.{max u2 u1, u1, u2} (MulEquiv.{u1, u2} (Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subgroup.mul.{u1} G' _inst_2 (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H)) (Subgroup.mul.{u2} G _inst_1 H)) (Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Submonoid.toMulOneClass.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (Subgroup.toSubmonoid.{u1} G' _inst_2 (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (Submonoid.toMulOneClass.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Subgroup.toSubmonoid.{u2} G _inst_1 H)) (MulEquiv.instMulEquivClassMulEquiv.{u1, u2} (Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subgroup.mul.{u1} G' _inst_2 (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H)) (Subgroup.mul.{u2} G _inst_1 H))))) (MulEquiv.symm.{u2, u1} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (Subgroup.mul.{u2} G _inst_1 H) (Subgroup.mul.{u1} G' _inst_2 (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H)) (MulEquiv.subgroupMap.{u2, u1} G G' _inst_1 _inst_2 e H)) g) (Subtype.mk.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (MulEquiv.{u1, u2} G' G (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) G' (fun (_x : G') => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G') => G) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (MulEquiv.{u1, u2} G' G (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) G' G (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u1, u2} (MulEquiv.{u1, u2} G' G (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) G' G (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u1, u2} (MulEquiv.{u1, u2} G' G (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) G' G (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (MulEquiv.instMulEquivClassMulEquiv.{u1, u2} G' G (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))))) (MulEquiv.symm.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) e) (Subtype.val.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Set.{u1} G') (Set.instMembershipSet.{u1} G') x (SetLike.coe.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2) (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) g)) (Iff.mp (Membership.mem.{u2, u2} G (Set.{u2} G) (Set.instMembershipSet.{u2} G) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (MulEquiv.{u1, u2} G' G (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) G' (fun (_x : G') => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G') => G) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (MulEquiv.{u1, u2} G' G (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) G' G (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u1, u2} (MulEquiv.{u1, u2} G' G (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) G' G (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u1, u2} (MulEquiv.{u1, u2} G' G (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) G' G (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (MulEquiv.instMulEquivClassMulEquiv.{u1, u2} G' G (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))))) (MulEquiv.symm.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) e) (Subtype.val.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Set.{u1} G') (Set.instMembershipSet.{u1} G') x (SetLike.coe.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2) (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) g)) (SetLike.coe.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1) H)) (Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (MulEquiv.{u1, u2} G' G (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) G' (fun (_x : G') => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G') => G) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (MulEquiv.{u1, u2} G' G (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) G' G (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u1, u2} (MulEquiv.{u1, u2} G' G (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) G' G (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u1, u2} (MulEquiv.{u1, u2} G' G (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) G' G (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (MulEquiv.instMulEquivClassMulEquiv.{u1, u2} G' G (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))))) (MulEquiv.symm.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) e) (Subtype.val.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Set.{u1} G') (Set.instMembershipSet.{u1} G') x (SetLike.coe.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2) (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) g)) H) (SetLike.mem_coe.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1) H (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (MulEquiv.{u1, u2} G' G (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) G' (fun (_x : G') => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G') => G) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (MulEquiv.{u1, u2} G' G (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) G' G (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u1, u2} (MulEquiv.{u1, u2} G' G (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) G' G (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u1, u2} (MulEquiv.{u1, u2} G' G (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) G' G (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (MulEquiv.instMulEquivClassMulEquiv.{u1, u2} G' G (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))))) (MulEquiv.symm.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) e) (Subtype.val.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Set.{u1} G') (Set.instMembershipSet.{u1} G') x (SetLike.coe.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2) (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) g))) (Iff.mp (Membership.mem.{u1, u1} G' (Set.{u1} G') (Set.instMembershipSet.{u1} G') (Subtype.val.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Set.{u1} G') (Set.instMembershipSet.{u1} G') x (SetLike.coe.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2) (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) g) (Set.image.{u2, u1} G G' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Equiv.{succ u2, succ u1} G G') G (fun (_x : G) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : G) => G') _x) (Equiv.instFunLikeEquiv.{succ u2, succ u1} G G') (MulEquiv.toEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) e)) (SetLike.coe.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1) H))) (Membership.mem.{u2, u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : G') => G) (Subtype.val.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Set.{u1} G') (Set.instMembershipSet.{u1} G') x (SetLike.coe.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2) (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) g)) (Set.{u2} G) (Set.instMembershipSet.{u2} G) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (Equiv.{succ u1, succ u2} G' G) G' (fun (_x : G') => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : G') => G) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u2} G' G) (Equiv.symm.{succ u2, succ u1} G G' (MulEquiv.toEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) e)) (Subtype.val.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Set.{u1} G') (Set.instMembershipSet.{u1} G') x (SetLike.coe.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2) (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) g)) (SetLike.coe.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1) H)) (Set.mem_image_equiv.{u1, u2} G G' (SetLike.coe.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1) H) (MulEquiv.toEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) e) (Subtype.val.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Set.{u1} G') (Set.instMembershipSet.{u1} G') x (SetLike.coe.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2) (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) g)) (Subtype.property.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H)) g))))
Case conversion may be inaccurate. Consider using '#align mul_equiv.subgroup_map_symm_apply MulEquiv.subgroupMap_symm_applyₓ'. -/
@[simp, to_additive]
theorem subgroupMap_symm_apply (e : G ≃* G') (H : Subgroup G) (g : H.map (e : G →* G')) :
    (e.subgroupMap H).symm g = ⟨e.symm g, SetLike.mem_coe.1 <| Set.mem_image_equiv.1 g.2⟩ :=
  rfl
#align mul_equiv.subgroup_map_symm_apply MulEquiv.subgroupMap_symm_apply
#align add_equiv.add_subgroup_map_symm_apply AddEquiv.addSubgroupMap_symm_apply

end MulEquiv

namespace Subgroup

/- warning: subgroup.equiv_map_of_injective_coe_mul_equiv -> Subgroup.equivMapOfInjective_coe_mulEquiv is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} {G' : Type.{u2}} [_inst_1 : Group.{u1} G] [_inst_2 : Group.{u2} G'] (H : Subgroup.{u1} G _inst_1) (e : MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))), Eq.{max (succ u1) (succ u2)} (MulEquiv.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G' _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H)) (Subgroup.mul.{u1} G _inst_1 H) (Subgroup.mul.{u2} G' _inst_2 (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) H))) (Subgroup.equivMapOfInjective.{u1, u2} G _inst_1 G' _inst_2 H ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} G G' (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquivClass.monoidHomClass.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))))))) e) (EquivLike.injective.{max (succ u1) (succ u2), succ u1, succ u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (MulEquivClass.toEquivLike.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))))) G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MulEquiv.mulEquivClass.{u1, u2} G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))))) e)) (MulEquiv.subgroupMap.{u1, u2} G G' _inst_1 _inst_2 e H)
but is expected to have type
  forall {G : Type.{u2}} {G' : Type.{u1}} [_inst_1 : Group.{u2} G] [_inst_2 : Group.{u1} G'] (H : Subgroup.{u2} G _inst_1) (e : MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))), Eq.{max (succ u2) (succ u1)} (MulEquiv.{u2, u1} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subtype.{succ u1} G' (fun (x : G') => Membership.mem.{u1, u1} G' (Subgroup.{u1} G' _inst_2) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G' _inst_2) G' (Subgroup.instSetLikeSubgroup.{u1} G' _inst_2)) x (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (Subgroup.mul.{u2} G _inst_1 H) (Subgroup.mul.{u1} G' _inst_2 (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) H))) (Subgroup.equivMapOfInjective.{u2, u1} G _inst_1 G' _inst_2 H (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} G G' (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquivClass.instMonoidHomClass.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e) (EquivLike.injective.{max (succ u2) (succ u1), succ u1, succ u2} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2))))) G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} G' (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))))) e)) (MulEquiv.subgroupMap.{u2, u1} G G' _inst_1 _inst_2 e H)
Case conversion may be inaccurate. Consider using '#align subgroup.equiv_map_of_injective_coe_mul_equiv Subgroup.equivMapOfInjective_coe_mulEquivₓ'. -/
@[simp, to_additive]
theorem equivMapOfInjective_coe_mulEquiv (H : Subgroup G) (e : G ≃* G') :
    H.equivMapOfInjective (e : G →* G') (EquivLike.injective e) = e.subgroupMap H :=
  by
  ext
  rfl
#align subgroup.equiv_map_of_injective_coe_mul_equiv Subgroup.equivMapOfInjective_coe_mulEquiv
#align add_subgroup.equiv_map_of_injective_coe_add_equiv AddSubgroup.equivMapOfInjective_coe_addEquiv

variable {C : Type _} [CommGroup C] {s t : Subgroup C} {x : C}

/- warning: subgroup.mem_sup -> Subgroup.mem_sup is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_5 : CommGroup.{u1} C] {s : Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)} {t : Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)} {x : C}, Iff (Membership.Mem.{u1, u1} C (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.setLike.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) x (Sup.sup.{u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (Subgroup.completeLattice.{u1} C (CommGroup.toGroup.{u1} C _inst_5))))) s t)) (Exists.{succ u1} C (fun (y : C) => Exists.{0} (Membership.Mem.{u1, u1} C (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.setLike.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) y s) (fun (H : Membership.Mem.{u1, u1} C (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.setLike.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) y s) => Exists.{succ u1} C (fun (z : C) => Exists.{0} (Membership.Mem.{u1, u1} C (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.setLike.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) z t) (fun (H : Membership.Mem.{u1, u1} C (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.setLike.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) z t) => Eq.{succ u1} C (HMul.hMul.{u1, u1, u1} C C C (instHMul.{u1} C (MulOneClass.toHasMul.{u1} C (Monoid.toMulOneClass.{u1} C (DivInvMonoid.toMonoid.{u1} C (Group.toDivInvMonoid.{u1} C (CommGroup.toGroup.{u1} C _inst_5)))))) y z) x)))))
but is expected to have type
  forall {C : Type.{u1}} [_inst_5 : CommGroup.{u1} C] {s : Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)} {t : Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)} {x : C}, Iff (Membership.mem.{u1, u1} C (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.instSetLikeSubgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) x (Sup.sup.{u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (Subgroup.instCompleteLatticeSubgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5))))) s t)) (Exists.{succ u1} C (fun (y : C) => And (Membership.mem.{u1, u1} C (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.instSetLikeSubgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) y s) (Exists.{succ u1} C (fun (z : C) => And (Membership.mem.{u1, u1} C (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.instSetLikeSubgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) z t) (Eq.{succ u1} C (HMul.hMul.{u1, u1, u1} C C C (instHMul.{u1} C (MulOneClass.toMul.{u1} C (Monoid.toMulOneClass.{u1} C (DivInvMonoid.toMonoid.{u1} C (Group.toDivInvMonoid.{u1} C (CommGroup.toGroup.{u1} C _inst_5)))))) y z) x)))))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_sup Subgroup.mem_supₓ'. -/
@[to_additive]
theorem mem_sup : x ∈ s ⊔ t ↔ ∃ y ∈ s, ∃ z ∈ t, y * z = x :=
  ⟨fun h => by
    rw [← closure_eq s, ← closure_eq t, ← closure_union] at h
    apply closure_induction h
    · rintro y (h | h)
      · exact ⟨y, h, 1, t.one_mem, by simp⟩
      · exact ⟨1, s.one_mem, y, h, by simp⟩
    · exact ⟨1, s.one_mem, 1, ⟨t.one_mem, mul_one 1⟩⟩
    · rintro _ _ ⟨y₁, hy₁, z₁, hz₁, rfl⟩ ⟨y₂, hy₂, z₂, hz₂, rfl⟩
      exact ⟨_, mul_mem hy₁ hy₂, _, mul_mem hz₁ hz₂, by simp [mul_assoc] <;> cc⟩
    · rintro _ ⟨y, hy, z, hz, rfl⟩
      exact ⟨_, inv_mem hy, _, inv_mem hz, mul_comm z y ▸ (mul_inv_rev z y).symm⟩, by
    rintro ⟨y, hy, z, hz, rfl⟩ <;> exact mul_mem_sup hy hz⟩
#align subgroup.mem_sup Subgroup.mem_sup
#align add_subgroup.mem_sup AddSubgroup.mem_sup

/- warning: subgroup.mem_sup' -> Subgroup.mem_sup' is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_5 : CommGroup.{u1} C] {s : Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)} {t : Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)} {x : C}, Iff (Membership.Mem.{u1, u1} C (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.setLike.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) x (Sup.sup.{u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (Subgroup.completeLattice.{u1} C (CommGroup.toGroup.{u1} C _inst_5))))) s t)) (Exists.{succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.setLike.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) s) (fun (y : coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.setLike.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) s) => Exists.{succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.setLike.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) t) (fun (z : coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.setLike.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) t) => Eq.{succ u1} C (HMul.hMul.{u1, u1, u1} C C C (instHMul.{u1} C (MulOneClass.toHasMul.{u1} C (Monoid.toMulOneClass.{u1} C (DivInvMonoid.toMonoid.{u1} C (Group.toDivInvMonoid.{u1} C (CommGroup.toGroup.{u1} C _inst_5)))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.setLike.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) s) C (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.setLike.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) s) C (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.setLike.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) s) C (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.setLike.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) s) C (coeSubtype.{succ u1} C (fun (x : C) => Membership.Mem.{u1, u1} C (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.setLike.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) x s))))) y) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.setLike.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) t) C (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.setLike.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) t) C (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.setLike.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) t) C (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.setLike.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) t) C (coeSubtype.{succ u1} C (fun (x : C) => Membership.Mem.{u1, u1} C (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.setLike.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) x t))))) z)) x)))
but is expected to have type
  forall {C : Type.{u1}} [_inst_5 : CommGroup.{u1} C] {s : Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)} {t : Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)} {x : C}, Iff (Membership.mem.{u1, u1} C (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.instSetLikeSubgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) x (Sup.sup.{u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (Subgroup.instCompleteLatticeSubgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5))))) s t)) (Exists.{succ u1} (Subtype.{succ u1} C (fun (x : C) => Membership.mem.{u1, u1} C (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.instSetLikeSubgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) x s)) (fun (y : Subtype.{succ u1} C (fun (x : C) => Membership.mem.{u1, u1} C (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.instSetLikeSubgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) x s)) => Exists.{succ u1} (Subtype.{succ u1} C (fun (x : C) => Membership.mem.{u1, u1} C (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.instSetLikeSubgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) x t)) (fun (z : Subtype.{succ u1} C (fun (x : C) => Membership.mem.{u1, u1} C (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.instSetLikeSubgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) x t)) => Eq.{succ u1} C (HMul.hMul.{u1, u1, u1} C C C (instHMul.{u1} C (MulOneClass.toMul.{u1} C (Monoid.toMulOneClass.{u1} C (DivInvMonoid.toMonoid.{u1} C (Group.toDivInvMonoid.{u1} C (CommGroup.toGroup.{u1} C _inst_5)))))) (Subtype.val.{succ u1} C (fun (x : C) => Membership.mem.{u1, u1} C (Set.{u1} C) (Set.instMembershipSet.{u1} C) x (SetLike.coe.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.instSetLikeSubgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) s)) y) (Subtype.val.{succ u1} C (fun (x : C) => Membership.mem.{u1, u1} C (Set.{u1} C) (Set.instMembershipSet.{u1} C) x (SetLike.coe.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.instSetLikeSubgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) t)) z)) x)))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_sup' Subgroup.mem_sup'ₓ'. -/
@[to_additive]
theorem mem_sup' : x ∈ s ⊔ t ↔ ∃ (y : s)(z : t), (y : C) * z = x :=
  mem_sup.trans <| by simp only [SetLike.exists, coe_mk]
#align subgroup.mem_sup' Subgroup.mem_sup'
#align add_subgroup.mem_sup' AddSubgroup.mem_sup'

/- warning: subgroup.mem_closure_pair -> Subgroup.mem_closure_pair is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_5 : CommGroup.{u1} C] {x : C} {y : C} {z : C}, Iff (Membership.Mem.{u1, u1} C (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.setLike.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) z (Subgroup.closure.{u1} C (CommGroup.toGroup.{u1} C _inst_5) (Insert.insert.{u1, u1} C (Set.{u1} C) (Set.hasInsert.{u1} C) x (Singleton.singleton.{u1, u1} C (Set.{u1} C) (Set.hasSingleton.{u1} C) y)))) (Exists.{1} Int (fun (m : Int) => Exists.{1} Int (fun (n : Int) => Eq.{succ u1} C (HMul.hMul.{u1, u1, u1} C C C (instHMul.{u1} C (MulOneClass.toHasMul.{u1} C (Monoid.toMulOneClass.{u1} C (DivInvMonoid.toMonoid.{u1} C (Group.toDivInvMonoid.{u1} C (CommGroup.toGroup.{u1} C _inst_5)))))) (HPow.hPow.{u1, 0, u1} C Int C (instHPow.{u1, 0} C Int (DivInvMonoid.Pow.{u1} C (Group.toDivInvMonoid.{u1} C (CommGroup.toGroup.{u1} C _inst_5)))) x m) (HPow.hPow.{u1, 0, u1} C Int C (instHPow.{u1, 0} C Int (DivInvMonoid.Pow.{u1} C (Group.toDivInvMonoid.{u1} C (CommGroup.toGroup.{u1} C _inst_5)))) y n)) z)))
but is expected to have type
  forall {C : Type.{u1}} [_inst_5 : CommGroup.{u1} C] {x : C} {y : C} {z : C}, Iff (Membership.mem.{u1, u1} C (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5)) C (Subgroup.instSetLikeSubgroup.{u1} C (CommGroup.toGroup.{u1} C _inst_5))) z (Subgroup.closure.{u1} C (CommGroup.toGroup.{u1} C _inst_5) (Insert.insert.{u1, u1} C (Set.{u1} C) (Set.instInsertSet.{u1} C) x (Singleton.singleton.{u1, u1} C (Set.{u1} C) (Set.instSingletonSet.{u1} C) y)))) (Exists.{1} Int (fun (m : Int) => Exists.{1} Int (fun (n : Int) => Eq.{succ u1} C (HMul.hMul.{u1, u1, u1} C C C (instHMul.{u1} C (MulOneClass.toMul.{u1} C (Monoid.toMulOneClass.{u1} C (DivInvMonoid.toMonoid.{u1} C (Group.toDivInvMonoid.{u1} C (CommGroup.toGroup.{u1} C _inst_5)))))) (HPow.hPow.{u1, 0, u1} C Int C (instHPow.{u1, 0} C Int (DivInvMonoid.Pow.{u1} C (Group.toDivInvMonoid.{u1} C (CommGroup.toGroup.{u1} C _inst_5)))) x m) (HPow.hPow.{u1, 0, u1} C Int C (instHPow.{u1, 0} C Int (DivInvMonoid.Pow.{u1} C (Group.toDivInvMonoid.{u1} C (CommGroup.toGroup.{u1} C _inst_5)))) y n)) z)))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_closure_pair Subgroup.mem_closure_pairₓ'. -/
@[to_additive]
theorem mem_closure_pair {x y z : C} :
    z ∈ closure ({x, y} : Set C) ↔ ∃ m n : ℤ, x ^ m * y ^ n = z :=
  by
  rw [← Set.singleton_union, Subgroup.closure_union, mem_sup]
  simp_rw [exists_prop, mem_closure_singleton, exists_exists_eq_and]
#align subgroup.mem_closure_pair Subgroup.mem_closure_pair
#align add_subgroup.mem_closure_pair AddSubgroup.mem_closure_pair

@[to_additive]
instance : IsModularLattice (Subgroup C) :=
  ⟨fun x y z xz a ha => by
    rw [mem_inf, mem_sup] at ha
    rcases ha with ⟨⟨b, hb, c, hc, rfl⟩, haz⟩
    rw [mem_sup]
    exact ⟨b, hb, c, mem_inf.2 ⟨hc, (mul_mem_cancel_left (xz hb)).1 haz⟩, rfl⟩⟩

end Subgroup

namespace Subgroup

section SubgroupNormal

/- warning: subgroup.normal_subgroup_of_iff -> Subgroup.normal_subgroupOf_iff is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1}, (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H K) -> (Iff (Subgroup.Normal.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K) (Subgroup.subgroupOf.{u1} G _inst_1 H K)) (forall (h : G) (k : G), (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) h H) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) k K) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) k h) (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) k)) H)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1}, (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) H K) -> (Iff (Subgroup.Normal.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Subgroup.toGroup.{u1} G _inst_1 K) (Subgroup.subgroupOf.{u1} G _inst_1 H K)) (forall (h : G) (k : G), (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) h H) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) k K) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) k h) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) k)) H)))
Case conversion may be inaccurate. Consider using '#align subgroup.normal_subgroup_of_iff Subgroup.normal_subgroupOf_iffₓ'. -/
@[to_additive]
theorem normal_subgroupOf_iff {H K : Subgroup G} (hHK : H ≤ K) :
    (H.subgroupOf K).Normal ↔ ∀ h k, h ∈ H → k ∈ K → k * h * k⁻¹ ∈ H :=
  ⟨fun hN h k hH hK => hN.conj_mem ⟨h, hHK hH⟩ hH ⟨k, hK⟩, fun hN =>
    { conj_mem := fun h hm k => hN h.1 k.1 hm k.2 }⟩
#align subgroup.normal_subgroup_of_iff Subgroup.normal_subgroupOf_iff
#align add_subgroup.normal_add_subgroup_of_iff AddSubgroup.normal_addSubgroupOf_iff

/- warning: subgroup.prod_subgroup_of_prod_normal -> Subgroup.prod_subgroupOf_prod_normal is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {H₁ : Subgroup.{u1} G _inst_1} {K₁ : Subgroup.{u1} G _inst_1} {H₂ : Subgroup.{u2} N _inst_4} {K₂ : Subgroup.{u2} N _inst_4} [h₁ : Subgroup.Normal.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K₁) (Subgroup.toGroup.{u1} G _inst_1 K₁) (Subgroup.subgroupOf.{u1} G _inst_1 H₁ K₁)] [h₂ : Subgroup.Normal.{u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} N _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.setLike.{u2} N _inst_4)) K₂) (Subgroup.toGroup.{u2} N _inst_4 K₂) (Subgroup.subgroupOf.{u2} N _inst_4 H₂ K₂)], Subgroup.Normal.{max u1 u2} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4)) (Prod.{u1, u2} G N) (Subgroup.setLike.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4))) (Subgroup.prod.{u1, u2} G _inst_1 N _inst_4 K₁ K₂)) (Subgroup.toGroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4) (Subgroup.prod.{u1, u2} G _inst_1 N _inst_4 K₁ K₂)) (Subgroup.subgroupOf.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4) (Subgroup.prod.{u1, u2} G _inst_1 N _inst_4 H₁ H₂) (Subgroup.prod.{u1, u2} G _inst_1 N _inst_4 K₁ K₂))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] {H₁ : Subgroup.{u1} G _inst_1} {K₁ : Subgroup.{u1} G _inst_1} {H₂ : Subgroup.{u2} N _inst_4} {K₂ : Subgroup.{u2} N _inst_4} [h₁ : Subgroup.Normal.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K₁)) (Subgroup.toGroup.{u1} G _inst_1 K₁) (Subgroup.subgroupOf.{u1} G _inst_1 H₁ K₁)] [h₂ : Subgroup.Normal.{u2} (Subtype.{succ u2} N (fun (x : N) => Membership.mem.{u2, u2} N (Subgroup.{u2} N _inst_4) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} N _inst_4) N (Subgroup.instSetLikeSubgroup.{u2} N _inst_4)) x K₂)) (Subgroup.toGroup.{u2} N _inst_4 K₂) (Subgroup.subgroupOf.{u2} N _inst_4 H₂ K₂)], Subgroup.Normal.{max u1 u2} (Subtype.{succ (max u1 u2)} (Prod.{u1, u2} G N) (fun (x : Prod.{u1, u2} G N) => Membership.mem.{max u1 u2, max u1 u2} (Prod.{u1, u2} G N) (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.instGroupProd.{u1, u2} G N _inst_1 _inst_4)) (SetLike.instMembership.{max u1 u2, max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.instGroupProd.{u1, u2} G N _inst_1 _inst_4)) (Prod.{u1, u2} G N) (Subgroup.instSetLikeSubgroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.instGroupProd.{u1, u2} G N _inst_1 _inst_4))) x (Subgroup.prod.{u1, u2} G _inst_1 N _inst_4 K₁ K₂))) (Subgroup.toGroup.{max u1 u2} (Prod.{u1, u2} G N) (Prod.instGroupProd.{u1, u2} G N _inst_1 _inst_4) (Subgroup.prod.{u1, u2} G _inst_1 N _inst_4 K₁ K₂)) (Subgroup.subgroupOf.{max u1 u2} (Prod.{u1, u2} G N) (Prod.instGroupProd.{u1, u2} G N _inst_1 _inst_4) (Subgroup.prod.{u1, u2} G _inst_1 N _inst_4 H₁ H₂) (Subgroup.prod.{u1, u2} G _inst_1 N _inst_4 K₁ K₂))
Case conversion may be inaccurate. Consider using '#align subgroup.prod_subgroup_of_prod_normal Subgroup.prod_subgroupOf_prod_normalₓ'. -/
@[to_additive]
instance prod_subgroupOf_prod_normal {H₁ K₁ : Subgroup G} {H₂ K₂ : Subgroup N}
    [h₁ : (H₁.subgroupOf K₁).Normal] [h₂ : (H₂.subgroupOf K₂).Normal] :
    ((H₁.Prod H₂).subgroupOf (K₁.Prod K₂)).Normal
    where conj_mem n hgHK g :=
    ⟨h₁.conj_mem ⟨(n : G × N).fst, (mem_prod.mp n.2).1⟩ hgHK.1
        ⟨(g : G × N).fst, (mem_prod.mp g.2).1⟩,
      h₂.conj_mem ⟨(n : G × N).snd, (mem_prod.mp n.2).2⟩ hgHK.2
        ⟨(g : G × N).snd, (mem_prod.mp g.2).2⟩⟩
#align subgroup.prod_subgroup_of_prod_normal Subgroup.prod_subgroupOf_prod_normal
#align add_subgroup.sum_add_subgroup_of_sum_normal AddSubgroup.sum_addSubgroupOf_sum_normal

/- warning: subgroup.prod_normal -> Subgroup.prod_normal is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (H : Subgroup.{u1} G _inst_1) (K : Subgroup.{u2} N _inst_4) [hH : Subgroup.Normal.{u1} G _inst_1 H] [hK : Subgroup.Normal.{u2} N _inst_4 K], Subgroup.Normal.{max u1 u2} (Prod.{u1, u2} G N) (Prod.group.{u1, u2} G N _inst_1 _inst_4) (Subgroup.prod.{u1, u2} G _inst_1 N _inst_4 H K)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Type.{u2}} [_inst_4 : Group.{u2} N] (H : Subgroup.{u1} G _inst_1) (K : Subgroup.{u2} N _inst_4) [hH : Subgroup.Normal.{u1} G _inst_1 H] [hK : Subgroup.Normal.{u2} N _inst_4 K], Subgroup.Normal.{max u1 u2} (Prod.{u1, u2} G N) (Prod.instGroupProd.{u1, u2} G N _inst_1 _inst_4) (Subgroup.prod.{u1, u2} G _inst_1 N _inst_4 H K)
Case conversion may be inaccurate. Consider using '#align subgroup.prod_normal Subgroup.prod_normalₓ'. -/
@[to_additive]
instance prod_normal (H : Subgroup G) (K : Subgroup N) [hH : H.Normal] [hK : K.Normal] :
    (H.Prod K).Normal
    where conj_mem n hg g :=
    ⟨hH.conj_mem n.fst (Subgroup.mem_prod.mp hg).1 g.fst,
      hK.conj_mem n.snd (Subgroup.mem_prod.mp hg).2 g.snd⟩
#align subgroup.prod_normal Subgroup.prod_normal
#align add_subgroup.sum_normal AddSubgroup.sum_normal

/- warning: subgroup.inf_subgroup_of_inf_normal_of_right -> Subgroup.inf_subgroupOf_inf_normal_of_right is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (A : Subgroup.{u1} G _inst_1) (B' : Subgroup.{u1} G _inst_1) (B : Subgroup.{u1} G _inst_1), (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) B' B) -> (forall [hN : Subgroup.Normal.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) B) (Subgroup.toGroup.{u1} G _inst_1 B) (Subgroup.subgroupOf.{u1} G _inst_1 B' B)], Subgroup.Normal.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasInf.{u1} G _inst_1) A B)) (Subgroup.toGroup.{u1} G _inst_1 (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasInf.{u1} G _inst_1) A B)) (Subgroup.subgroupOf.{u1} G _inst_1 (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasInf.{u1} G _inst_1) A B') (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasInf.{u1} G _inst_1) A B)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (A : Subgroup.{u1} G _inst_1) (B' : Subgroup.{u1} G _inst_1) (B : Subgroup.{u1} G _inst_1), (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) B' B) -> (forall [hN : Subgroup.Normal.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x B)) (Subgroup.toGroup.{u1} G _inst_1 B) (Subgroup.subgroupOf.{u1} G _inst_1 B' B)], Subgroup.Normal.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instInfSubgroup.{u1} G _inst_1) A B))) (Subgroup.toGroup.{u1} G _inst_1 (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instInfSubgroup.{u1} G _inst_1) A B)) (Subgroup.subgroupOf.{u1} G _inst_1 (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instInfSubgroup.{u1} G _inst_1) A B') (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instInfSubgroup.{u1} G _inst_1) A B)))
Case conversion may be inaccurate. Consider using '#align subgroup.inf_subgroup_of_inf_normal_of_right Subgroup.inf_subgroupOf_inf_normal_of_rightₓ'. -/
@[to_additive]
theorem inf_subgroupOf_inf_normal_of_right (A B' B : Subgroup G) (hB : B' ≤ B)
    [hN : (B'.subgroupOf B).Normal] : ((A ⊓ B').subgroupOf (A ⊓ B)).Normal :=
  {
    conj_mem := fun n hn g =>
      ⟨mul_mem (mul_mem (mem_inf.1 g.2).1 (mem_inf.1 n.2).1) (inv_mem (mem_inf.1 g.2).1),
        (normal_subgroupOf_iff hB).mp hN n g hn.2 (mem_inf.mp g.2).2⟩ }
#align subgroup.inf_subgroup_of_inf_normal_of_right Subgroup.inf_subgroupOf_inf_normal_of_right
#align add_subgroup.inf_add_subgroup_of_inf_normal_of_right AddSubgroup.inf_addSubgroupOf_inf_normal_of_right

/- warning: subgroup.inf_subgroup_of_inf_normal_of_left -> Subgroup.inf_subgroupOf_inf_normal_of_left is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {A' : Subgroup.{u1} G _inst_1} {A : Subgroup.{u1} G _inst_1} (B : Subgroup.{u1} G _inst_1), (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) A' A) -> (forall [hN : Subgroup.Normal.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) A) (Subgroup.toGroup.{u1} G _inst_1 A) (Subgroup.subgroupOf.{u1} G _inst_1 A' A)], Subgroup.Normal.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasInf.{u1} G _inst_1) A B)) (Subgroup.toGroup.{u1} G _inst_1 (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasInf.{u1} G _inst_1) A B)) (Subgroup.subgroupOf.{u1} G _inst_1 (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasInf.{u1} G _inst_1) A' B) (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasInf.{u1} G _inst_1) A B)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {A' : Subgroup.{u1} G _inst_1} {A : Subgroup.{u1} G _inst_1} (B : Subgroup.{u1} G _inst_1), (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) A' A) -> (forall [hN : Subgroup.Normal.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x A)) (Subgroup.toGroup.{u1} G _inst_1 A) (Subgroup.subgroupOf.{u1} G _inst_1 A' A)], Subgroup.Normal.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instInfSubgroup.{u1} G _inst_1) A B))) (Subgroup.toGroup.{u1} G _inst_1 (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instInfSubgroup.{u1} G _inst_1) A B)) (Subgroup.subgroupOf.{u1} G _inst_1 (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instInfSubgroup.{u1} G _inst_1) A' B) (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instInfSubgroup.{u1} G _inst_1) A B)))
Case conversion may be inaccurate. Consider using '#align subgroup.inf_subgroup_of_inf_normal_of_left Subgroup.inf_subgroupOf_inf_normal_of_leftₓ'. -/
@[to_additive]
theorem inf_subgroupOf_inf_normal_of_left {A' A : Subgroup G} (B : Subgroup G) (hA : A' ≤ A)
    [hN : (A'.subgroupOf A).Normal] : ((A' ⊓ B).subgroupOf (A ⊓ B)).Normal :=
  {
    conj_mem := fun n hn g =>
      ⟨(normal_subgroupOf_iff hA).mp hN n g hn.1 (mem_inf.mp g.2).1,
        mul_mem (mul_mem (mem_inf.1 g.2).2 (mem_inf.1 n.2).2) (inv_mem (mem_inf.1 g.2).2)⟩ }
#align subgroup.inf_subgroup_of_inf_normal_of_left Subgroup.inf_subgroupOf_inf_normal_of_left
#align add_subgroup.inf_add_subgroup_of_inf_normal_of_left AddSubgroup.inf_addSubgroupOf_inf_normal_of_left

/- warning: subgroup.normal_inf_normal -> Subgroup.normal_inf_normal is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (K : Subgroup.{u1} G _inst_1) [hH : Subgroup.Normal.{u1} G _inst_1 H] [hK : Subgroup.Normal.{u1} G _inst_1 K], Subgroup.Normal.{u1} G _inst_1 (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasInf.{u1} G _inst_1) H K)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (K : Subgroup.{u1} G _inst_1) [hH : Subgroup.Normal.{u1} G _inst_1 H] [hK : Subgroup.Normal.{u1} G _inst_1 K], Subgroup.Normal.{u1} G _inst_1 (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instInfSubgroup.{u1} G _inst_1) H K)
Case conversion may be inaccurate. Consider using '#align subgroup.normal_inf_normal Subgroup.normal_inf_normalₓ'. -/
@[to_additive]
instance normal_inf_normal (H K : Subgroup G) [hH : H.Normal] [hK : K.Normal] : (H ⊓ K).Normal :=
  ⟨fun n hmem g => ⟨hH.conj_mem n hmem.1 g, hK.conj_mem n hmem.2 g⟩⟩
#align subgroup.normal_inf_normal Subgroup.normal_inf_normal
#align add_subgroup.normal_inf_normal AddSubgroup.normal_inf_normal

/- warning: subgroup.subgroup_of_sup -> Subgroup.subgroupOf_sup is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (A : Subgroup.{u1} G _inst_1) (A' : Subgroup.{u1} G _inst_1) (B : Subgroup.{u1} G _inst_1), (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) A B) -> (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) A' B) -> (Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) B) (Subgroup.toGroup.{u1} G _inst_1 B)) (Subgroup.subgroupOf.{u1} G _inst_1 (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1)))) A A') B) (Sup.sup.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) B) (Subgroup.toGroup.{u1} G _inst_1 B)) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) B) (Subgroup.toGroup.{u1} G _inst_1 B)) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) B) (Subgroup.toGroup.{u1} G _inst_1 B)) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) B) (Subgroup.toGroup.{u1} G _inst_1 B)) (Subgroup.completeLattice.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) B) (Subgroup.toGroup.{u1} G _inst_1 B))))) (Subgroup.subgroupOf.{u1} G _inst_1 A B) (Subgroup.subgroupOf.{u1} G _inst_1 A' B)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (A : Subgroup.{u1} G _inst_1) (A' : Subgroup.{u1} G _inst_1) (B : Subgroup.{u1} G _inst_1), (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) A B) -> (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) A' B) -> (Eq.{succ u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x B)) (Subgroup.toGroup.{u1} G _inst_1 B)) (Subgroup.subgroupOf.{u1} G _inst_1 (Sup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1)))) A A') B) (Sup.sup.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x B)) (Subgroup.toGroup.{u1} G _inst_1 B)) (SemilatticeSup.toSup.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x B)) (Subgroup.toGroup.{u1} G _inst_1 B)) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x B)) (Subgroup.toGroup.{u1} G _inst_1 B)) (CompleteLattice.toLattice.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x B)) (Subgroup.toGroup.{u1} G _inst_1 B)) (Subgroup.instCompleteLatticeSubgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x B)) (Subgroup.toGroup.{u1} G _inst_1 B))))) (Subgroup.subgroupOf.{u1} G _inst_1 A B) (Subgroup.subgroupOf.{u1} G _inst_1 A' B)))
Case conversion may be inaccurate. Consider using '#align subgroup.subgroup_of_sup Subgroup.subgroupOf_supₓ'. -/
@[to_additive]
theorem subgroupOf_sup (A A' B : Subgroup G) (hA : A ≤ B) (hA' : A' ≤ B) :
    (A ⊔ A').subgroupOf B = A.subgroupOf B ⊔ A'.subgroupOf B :=
  by
  refine'
    map_injective_of_ker_le B.subtype (ker_le_comap _ _)
      (le_trans (ker_le_comap B.subtype _) le_sup_left) _
  · simp only [subgroup_of, map_comap_eq, map_sup, subtype_range]
    rw [inf_of_le_right (sup_le hA hA'), inf_of_le_right hA', inf_of_le_right hA]
#align subgroup.subgroup_of_sup Subgroup.subgroupOf_sup
#align add_subgroup.add_subgroup_of_sup AddSubgroup.addSubgroupOf_sup

/- warning: subgroup.subgroup_normal.mem_comm -> Subgroup.SubgroupNormal.mem_comm is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1}, (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H K) -> (forall [hN : Subgroup.Normal.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) K) (Subgroup.toGroup.{u1} G _inst_1 K) (Subgroup.subgroupOf.{u1} G _inst_1 H K)] {a : G} {b : G}, (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) b K) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) a b) H) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) b a) H))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {K : Subgroup.{u1} G _inst_1}, (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) H K) -> (forall [hN : Subgroup.Normal.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x K)) (Subgroup.toGroup.{u1} G _inst_1 K) (Subgroup.subgroupOf.{u1} G _inst_1 H K)] {a : G} {b : G}, (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) b K) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) a b) H) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) b a) H))
Case conversion may be inaccurate. Consider using '#align subgroup.subgroup_normal.mem_comm Subgroup.SubgroupNormal.mem_commₓ'. -/
@[to_additive]
theorem SubgroupNormal.mem_comm {H K : Subgroup G} (hK : H ≤ K) [hN : (H.subgroupOf K).Normal]
    {a b : G} (hb : b ∈ K) (h : a * b ∈ H) : b * a ∈ H :=
  by
  have := (normal_subgroup_of_iff hK).mp hN (a * b) b h hb
  rwa [mul_assoc, mul_assoc, mul_right_inv, mul_one] at this
#align subgroup.subgroup_normal.mem_comm Subgroup.SubgroupNormal.mem_comm
#align add_subgroup.subgroup_normal.mem_comm AddSubgroup.SubgroupNormal.mem_comm

/- warning: subgroup.commute_of_normal_of_disjoint -> Subgroup.commute_of_normal_of_disjoint is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H₁ : Subgroup.{u1} G _inst_1) (H₂ : Subgroup.{u1} G _inst_1), (Subgroup.Normal.{u1} G _inst_1 H₁) -> (Subgroup.Normal.{u1} G _inst_1 H₂) -> (Disjoint.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (BoundedOrder.toOrderBot.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (CompleteLattice.toBoundedOrder.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))) H₁ H₂) -> (forall (x : G) (y : G), (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H₁) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) y H₂) -> (Commute.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) x y))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H₁ : Subgroup.{u1} G _inst_1) (H₂ : Subgroup.{u1} G _inst_1), (Subgroup.Normal.{u1} G _inst_1 H₁) -> (Subgroup.Normal.{u1} G _inst_1 H₂) -> (Disjoint.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))) (BoundedOrder.toOrderBot.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (CompleteLattice.toBoundedOrder.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))) H₁ H₂) -> (forall (x : G) (y : G), (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H₁) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) y H₂) -> (Commute.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) x y))
Case conversion may be inaccurate. Consider using '#align subgroup.commute_of_normal_of_disjoint Subgroup.commute_of_normal_of_disjointₓ'. -/
/-- Elements of disjoint, normal subgroups commute. -/
@[to_additive "Elements of disjoint, normal subgroups commute."]
theorem commute_of_normal_of_disjoint (H₁ H₂ : Subgroup G) (hH₁ : H₁.Normal) (hH₂ : H₂.Normal)
    (hdis : Disjoint H₁ H₂) (x y : G) (hx : x ∈ H₁) (hy : y ∈ H₂) : Commute x y :=
  by
  suffices x * y * x⁻¹ * y⁻¹ = 1 by
    show x * y = y * x
    · rw [mul_assoc, mul_eq_one_iff_eq_inv] at this
      simpa
  apply hdis.le_bot
  constructor
  · suffices x * (y * x⁻¹ * y⁻¹) ∈ H₁ by simpa [mul_assoc]
    exact H₁.mul_mem hx (hH₁.conj_mem _ (H₁.inv_mem hx) _)
  · show x * y * x⁻¹ * y⁻¹ ∈ H₂
    apply H₂.mul_mem _ (H₂.inv_mem hy)
    apply hH₂.conj_mem _ hy
#align subgroup.commute_of_normal_of_disjoint Subgroup.commute_of_normal_of_disjoint
#align add_subgroup.commute_of_normal_of_disjoint AddSubgroup.commute_of_normal_of_disjoint

end SubgroupNormal

/- warning: subgroup.disjoint_def -> Subgroup.disjoint_def is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H₁ : Subgroup.{u1} G _inst_1} {H₂ : Subgroup.{u1} G _inst_1}, Iff (Disjoint.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (BoundedOrder.toOrderBot.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (CompleteLattice.toBoundedOrder.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))) H₁ H₂) (forall {x : G}, (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H₁) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H₂) -> (Eq.{succ u1} G x (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H₁ : Subgroup.{u1} G _inst_1} {H₂ : Subgroup.{u1} G _inst_1}, Iff (Disjoint.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))) (BoundedOrder.toOrderBot.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (CompleteLattice.toBoundedOrder.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))) H₁ H₂) (forall {x : G}, (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H₁) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H₂) -> (Eq.{succ u1} G x (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align subgroup.disjoint_def Subgroup.disjoint_defₓ'. -/
@[to_additive]
theorem disjoint_def {H₁ H₂ : Subgroup G} : Disjoint H₁ H₂ ↔ ∀ {x : G}, x ∈ H₁ → x ∈ H₂ → x = 1 :=
  disjoint_iff_inf_le.trans <| by simp only [Disjoint, SetLike.le_def, mem_inf, mem_bot, and_imp]
#align subgroup.disjoint_def Subgroup.disjoint_def
#align add_subgroup.disjoint_def AddSubgroup.disjoint_def

/- warning: subgroup.disjoint_def' -> Subgroup.disjoint_def' is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H₁ : Subgroup.{u1} G _inst_1} {H₂ : Subgroup.{u1} G _inst_1}, Iff (Disjoint.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (BoundedOrder.toOrderBot.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (CompleteLattice.toBoundedOrder.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))) H₁ H₂) (forall {x : G} {y : G}, (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H₁) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) y H₂) -> (Eq.{succ u1} G x y) -> (Eq.{succ u1} G x (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H₁ : Subgroup.{u1} G _inst_1} {H₂ : Subgroup.{u1} G _inst_1}, Iff (Disjoint.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))) (BoundedOrder.toOrderBot.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (CompleteLattice.toBoundedOrder.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))) H₁ H₂) (forall {x : G} {y : G}, (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H₁) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) y H₂) -> (Eq.{succ u1} G x y) -> (Eq.{succ u1} G x (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align subgroup.disjoint_def' Subgroup.disjoint_def'ₓ'. -/
@[to_additive]
theorem disjoint_def' {H₁ H₂ : Subgroup G} :
    Disjoint H₁ H₂ ↔ ∀ {x y : G}, x ∈ H₁ → y ∈ H₂ → x = y → x = 1 :=
  disjoint_def.trans ⟨fun h x y hx hy hxy => h hx <| hxy.symm ▸ hy, fun h x hx hx' => h hx hx' rfl⟩
#align subgroup.disjoint_def' Subgroup.disjoint_def'
#align add_subgroup.disjoint_def' AddSubgroup.disjoint_def'

/- warning: subgroup.disjoint_iff_mul_eq_one -> Subgroup.disjoint_iff_mul_eq_one is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H₁ : Subgroup.{u1} G _inst_1} {H₂ : Subgroup.{u1} G _inst_1}, Iff (Disjoint.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (BoundedOrder.toOrderBot.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (CompleteLattice.toBoundedOrder.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))) H₁ H₂) (forall {x : G} {y : G}, (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H₁) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) y H₂) -> (Eq.{succ u1} G (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x y) (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))) -> (And (Eq.{succ u1} G x (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))) (Eq.{succ u1} G y (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H₁ : Subgroup.{u1} G _inst_1} {H₂ : Subgroup.{u1} G _inst_1}, Iff (Disjoint.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))) (BoundedOrder.toOrderBot.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (CompleteLattice.toBoundedOrder.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))) H₁ H₂) (forall {x : G} {y : G}, (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H₁) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) y H₂) -> (Eq.{succ u1} G (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x y) (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))))) -> (And (Eq.{succ u1} G x (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))))) (Eq.{succ u1} G y (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))))))))
Case conversion may be inaccurate. Consider using '#align subgroup.disjoint_iff_mul_eq_one Subgroup.disjoint_iff_mul_eq_oneₓ'. -/
@[to_additive]
theorem disjoint_iff_mul_eq_one {H₁ H₂ : Subgroup G} :
    Disjoint H₁ H₂ ↔ ∀ {x y : G}, x ∈ H₁ → y ∈ H₂ → x * y = 1 → x = 1 ∧ y = 1 :=
  disjoint_def'.trans
    ⟨fun h x y hx hy hxy =>
      let hx1 : x = 1 := h hx (H₂.inv_mem hy) (eq_inv_iff_mul_eq_one.mpr hxy)
      ⟨hx1, by simpa [hx1] using hxy⟩,
      fun h x y hx hy hxy => (h hx (H₂.inv_mem hy) (mul_inv_eq_one.mpr hxy)).1⟩
#align subgroup.disjoint_iff_mul_eq_one Subgroup.disjoint_iff_mul_eq_one
#align add_subgroup.disjoint_iff_add_eq_zero AddSubgroup.disjoint_iff_add_eq_zero

/- warning: subgroup.mul_injective_of_disjoint -> Subgroup.mul_injective_of_disjoint is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H₁ : Subgroup.{u1} G _inst_1} {H₂ : Subgroup.{u1} G _inst_1}, (Disjoint.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (BoundedOrder.toOrderBot.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (CompleteLattice.toBoundedOrder.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))) H₁ H₂) -> (Function.Injective.{succ u1, succ u1} (Prod.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H₁) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H₂)) G (fun (g : Prod.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H₁) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H₂)) => HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H₁) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H₁) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H₁) G (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H₁) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H₁))))) (Prod.fst.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H₁) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H₂) g)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H₂) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H₂) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H₂) G (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H₂) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H₂))))) (Prod.snd.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H₁) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H₂) g))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H₁ : Subgroup.{u1} G _inst_1} {H₂ : Subgroup.{u1} G _inst_1}, (Disjoint.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))) (BoundedOrder.toOrderBot.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (CompleteLattice.toBoundedOrder.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))) H₁ H₂) -> (Function.Injective.{succ u1, succ u1} (Prod.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H₁)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H₂))) G (fun (g : Prod.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H₁)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H₂))) => HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H₁)) (Prod.fst.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H₁)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H₂)) g)) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H₂)) (Prod.snd.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H₁)) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H₂)) g))))
Case conversion may be inaccurate. Consider using '#align subgroup.mul_injective_of_disjoint Subgroup.mul_injective_of_disjointₓ'. -/
@[to_additive]
theorem mul_injective_of_disjoint {H₁ H₂ : Subgroup G} (h : Disjoint H₁ H₂) :
    Function.Injective (fun g => g.1 * g.2 : H₁ × H₂ → G) :=
  by
  intro x y hxy
  rw [← inv_mul_eq_iff_eq_mul, ← mul_assoc, ← mul_inv_eq_one, mul_assoc] at hxy
  replace hxy := disjoint_iff_mul_eq_one.mp h (y.1⁻¹ * x.1).Prop (x.2 * y.2⁻¹).Prop hxy
  rwa [coe_mul, coe_mul, coe_inv, coe_inv, inv_mul_eq_one, mul_inv_eq_one, ← Subtype.ext_iff, ←
    Subtype.ext_iff, eq_comm, ← Prod.ext_iff] at hxy
#align subgroup.mul_injective_of_disjoint Subgroup.mul_injective_of_disjoint
#align add_subgroup.add_injective_of_disjoint AddSubgroup.add_injective_of_disjoint

end Subgroup

namespace IsConj

open Subgroup

/- warning: is_conj.normal_closure_eq_top_of -> IsConj.normalClosure_eq_top_of is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Subgroup.{u1} G _inst_1} [hn : Subgroup.Normal.{u1} G _inst_1 N] {g : G} {g' : G} {hg : Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) g N} {hg' : Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) g' N}, (IsConj.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) g g') -> (Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) N) (Subgroup.toGroup.{u1} G _inst_1 N)) (Subgroup.normalClosure.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) N) (Subgroup.toGroup.{u1} G _inst_1 N) (Singleton.singleton.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) N) (Set.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) N)) (Set.hasSingleton.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) N)) (Subtype.mk.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x N) g hg))) (Top.top.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) N) (Subgroup.toGroup.{u1} G _inst_1 N)) (Subgroup.hasTop.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) N) (Subgroup.toGroup.{u1} G _inst_1 N)))) -> (Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) N) (Subgroup.toGroup.{u1} G _inst_1 N)) (Subgroup.normalClosure.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) N) (Subgroup.toGroup.{u1} G _inst_1 N) (Singleton.singleton.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) N) (Set.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) N)) (Set.hasSingleton.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) N)) (Subtype.mk.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x N) g' hg'))) (Top.top.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) N) (Subgroup.toGroup.{u1} G _inst_1 N)) (Subgroup.hasTop.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) N) (Subgroup.toGroup.{u1} G _inst_1 N))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {N : Subgroup.{u1} G _inst_1} [hn : Subgroup.Normal.{u1} G _inst_1 N] {g : G} {g' : G} {hg : Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) g N} {hg' : Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) g' N}, (IsConj.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) g g') -> (Eq.{succ u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x N)) (Subgroup.toGroup.{u1} G _inst_1 N)) (Subgroup.normalClosure.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x N)) (Subgroup.toGroup.{u1} G _inst_1 N) (Singleton.singleton.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x N)) (Set.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x N))) (Set.instSingletonSet.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x N))) (Subtype.mk.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x N) g hg))) (Top.top.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x N)) (Subgroup.toGroup.{u1} G _inst_1 N)) (Subgroup.instTopSubgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x N)) (Subgroup.toGroup.{u1} G _inst_1 N)))) -> (Eq.{succ u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x N)) (Subgroup.toGroup.{u1} G _inst_1 N)) (Subgroup.normalClosure.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x N)) (Subgroup.toGroup.{u1} G _inst_1 N) (Singleton.singleton.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x N)) (Set.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x N))) (Set.instSingletonSet.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x N))) (Subtype.mk.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x N) g' hg'))) (Top.top.{u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x N)) (Subgroup.toGroup.{u1} G _inst_1 N)) (Subgroup.instTopSubgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x N)) (Subgroup.toGroup.{u1} G _inst_1 N))))
Case conversion may be inaccurate. Consider using '#align is_conj.normal_closure_eq_top_of IsConj.normalClosure_eq_top_ofₓ'. -/
theorem normalClosure_eq_top_of {N : Subgroup G} [hn : N.Normal] {g g' : G} {hg : g ∈ N}
    {hg' : g' ∈ N} (hc : IsConj g g') (ht : normalClosure ({⟨g, hg⟩} : Set N) = ⊤) :
    normalClosure ({⟨g', hg'⟩} : Set N) = ⊤ :=
  by
  obtain ⟨c, rfl⟩ := isConj_iff.1 hc
  have h : ∀ x : N, (MulAut.conj c) x ∈ N :=
    by
    rintro ⟨x, hx⟩
    exact hn.conj_mem _ hx c
  have hs : Function.Surjective (((MulAut.conj c).toMonoidHom.restrict N).codRestrict _ h) :=
    by
    rintro ⟨x, hx⟩
    refine' ⟨⟨c⁻¹ * x * c, _⟩, _⟩
    · have h := hn.conj_mem _ hx c⁻¹
      rwa [inv_inv] at h
    simp only [MonoidHom.codRestrict_apply, MulEquiv.coe_toMonoidHom, MulAut.conj_apply, coe_mk,
      MonoidHom.restrict_apply, Subtype.mk_eq_mk, ← mul_assoc, mul_inv_self, one_mul]
    rw [mul_assoc, mul_inv_self, mul_one]
  have ht' := map_mono (eq_top_iff.1 ht)
  rw [← MonoidHom.range_eq_map, MonoidHom.range_top_of_surjective _ hs] at ht'
  refine' eq_top_iff.2 (le_trans ht' (map_le_iff_le_comap.2 (normal_closure_le_normal _)))
  rw [Set.singleton_subset_iff, SetLike.mem_coe]
  simp only [MonoidHom.codRestrict_apply, MulEquiv.coe_toMonoidHom, MulAut.conj_apply, coe_mk,
    MonoidHom.restrict_apply, mem_comap]
  exact subset_normal_closure (Set.mem_singleton _)
#align is_conj.normal_closure_eq_top_of IsConj.normalClosure_eq_top_of

end IsConj

assert_not_exists Multiset

