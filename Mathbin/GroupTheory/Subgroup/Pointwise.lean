/-
Copyright (c) 2021 Eric Wieser. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Wieser

! This file was ported from Lean 3 source module group_theory.subgroup.pointwise
! leanprover-community/mathlib commit e97cf15cd1aec9bd5c193b2ffac5a6dc9118912b
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.GroupTheory.Subgroup.MulOpposite
import Mathbin.GroupTheory.Submonoid.Pointwise
import Mathbin.GroupTheory.GroupAction.ConjAct

/-! # Pointwise instances on `subgroup` and `add_subgroup`s

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file provides the actions

* `subgroup.pointwise_mul_action`
* `add_subgroup.pointwise_mul_action`

which matches the action of `mul_action_set`.

These actions are available in the `pointwise` locale.

## Implementation notes

The pointwise section of this file is almost identical to `group_theory/submonoid/pointwise.lean`.
Where possible, try to keep them in sync.
-/


open Set

open Pointwise

variable {α G A S : Type _} [Group G] [AddGroup A] {s : Set G}

/- warning: inv_coe_set -> inv_coe_set is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} {S : Type.{u2}} [_inst_1 : Group.{u1} G] [_inst_3 : SetLike.{u2, u1} S G] [_inst_4 : SubgroupClass.{u2, u1} S G (Group.toDivInvMonoid.{u1} G _inst_1) _inst_3] {H : S}, Eq.{succ u1} (Set.{u1} G) (Inv.inv.{u1} (Set.{u1} G) (Set.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) ((fun (a : Type.{u2}) (b : Type.{u1}) [self : HasLiftT.{succ u2, succ u1} a b] => self.0) S (Set.{u1} G) (HasLiftT.mk.{succ u2, succ u1} S (Set.{u1} G) (CoeTCₓ.coe.{succ u2, succ u1} S (Set.{u1} G) (SetLike.Set.hasCoeT.{u2, u1} S G _inst_3))) H)) ((fun (a : Type.{u2}) (b : Type.{u1}) [self : HasLiftT.{succ u2, succ u1} a b] => self.0) S (Set.{u1} G) (HasLiftT.mk.{succ u2, succ u1} S (Set.{u1} G) (CoeTCₓ.coe.{succ u2, succ u1} S (Set.{u1} G) (SetLike.Set.hasCoeT.{u2, u1} S G _inst_3))) H)
but is expected to have type
  forall {G : Type.{u1}} {S : Type.{u2}} [_inst_1 : Group.{u1} G] [_inst_3 : SetLike.{u2, u1} S G] [_inst_4 : SubgroupClass.{u2, u1} S G (Group.toDivInvMonoid.{u1} G _inst_1) _inst_3] {H : S}, Eq.{succ u1} (Set.{u1} G) (Inv.inv.{u1} (Set.{u1} G) (Set.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))) (SetLike.coe.{u2, u1} S G _inst_3 H)) (SetLike.coe.{u2, u1} S G _inst_3 H)
Case conversion may be inaccurate. Consider using '#align inv_coe_set inv_coe_setₓ'. -/
@[simp, to_additive]
theorem inv_coe_set [SetLike S G] [SubgroupClass S G] {H : S} : (H : Set G)⁻¹ = H :=
  by
  ext
  simp
#align inv_coe_set inv_coe_set
#align neg_coe_set neg_coe_set

namespace Subgroup

/- warning: subgroup.inv_subset_closure -> Subgroup.inv_subset_closure is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (S : Set.{u1} G), HasSubset.Subset.{u1} (Set.{u1} G) (Set.hasSubset.{u1} G) (Inv.inv.{u1} (Set.{u1} G) (Set.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) S) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.closure.{u1} G _inst_1 S))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (S : Set.{u1} G), HasSubset.Subset.{u1} (Set.{u1} G) (Set.instHasSubsetSet.{u1} G) (Inv.inv.{u1} (Set.{u1} G) (Set.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))) S) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (Subgroup.closure.{u1} G _inst_1 S))
Case conversion may be inaccurate. Consider using '#align subgroup.inv_subset_closure Subgroup.inv_subset_closureₓ'. -/
@[simp, to_additive]
theorem inv_subset_closure (S : Set G) : S⁻¹ ⊆ closure S := fun s hs =>
  by
  rw [SetLike.mem_coe, ← Subgroup.inv_mem_iff]
  exact subset_closure (mem_inv.mp hs)
#align subgroup.inv_subset_closure Subgroup.inv_subset_closure
#align add_subgroup.neg_subset_closure AddSubgroup.neg_subset_closure

/- warning: subgroup.closure_to_submonoid -> Subgroup.closure_toSubmonoid is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (S : Set.{u1} G), Eq.{succ u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.toSubmonoid.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 S)) (Submonoid.closure.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Union.union.{u1} (Set.{u1} G) (Set.hasUnion.{u1} G) S (Inv.inv.{u1} (Set.{u1} G) (Set.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) S)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (S : Set.{u1} G), Eq.{succ u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.toSubmonoid.{u1} G _inst_1 (Subgroup.closure.{u1} G _inst_1 S)) (Submonoid.closure.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Union.union.{u1} (Set.{u1} G) (Set.instUnionSet.{u1} G) S (Inv.inv.{u1} (Set.{u1} G) (Set.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))) S)))
Case conversion may be inaccurate. Consider using '#align subgroup.closure_to_submonoid Subgroup.closure_toSubmonoidₓ'. -/
@[to_additive]
theorem closure_toSubmonoid (S : Set G) : (closure S).toSubmonoid = Submonoid.closure (S ∪ S⁻¹) :=
  by
  refine' le_antisymm (fun x hx => _) (Submonoid.closure_le.2 _)
  · refine'
      closure_induction hx
        (fun x hx => Submonoid.closure_mono (subset_union_left S S⁻¹) (Submonoid.subset_closure hx))
        (Submonoid.one_mem _) (fun x y hx hy => Submonoid.mul_mem _ hx hy) fun x hx => _
    rwa [← Submonoid.mem_closure_inv, Set.union_inv, inv_inv, Set.union_comm]
  · simp only [true_and_iff, coe_to_submonoid, union_subset_iff, subset_closure, inv_subset_closure]
#align subgroup.closure_to_submonoid Subgroup.closure_toSubmonoid
#align add_subgroup.closure_to_add_submonoid AddSubgroup.closure_toAddSubmonoid

/- warning: subgroup.closure_induction_left -> Subgroup.closure_induction_left is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G} {p : G -> Prop} {x : G}, (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 s)) -> (p (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))) -> (forall (x : G), (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) x s) -> (forall (y : G), (p y) -> (p (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x y)))) -> (forall (x : G), (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) x s) -> (forall (y : G), (p y) -> (p (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) x) y)))) -> (p x)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G} {p : G -> Prop} {x : G}, (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 s)) -> (p (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))))) -> (forall (x : G), (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x s) -> (forall (y : G), (p y) -> (p (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x y)))) -> (forall (x : G), (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x s) -> (forall (y : G), (p y) -> (p (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) x) y)))) -> (p x)
Case conversion may be inaccurate. Consider using '#align subgroup.closure_induction_left Subgroup.closure_induction_leftₓ'. -/
@[to_additive]
theorem closure_induction_left {p : G → Prop} {x : G} (h : x ∈ closure s) (H1 : p 1)
    (Hmul : ∀ x ∈ s, ∀ (y), p y → p (x * y)) (Hinv : ∀ x ∈ s, ∀ (y), p y → p (x⁻¹ * y)) : p x :=
  let key := (closure_toSubmonoid s).le
  Submonoid.closure_induction_left (key h) H1 fun x hx =>
    hx.elim (Hmul x) fun hx y hy => (congr_arg _ <| inv_inv x).mp <| Hinv x⁻¹ hx y hy
#align subgroup.closure_induction_left Subgroup.closure_induction_left
#align add_subgroup.closure_induction_left AddSubgroup.closure_induction_left

/- warning: subgroup.closure_induction_right -> Subgroup.closure_induction_right is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G} {p : G -> Prop} {x : G}, (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 s)) -> (p (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))) -> (forall (x : G) (y : G), (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) y s) -> (p x) -> (p (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x y))) -> (forall (x : G) (y : G), (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) y s) -> (p x) -> (p (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) y)))) -> (p x)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G} {p : G -> Prop} {x : G}, (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 s)) -> (p (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))))) -> (forall (x : G) (y : G), (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) y s) -> (p x) -> (p (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x y))) -> (forall (x : G) (y : G), (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) y s) -> (p x) -> (p (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) y)))) -> (p x)
Case conversion may be inaccurate. Consider using '#align subgroup.closure_induction_right Subgroup.closure_induction_rightₓ'. -/
@[to_additive]
theorem closure_induction_right {p : G → Prop} {x : G} (h : x ∈ closure s) (H1 : p 1)
    (Hmul : ∀ (x), ∀ y ∈ s, p x → p (x * y)) (Hinv : ∀ (x), ∀ y ∈ s, p x → p (x * y⁻¹)) : p x :=
  let key := (closure_toSubmonoid s).le
  Submonoid.closure_induction_right (key h) H1 fun x y hy =>
    hy.elim (Hmul x y) fun hy hx => (congr_arg _ <| inv_inv y).mp <| Hinv x y⁻¹ hy hx
#align subgroup.closure_induction_right Subgroup.closure_induction_right
#align add_subgroup.closure_induction_right AddSubgroup.closure_induction_right

/- warning: subgroup.closure_inv -> Subgroup.closure_inv is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (s : Set.{u1} G), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.closure.{u1} G _inst_1 (Inv.inv.{u1} (Set.{u1} G) (Set.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) s)) (Subgroup.closure.{u1} G _inst_1 s)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (s : Set.{u1} G), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.closure.{u1} G _inst_1 (Inv.inv.{u1} (Set.{u1} G) (Set.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))) s)) (Subgroup.closure.{u1} G _inst_1 s)
Case conversion may be inaccurate. Consider using '#align subgroup.closure_inv Subgroup.closure_invₓ'. -/
@[simp, to_additive]
theorem closure_inv (s : Set G) : closure s⁻¹ = closure s := by
  simp only [← to_submonoid_eq, closure_to_submonoid, inv_inv, union_comm]
#align subgroup.closure_inv Subgroup.closure_inv
#align add_subgroup.closure_neg AddSubgroup.closure_neg

/- warning: subgroup.closure_induction'' -> Subgroup.closure_induction'' is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G} {p : G -> Prop} {x : G}, (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 s)) -> (forall (x : G), (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) x s) -> (p x)) -> (forall (x : G), (Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) x s) -> (p (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) x))) -> (p (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))) -> (forall (x : G) (y : G), (p x) -> (p y) -> (p (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x y))) -> (p x)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {s : Set.{u1} G} {p : G -> Prop} {x : G}, (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (Subgroup.closure.{u1} G _inst_1 s)) -> (forall (x : G), (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x s) -> (p x)) -> (forall (x : G), (Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x s) -> (p (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) x))) -> (p (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))))) -> (forall (x : G) (y : G), (p x) -> (p y) -> (p (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x y))) -> (p x)
Case conversion may be inaccurate. Consider using '#align subgroup.closure_induction'' Subgroup.closure_induction''ₓ'. -/
/-- An induction principle for closure membership. If `p` holds for `1` and all elements of
`k` and their inverse, and is preserved under multiplication, then `p` holds for all elements of
the closure of `k`. -/
@[to_additive
      "An induction principle for additive closure membership. If `p` holds for `0` and all\nelements of `k` and their negation, and is preserved under addition, then `p` holds for all\nelements of the additive closure of `k`."]
theorem closure_induction'' {p : G → Prop} {x} (h : x ∈ closure s) (Hk : ∀ x ∈ s, p x)
    (Hk_inv : ∀ x ∈ s, p x⁻¹) (H1 : p 1) (Hmul : ∀ x y, p x → p y → p (x * y)) : p x :=
  closure_induction_left h H1 (fun x hx y hy => Hmul x y (Hk x hx) hy) fun x hx y =>
    Hmul x⁻¹ y <| Hk_inv x hx
#align subgroup.closure_induction'' Subgroup.closure_induction''
#align add_subgroup.closure_induction'' AddSubgroup.closure_induction''

/- warning: subgroup.supr_induction -> Subgroup.supᵢ_induction is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Sort.{u2}} (S : ι -> (Subgroup.{u1} G _inst_1)) {C : G -> Prop} {x : G}, (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (supᵢ.{u1, u2} (Subgroup.{u1} G _inst_1) (ConditionallyCompleteLattice.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))) ι (fun (i : ι) => S i))) -> (forall (i : ι) (x : G), (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (S i)) -> (C x)) -> (C (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))) -> (forall (x : G) (y : G), (C x) -> (C y) -> (C (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x y))) -> (C x)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Sort.{u2}} (S : ι -> (Subgroup.{u1} G _inst_1)) {C : G -> Prop} {x : G}, (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (supᵢ.{u1, u2} (Subgroup.{u1} G _inst_1) (ConditionallyCompleteLattice.toSupSet.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))) ι (fun (i : ι) => S i))) -> (forall (i : ι) (x : G), (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (S i)) -> (C x)) -> (C (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))))) -> (forall (x : G) (y : G), (C x) -> (C y) -> (C (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x y))) -> (C x)
Case conversion may be inaccurate. Consider using '#align subgroup.supr_induction Subgroup.supᵢ_inductionₓ'. -/
/-- An induction principle for elements of `⨆ i, S i`.
If `C` holds for `1` and all elements of `S i` for all `i`, and is preserved under multiplication,
then it holds for all elements of the supremum of `S`. -/
@[elab_as_elim,
  to_additive
      " An induction principle for elements of `⨆ i, S i`.\nIf `C` holds for `0` and all elements of `S i` for all `i`, and is preserved under addition,\nthen it holds for all elements of the supremum of `S`. "]
theorem supᵢ_induction {ι : Sort _} (S : ι → Subgroup G) {C : G → Prop} {x : G} (hx : x ∈ ⨆ i, S i)
    (hp : ∀ (i), ∀ x ∈ S i, C x) (h1 : C 1) (hmul : ∀ x y, C x → C y → C (x * y)) : C x :=
  by
  rw [supr_eq_closure] at hx
  refine' closure_induction'' hx (fun x hx => _) (fun x hx => _) h1 hmul
  · obtain ⟨i, hi⟩ := set.mem_Union.mp hx
    exact hp _ _ hi
  · obtain ⟨i, hi⟩ := set.mem_Union.mp hx
    exact hp _ _ (inv_mem hi)
#align subgroup.supr_induction Subgroup.supᵢ_induction
#align add_subgroup.supr_induction AddSubgroup.supᵢ_induction

/- warning: subgroup.supr_induction' -> Subgroup.supᵢ_induction' is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Sort.{u2}} (S : ι -> (Subgroup.{u1} G _inst_1)) {C : forall (x : G), (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (supᵢ.{u1, u2} (Subgroup.{u1} G _inst_1) (ConditionallyCompleteLattice.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))) ι (fun (i : ι) => S i))) -> Prop}, (forall (i : ι) (x : G) (H : Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (S i)), C x (Subgroup.mem_supᵢ_of_mem.{u1, u2} G _inst_1 ι (fun (i : ι) => S i) i x H)) -> (C (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) (OneMemClass.one_mem.{u1, u1} (Subgroup.{u1} G _inst_1) G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.setLike.{u1} G _inst_1) (SubmonoidClass.to_oneMemClass.{u1, u1} (Subgroup.{u1} G _inst_1) G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.setLike.{u1} G _inst_1) (SubgroupClass.to_submonoidClass.{u1, u1} (Subgroup.{u1} G _inst_1) G (Group.toDivInvMonoid.{u1} G _inst_1) (Subgroup.setLike.{u1} G _inst_1) (Subgroup.subgroupClass.{u1} G _inst_1))) (supᵢ.{u1, u2} (Subgroup.{u1} G _inst_1) (ConditionallyCompleteLattice.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))) ι (fun (i : ι) => S i)))) -> (forall (x : G) (y : G) (hx : Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (supᵢ.{u1, u2} (Subgroup.{u1} G _inst_1) (ConditionallyCompleteLattice.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))) ι (fun (i : ι) => S i))) (hy : Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) y (supᵢ.{u1, u2} (Subgroup.{u1} G _inst_1) (ConditionallyCompleteLattice.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))) ι (fun (i : ι) => S i))), (C x hx) -> (C y hy) -> (C (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x y) (MulMemClass.mul_mem.{u1, u1} (Subgroup.{u1} G _inst_1) G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.setLike.{u1} G _inst_1) (SubmonoidClass.to_mulMemClass.{u1, u1} (Subgroup.{u1} G _inst_1) G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.setLike.{u1} G _inst_1) (SubgroupClass.to_submonoidClass.{u1, u1} (Subgroup.{u1} G _inst_1) G (Group.toDivInvMonoid.{u1} G _inst_1) (Subgroup.setLike.{u1} G _inst_1) (Subgroup.subgroupClass.{u1} G _inst_1))) (supᵢ.{u1, u2} (Subgroup.{u1} G _inst_1) (ConditionallyCompleteLattice.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))) ι (fun (i : ι) => S i)) x y hx hy))) -> (forall {x : G} (hx : Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (supᵢ.{u1, u2} (Subgroup.{u1} G _inst_1) (ConditionallyCompleteLattice.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))) ι (fun (i : ι) => S i))), C x hx)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Sort.{u2}} (S : ι -> (Subgroup.{u1} G _inst_1)) {C : forall (x : G), (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (supᵢ.{u1, u2} (Subgroup.{u1} G _inst_1) (ConditionallyCompleteLattice.toSupSet.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))) ι (fun (i : ι) => S i))) -> Prop}, (forall (i : ι) (x : G) (H : Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (S i)), C x (Subgroup.mem_supᵢ_of_mem.{u1, u2} G _inst_1 ι (fun (i : ι) => S i) i x H)) -> (C (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))))) (OneMemClass.one_mem.{u1, u1} (Subgroup.{u1} G _inst_1) G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (SubmonoidClass.toOneMemClass.{u1, u1} (Subgroup.{u1} G _inst_1) G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (SubgroupClass.toSubmonoidClass.{u1, u1} (Subgroup.{u1} G _inst_1) G (Group.toDivInvMonoid.{u1} G _inst_1) (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (Subgroup.instSubgroupClassSubgroupToDivInvMonoidInstSetLikeSubgroup.{u1} G _inst_1))) (supᵢ.{u1, u2} (Subgroup.{u1} G _inst_1) (ConditionallyCompleteLattice.toSupSet.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))) ι (fun (i : ι) => S i)))) -> (forall (x : G) (y : G) (hx : Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (supᵢ.{u1, u2} (Subgroup.{u1} G _inst_1) (ConditionallyCompleteLattice.toSupSet.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))) ι (fun (i : ι) => S i))) (hy : Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) y (supᵢ.{u1, u2} (Subgroup.{u1} G _inst_1) (ConditionallyCompleteLattice.toSupSet.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))) ι (fun (i : ι) => S i))), (C x hx) -> (C y hy) -> (C (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) x y) (MulMemClass.mul_mem.{u1, u1} (Subgroup.{u1} G _inst_1) G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (SubmonoidClass.toMulMemClass.{u1, u1} (Subgroup.{u1} G _inst_1) G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (SubgroupClass.toSubmonoidClass.{u1, u1} (Subgroup.{u1} G _inst_1) G (Group.toDivInvMonoid.{u1} G _inst_1) (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (Subgroup.instSubgroupClassSubgroupToDivInvMonoidInstSetLikeSubgroup.{u1} G _inst_1))) (supᵢ.{u1, u2} (Subgroup.{u1} G _inst_1) (ConditionallyCompleteLattice.toSupSet.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))) ι (fun (i : ι) => S i)) x y hx hy))) -> (forall {x : G} (hx : Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (supᵢ.{u1, u2} (Subgroup.{u1} G _inst_1) (ConditionallyCompleteLattice.toSupSet.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))) ι (fun (i : ι) => S i))), C x hx)
Case conversion may be inaccurate. Consider using '#align subgroup.supr_induction' Subgroup.supᵢ_induction'ₓ'. -/
/-- A dependent version of `subgroup.supr_induction`. -/
@[elab_as_elim, to_additive "A dependent version of `add_subgroup.supr_induction`. "]
theorem supᵢ_induction' {ι : Sort _} (S : ι → Subgroup G) {C : ∀ x, (x ∈ ⨆ i, S i) → Prop}
    (hp : ∀ (i), ∀ x ∈ S i, C x (mem_supᵢ_of_mem i ‹_›)) (h1 : C 1 (one_mem _))
    (hmul : ∀ x y hx hy, C x hx → C y hy → C (x * y) (mul_mem ‹_› ‹_›)) {x : G}
    (hx : x ∈ ⨆ i, S i) : C x hx :=
  by
  refine' Exists.elim _ fun (hx : x ∈ ⨆ i, S i) (hc : C x hx) => hc
  refine' supr_induction S hx (fun i x hx => _) _ fun x y => _
  · exact ⟨_, hp _ _ hx⟩
  · exact ⟨_, h1⟩
  · rintro ⟨_, Cx⟩ ⟨_, Cy⟩
    refine' ⟨_, hmul _ _ _ _ Cx Cy⟩
#align subgroup.supr_induction' Subgroup.supᵢ_induction'
#align add_subgroup.supr_induction' AddSubgroup.supᵢ_induction'

/- warning: subgroup.closure_mul_le -> Subgroup.closure_mul_le is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (S : Set.{u1} G) (T : Set.{u1} G), LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Subgroup.closure.{u1} G _inst_1 (HMul.hMul.{u1, u1, u1} (Set.{u1} G) (Set.{u1} G) (Set.{u1} G) (instHMul.{u1} (Set.{u1} G) (Set.mul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) S T)) (HasSup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (ConditionallyCompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))))) (Subgroup.closure.{u1} G _inst_1 S) (Subgroup.closure.{u1} G _inst_1 T))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (S : Set.{u1} G) (T : Set.{u1} G), LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (Subgroup.closure.{u1} G _inst_1 (HMul.hMul.{u1, u1, u1} (Set.{u1} G) (Set.{u1} G) (Set.{u1} G) (instHMul.{u1} (Set.{u1} G) (Set.mul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) S T)) (HasSup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (ConditionallyCompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (Subgroup.closure.{u1} G _inst_1 S) (Subgroup.closure.{u1} G _inst_1 T))
Case conversion may be inaccurate. Consider using '#align subgroup.closure_mul_le Subgroup.closure_mul_leₓ'. -/
@[to_additive]
theorem closure_mul_le (S T : Set G) : closure (S * T) ≤ closure S ⊔ closure T :=
  infₛ_le fun x ⟨s, t, hs, ht, hx⟩ =>
    hx ▸
      (closure S ⊔ closure T).mul_mem (SetLike.le_def.mp le_sup_left <| subset_closure hs)
        (SetLike.le_def.mp le_sup_right <| subset_closure ht)
#align subgroup.closure_mul_le Subgroup.closure_mul_le
#align add_subgroup.closure_add_le AddSubgroup.closure_add_le

/- warning: subgroup.sup_eq_closure -> Subgroup.sup_eq_closure is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (K : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (HasSup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (ConditionallyCompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))))) H K) (Subgroup.closure.{u1} G _inst_1 (HMul.hMul.{u1, u1, u1} (Set.{u1} G) (Set.{u1} G) (Set.{u1} G) (instHMul.{u1} (Set.{u1} G) (Set.mul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) K)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (K : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (HasSup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (ConditionallyCompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) H K) (Subgroup.closure.{u1} G _inst_1 (HMul.hMul.{u1, u1, u1} (Set.{u1} G) (Set.{u1} G) (Set.{u1} G) (instHMul.{u1} (Set.{u1} G) (Set.mul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) K)))
Case conversion may be inaccurate. Consider using '#align subgroup.sup_eq_closure Subgroup.sup_eq_closureₓ'. -/
@[to_additive]
theorem sup_eq_closure (H K : Subgroup G) : H ⊔ K = closure (H * K) :=
  le_antisymm
    (sup_le (fun h hh => subset_closure ⟨h, 1, hh, K.one_mem, mul_one h⟩) fun k hk =>
      subset_closure ⟨1, k, H.one_mem, hk, one_mul k⟩)
    (by conv_rhs => rw [← closure_eq H, ← closure_eq K] <;> apply closure_mul_le)
#align subgroup.sup_eq_closure Subgroup.sup_eq_closure
#align add_subgroup.sup_eq_closure AddSubgroup.sup_eq_closure

@[to_additive]
private def mul_normal_aux (H N : Subgroup G) [hN : N.Normal] : Subgroup G
    where
  carrier := (H : Set G) * N
  one_mem' := ⟨1, 1, H.one_mem, N.one_mem, by rw [mul_one]⟩
  mul_mem' := fun a b ⟨h, n, hh, hn, ha⟩ ⟨h', n', hh', hn', hb⟩ =>
    ⟨h * h', h'⁻¹ * n * h' * n', H.mul_mem hh hh',
      N.mul_mem (by simpa using hN.conj_mem _ hn h'⁻¹) hn', by simp [← ha, ← hb, mul_assoc]⟩
  inv_mem' := fun x ⟨h, n, hh, hn, hx⟩ =>
    ⟨h⁻¹, h * n⁻¹ * h⁻¹, H.inv_mem hh, hN.conj_mem _ (N.inv_mem hn) h, by
      rw [mul_assoc h, inv_mul_cancel_left, ← hx, mul_inv_rev]⟩
#align subgroup.mul_normal_aux subgroup.mul_normal_aux

/- warning: subgroup.mul_normal -> Subgroup.mul_normal is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (N : Subgroup.{u1} G _inst_1) [_inst_3 : Subgroup.Normal.{u1} G _inst_1 N], Eq.{succ u1} (Set.{u1} G) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (HasSup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (ConditionallyCompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))))) H N)) (HMul.hMul.{u1, u1, u1} (Set.{u1} G) (Set.{u1} G) (Set.{u1} G) (instHMul.{u1} (Set.{u1} G) (Set.mul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) N))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (N : Subgroup.{u1} G _inst_1) [_inst_3 : Subgroup.Normal.{u1} G _inst_1 N], Eq.{succ u1} (Set.{u1} G) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (HasSup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (ConditionallyCompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) H N)) (HMul.hMul.{u1, u1, u1} (Set.{u1} G) (Set.{u1} G) (Set.{u1} G) (instHMul.{u1} (Set.{u1} G) (Set.mul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) N))
Case conversion may be inaccurate. Consider using '#align subgroup.mul_normal Subgroup.mul_normalₓ'. -/
/-- The carrier of `H ⊔ N` is just `↑H * ↑N` (pointwise set product) when `N` is normal. -/
@[to_additive
      "The carrier of `H ⊔ N` is just `↑H + ↑N` (pointwise set addition)\nwhen `N` is normal."]
theorem mul_normal (H N : Subgroup G) [N.Normal] : (↑(H ⊔ N) : Set G) = H * N :=
  Set.Subset.antisymm
    (show H ⊔ N ≤ mulNormalAux H N by
      rw [sup_eq_closure]
      apply infₛ_le _
      dsimp
      rfl)
    ((sup_eq_closure H N).symm ▸ subset_closure)
#align subgroup.mul_normal Subgroup.mul_normal
#align add_subgroup.add_normal AddSubgroup.add_normal

@[to_additive]
private def normal_mul_aux (N H : Subgroup G) [hN : N.Normal] : Subgroup G
    where
  carrier := (N : Set G) * H
  one_mem' := ⟨1, 1, N.one_mem, H.one_mem, by rw [mul_one]⟩
  mul_mem' := fun a b ⟨n, h, hn, hh, ha⟩ ⟨n', h', hn', hh', hb⟩ =>
    ⟨n * (h * n' * h⁻¹), h * h', N.mul_mem hn (hN.conj_mem _ hn' _), H.mul_mem hh hh', by
      simp [← ha, ← hb, mul_assoc]⟩
  inv_mem' := fun x ⟨n, h, hn, hh, hx⟩ =>
    ⟨h⁻¹ * n⁻¹ * h, h⁻¹, by simpa using hN.conj_mem _ (N.inv_mem hn) h⁻¹, H.inv_mem hh, by
      rw [mul_inv_cancel_right, ← mul_inv_rev, hx]⟩
#align subgroup.normal_mul_aux subgroup.normal_mul_aux

/- warning: subgroup.normal_mul -> Subgroup.normal_mul is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (N : Subgroup.{u1} G _inst_1) (H : Subgroup.{u1} G _inst_1) [_inst_3 : Subgroup.Normal.{u1} G _inst_1 N], Eq.{succ u1} (Set.{u1} G) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (HasSup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (ConditionallyCompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))))) N H)) (HMul.hMul.{u1, u1, u1} (Set.{u1} G) (Set.{u1} G) (Set.{u1} G) (instHMul.{u1} (Set.{u1} G) (Set.mul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) N) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (N : Subgroup.{u1} G _inst_1) (H : Subgroup.{u1} G _inst_1) [_inst_3 : Subgroup.Normal.{u1} G _inst_1 N], Eq.{succ u1} (Set.{u1} G) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (HasSup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (ConditionallyCompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) N H)) (HMul.hMul.{u1, u1, u1} (Set.{u1} G) (Set.{u1} G) (Set.{u1} G) (instHMul.{u1} (Set.{u1} G) (Set.mul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) N) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H))
Case conversion may be inaccurate. Consider using '#align subgroup.normal_mul Subgroup.normal_mulₓ'. -/
/-- The carrier of `N ⊔ H` is just `↑N * ↑H` (pointwise set product) when `N` is normal. -/
@[to_additive
      "The carrier of `N ⊔ H` is just `↑N + ↑H` (pointwise set addition)\nwhen `N` is normal."]
theorem normal_mul (N H : Subgroup G) [N.Normal] : (↑(N ⊔ H) : Set G) = N * H :=
  Set.Subset.antisymm
    (show N ⊔ H ≤ normalMulAux N H by
      rw [sup_eq_closure]
      apply infₛ_le _
      dsimp
      rfl)
    ((sup_eq_closure N H).symm ▸ subset_closure)
#align subgroup.normal_mul Subgroup.normal_mul
#align add_subgroup.normal_add AddSubgroup.normal_add

/- warning: subgroup.mul_inf_assoc -> Subgroup.mul_inf_assoc is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (A : Subgroup.{u1} G _inst_1) (B : Subgroup.{u1} G _inst_1) (C : Subgroup.{u1} G _inst_1), (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) A C) -> (Eq.{succ u1} (Set.{u1} G) (HMul.hMul.{u1, u1, u1} (Set.{u1} G) (Set.{u1} G) (Set.{u1} G) (instHMul.{u1} (Set.{u1} G) (Set.mul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) A) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (HasInf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasInf.{u1} G _inst_1) B C))) (HasInf.inf.{u1} (Set.{u1} G) (SemilatticeInf.toHasInf.{u1} (Set.{u1} G) (Lattice.toSemilatticeInf.{u1} (Set.{u1} G) (ConditionallyCompleteLattice.toLattice.{u1} (Set.{u1} G) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Set.{u1} G) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} G) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} G) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} G) (Set.completeBooleanAlgebra.{u1} G)))))))) (HMul.hMul.{u1, u1, u1} (Set.{u1} G) (Set.{u1} G) (Set.{u1} G) (instHMul.{u1} (Set.{u1} G) (Set.mul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) A) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) B)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) C)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (A : Subgroup.{u1} G _inst_1) (B : Subgroup.{u1} G _inst_1) (C : Subgroup.{u1} G _inst_1), (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) A C) -> (Eq.{succ u1} (Set.{u1} G) (HMul.hMul.{u1, u1, u1} (Set.{u1} G) (Set.{u1} G) (Set.{u1} G) (instHMul.{u1} (Set.{u1} G) (Set.mul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) A) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (HasInf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instHasInfSubgroup.{u1} G _inst_1) B C))) (HasInf.inf.{u1} (Set.{u1} G) (Lattice.toHasInf.{u1} (Set.{u1} G) (ConditionallyCompleteLattice.toLattice.{u1} (Set.{u1} G) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Set.{u1} G) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} G) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} G) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} G) (Set.instCompleteBooleanAlgebraSet.{u1} G))))))) (HMul.hMul.{u1, u1, u1} (Set.{u1} G) (Set.{u1} G) (Set.{u1} G) (instHMul.{u1} (Set.{u1} G) (Set.mul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) A) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) B)) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) C)))
Case conversion may be inaccurate. Consider using '#align subgroup.mul_inf_assoc Subgroup.mul_inf_assocₓ'. -/
@[to_additive]
theorem mul_inf_assoc (A B C : Subgroup G) (h : A ≤ C) : (A : Set G) * ↑(B ⊓ C) = A * B ⊓ C :=
  by
  ext
  simp only [coe_inf, Set.inf_eq_inter, Set.mem_mul, Set.mem_inter_iff]
  constructor
  · rintro ⟨y, z, hy, ⟨hzB, hzC⟩, rfl⟩
    refine' ⟨_, mul_mem (h hy) hzC⟩
    exact ⟨y, z, hy, hzB, rfl⟩
  rintro ⟨⟨y, z, hy, hz, rfl⟩, hyz⟩
  refine' ⟨y, z, hy, ⟨hz, _⟩, rfl⟩
  suffices y⁻¹ * (y * z) ∈ C by simpa
  exact mul_mem (inv_mem (h hy)) hyz
#align subgroup.mul_inf_assoc Subgroup.mul_inf_assoc
#align add_subgroup.add_inf_assoc AddSubgroup.add_inf_assoc

/- warning: subgroup.inf_mul_assoc -> Subgroup.inf_mul_assoc is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (A : Subgroup.{u1} G _inst_1) (B : Subgroup.{u1} G _inst_1) (C : Subgroup.{u1} G _inst_1), (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) C A) -> (Eq.{succ u1} (Set.{u1} G) (HMul.hMul.{u1, u1, u1} (Set.{u1} G) (Set.{u1} G) (Set.{u1} G) (instHMul.{u1} (Set.{u1} G) (Set.mul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (HasInf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasInf.{u1} G _inst_1) A B)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) C)) (HasInf.inf.{u1} (Set.{u1} G) (SemilatticeInf.toHasInf.{u1} (Set.{u1} G) (Lattice.toSemilatticeInf.{u1} (Set.{u1} G) (ConditionallyCompleteLattice.toLattice.{u1} (Set.{u1} G) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Set.{u1} G) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} G) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} G) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} G) (Set.completeBooleanAlgebra.{u1} G)))))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) A) (HMul.hMul.{u1, u1, u1} (Set.{u1} G) (Set.{u1} G) (Set.{u1} G) (instHMul.{u1} (Set.{u1} G) (Set.mul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) B) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) C))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (A : Subgroup.{u1} G _inst_1) (B : Subgroup.{u1} G _inst_1) (C : Subgroup.{u1} G _inst_1), (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) C A) -> (Eq.{succ u1} (Set.{u1} G) (HMul.hMul.{u1, u1, u1} (Set.{u1} G) (Set.{u1} G) (Set.{u1} G) (instHMul.{u1} (Set.{u1} G) (Set.mul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) (HasInf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instHasInfSubgroup.{u1} G _inst_1) A B)) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) C)) (HasInf.inf.{u1} (Set.{u1} G) (Lattice.toHasInf.{u1} (Set.{u1} G) (ConditionallyCompleteLattice.toLattice.{u1} (Set.{u1} G) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Set.{u1} G) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} G) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} G) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} G) (Set.instCompleteBooleanAlgebraSet.{u1} G))))))) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) A) (HMul.hMul.{u1, u1, u1} (Set.{u1} G) (Set.{u1} G) (Set.{u1} G) (instHMul.{u1} (Set.{u1} G) (Set.mul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) B) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) C))))
Case conversion may be inaccurate. Consider using '#align subgroup.inf_mul_assoc Subgroup.inf_mul_assocₓ'. -/
@[to_additive]
theorem inf_mul_assoc (A B C : Subgroup G) (h : C ≤ A) :
    ((A ⊓ B : Subgroup G) : Set G) * C = A ⊓ B * C :=
  by
  ext
  simp only [coe_inf, Set.inf_eq_inter, Set.mem_mul, Set.mem_inter_iff]
  constructor
  · rintro ⟨y, z, ⟨hyA, hyB⟩, hz, rfl⟩
    refine' ⟨A.mul_mem hyA (h hz), _⟩
    exact ⟨y, z, hyB, hz, rfl⟩
  rintro ⟨hyz, y, z, hy, hz, rfl⟩
  refine' ⟨y, z, ⟨_, hy⟩, hz, rfl⟩
  suffices y * z * z⁻¹ ∈ A by simpa
  exact mul_mem hyz (inv_mem (h hz))
#align subgroup.inf_mul_assoc Subgroup.inf_mul_assoc
#align add_subgroup.inf_add_assoc AddSubgroup.inf_add_assoc

/- warning: subgroup.sup_normal -> Subgroup.sup_normal is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (K : Subgroup.{u1} G _inst_1) [hH : Subgroup.Normal.{u1} G _inst_1 H] [hK : Subgroup.Normal.{u1} G _inst_1 K], Subgroup.Normal.{u1} G _inst_1 (HasSup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (ConditionallyCompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))))) H K)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H : Subgroup.{u1} G _inst_1) (K : Subgroup.{u1} G _inst_1) [hH : Subgroup.Normal.{u1} G _inst_1 H] [hK : Subgroup.Normal.{u1} G _inst_1 K], Subgroup.Normal.{u1} G _inst_1 (HasSup.sup.{u1} (Subgroup.{u1} G _inst_1) (SemilatticeSup.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (Lattice.toSemilatticeSup.{u1} (Subgroup.{u1} G _inst_1) (ConditionallyCompleteLattice.toLattice.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) H K)
Case conversion may be inaccurate. Consider using '#align subgroup.sup_normal Subgroup.sup_normalₓ'. -/
instance sup_normal (H K : Subgroup G) [hH : H.Normal] [hK : K.Normal] : (H ⊔ K).Normal
    where conj_mem n hmem g := by
    change n ∈ ↑(H ⊔ K) at hmem
    change g * n * g⁻¹ ∈ ↑(H ⊔ K)
    rw [normal_mul, Set.mem_mul] at *
    rcases hmem with ⟨h, k, hh, hk, rfl⟩
    refine' ⟨g * h * g⁻¹, g * k * g⁻¹, hH.conj_mem h hh g, hK.conj_mem k hk g, _⟩
    simp
#align subgroup.sup_normal Subgroup.sup_normal

/- warning: subgroup.smul_opposite_image_mul_preimage -> Subgroup.smul_opposite_image_mul_preimage is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} (g : G) (h : coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1)) (MulOpposite.{u1} G) (Subgroup.setLike.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (fun (_x : Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) => (Subgroup.{u1} G _inst_1) -> (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (Equiv.hasCoeToFun.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (Subgroup.opposite.{u1} G _inst_1) H)) (s : Set.{u1} G), Eq.{succ u1} (Set.{u1} G) (Set.image.{u1, u1} G G (fun (y : G) => SMul.smul.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1)) (MulOpposite.{u1} G) (Subgroup.setLike.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (fun (_x : Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) => (Subgroup.{u1} G _inst_1) -> (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (Equiv.hasCoeToFun.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (Subgroup.opposite.{u1} G _inst_1) H)) G (MulAction.toHasSmul.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1)) (MulOpposite.{u1} G) (Subgroup.setLike.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (fun (_x : Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) => (Subgroup.{u1} G _inst_1) -> (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (Equiv.hasCoeToFun.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (Subgroup.opposite.{u1} G _inst_1) H)) G (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1)) (MulOpposite.{u1} G) (Subgroup.setLike.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (fun (_x : Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) => (Subgroup.{u1} G _inst_1) -> (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (Equiv.hasCoeToFun.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (Subgroup.opposite.{u1} G _inst_1) H)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1)) (MulOpposite.{u1} G) (Subgroup.setLike.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (fun (_x : Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) => (Subgroup.{u1} G _inst_1) -> (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (Equiv.hasCoeToFun.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (Subgroup.opposite.{u1} G _inst_1) H)) (Subgroup.toGroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (fun (_x : Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) => (Subgroup.{u1} G _inst_1) -> (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (Equiv.hasCoeToFun.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (Subgroup.opposite.{u1} G _inst_1) H)))) (Subgroup.mulAction.{u1, u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1) G (Monoid.toOppositeMulAction.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (fun (_x : Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) => (Subgroup.{u1} G _inst_1) -> (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (Equiv.hasCoeToFun.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (Subgroup.opposite.{u1} G _inst_1) H))) h y) (Set.preimage.{u1, u1} G G (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g) s)) (Set.preimage.{u1, u1} G G (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g) (Set.image.{u1, u1} G G (fun (y : G) => SMul.smul.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1)) (MulOpposite.{u1} G) (Subgroup.setLike.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (fun (_x : Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) => (Subgroup.{u1} G _inst_1) -> (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (Equiv.hasCoeToFun.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (Subgroup.opposite.{u1} G _inst_1) H)) G (MulAction.toHasSmul.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1)) (MulOpposite.{u1} G) (Subgroup.setLike.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (fun (_x : Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) => (Subgroup.{u1} G _inst_1) -> (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (Equiv.hasCoeToFun.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (Subgroup.opposite.{u1} G _inst_1) H)) G (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1)) (MulOpposite.{u1} G) (Subgroup.setLike.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (fun (_x : Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) => (Subgroup.{u1} G _inst_1) -> (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (Equiv.hasCoeToFun.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (Subgroup.opposite.{u1} G _inst_1) H)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1)) (MulOpposite.{u1} G) (Subgroup.setLike.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (fun (_x : Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) => (Subgroup.{u1} G _inst_1) -> (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (Equiv.hasCoeToFun.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (Subgroup.opposite.{u1} G _inst_1) H)) (Subgroup.toGroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (fun (_x : Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) => (Subgroup.{u1} G _inst_1) -> (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (Equiv.hasCoeToFun.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (Subgroup.opposite.{u1} G _inst_1) H)))) (Subgroup.mulAction.{u1, u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1) G (Monoid.toOppositeMulAction.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (fun (_x : Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) => (Subgroup.{u1} G _inst_1) -> (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (Equiv.hasCoeToFun.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.group.{u1} G _inst_1))) (Subgroup.opposite.{u1} G _inst_1) H))) h y) s))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} (g : G) (h : Subtype.{succ u1} (MulOpposite.{u1} G) (fun (x : MulOpposite.{u1} G) => Membership.mem.{u1, u1} (MulOpposite.{u1} G) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Subgroup.{u1} G _inst_1) => Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1)) H) (SetLike.instMembership.{u1, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Subgroup.{u1} G _inst_1) => Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1)) H) (MulOpposite.{u1} G) (Subgroup.instSetLikeSubgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1))) x (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1))) (Subgroup.{u1} G _inst_1) (fun (a : Subgroup.{u1} G _inst_1) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Subgroup.{u1} G _inst_1) => Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1)) a) (Equiv.instFunLikeEquiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1))) (Subgroup.opposite.{u1} G _inst_1) H))) (s : Set.{u1} G), Eq.{succ u1} (Set.{u1} G) (Set.image.{u1, u1} G G (fun (y : G) => HSMul.hSMul.{u1, u1, u1} (Subtype.{succ u1} (MulOpposite.{u1} G) (fun (x : MulOpposite.{u1} G) => Membership.mem.{u1, u1} (MulOpposite.{u1} G) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Subgroup.{u1} G _inst_1) => Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1)) H) (SetLike.instMembership.{u1, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Subgroup.{u1} G _inst_1) => Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1)) H) (MulOpposite.{u1} G) (Subgroup.instSetLikeSubgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1))) x (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1))) (Subgroup.{u1} G _inst_1) (fun (a : Subgroup.{u1} G _inst_1) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Subgroup.{u1} G _inst_1) => Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1)) a) (Equiv.instFunLikeEquiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1))) (Subgroup.opposite.{u1} G _inst_1) H))) G G (instHSMul.{u1, u1} (Subtype.{succ u1} (MulOpposite.{u1} G) (fun (x : MulOpposite.{u1} G) => Membership.mem.{u1, u1} (MulOpposite.{u1} G) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Subgroup.{u1} G _inst_1) => Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1)) H) (SetLike.instMembership.{u1, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Subgroup.{u1} G _inst_1) => Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1)) H) (MulOpposite.{u1} G) (Subgroup.instSetLikeSubgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1))) x (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1))) (Subgroup.{u1} G _inst_1) (fun (a : Subgroup.{u1} G _inst_1) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Subgroup.{u1} G _inst_1) => Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1)) a) (Equiv.instFunLikeEquiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1))) (Subgroup.opposite.{u1} G _inst_1) H))) G (Submonoid.smul.{u1, u1} (MulOpposite.{u1} G) G (Monoid.toMulOneClass.{u1} (MulOpposite.{u1} G) (DivInvMonoid.toMonoid.{u1} (MulOpposite.{u1} G) (Group.toDivInvMonoid.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1)))) (Mul.toHasOppositeSMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Subgroup.toSubmonoid.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1))) (Subgroup.{u1} G _inst_1) (fun (a : Subgroup.{u1} G _inst_1) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Subgroup.{u1} G _inst_1) => Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1)) a) (Equiv.instFunLikeEquiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1))) (Subgroup.opposite.{u1} G _inst_1) H)))) h y) (Set.preimage.{u1, u1} G G (fun (x._@.Mathlib.GroupTheory.Subgroup.Pointwise._hyg.2255 : G) => HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g x._@.Mathlib.GroupTheory.Subgroup.Pointwise._hyg.2255) s)) (Set.preimage.{u1, u1} G G (fun (x._@.Mathlib.GroupTheory.Subgroup.Pointwise._hyg.2270 : G) => HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g x._@.Mathlib.GroupTheory.Subgroup.Pointwise._hyg.2270) (Set.image.{u1, u1} G G (fun (y : G) => HSMul.hSMul.{u1, u1, u1} (Subtype.{succ u1} (MulOpposite.{u1} G) (fun (x : MulOpposite.{u1} G) => Membership.mem.{u1, u1} (MulOpposite.{u1} G) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Subgroup.{u1} G _inst_1) => Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1)) H) (SetLike.instMembership.{u1, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Subgroup.{u1} G _inst_1) => Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1)) H) (MulOpposite.{u1} G) (Subgroup.instSetLikeSubgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1))) x (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1))) (Subgroup.{u1} G _inst_1) (fun (a : Subgroup.{u1} G _inst_1) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Subgroup.{u1} G _inst_1) => Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1)) a) (Equiv.instFunLikeEquiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1))) (Subgroup.opposite.{u1} G _inst_1) H))) G G (instHSMul.{u1, u1} (Subtype.{succ u1} (MulOpposite.{u1} G) (fun (x : MulOpposite.{u1} G) => Membership.mem.{u1, u1} (MulOpposite.{u1} G) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Subgroup.{u1} G _inst_1) => Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1)) H) (SetLike.instMembership.{u1, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Subgroup.{u1} G _inst_1) => Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1)) H) (MulOpposite.{u1} G) (Subgroup.instSetLikeSubgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1))) x (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1))) (Subgroup.{u1} G _inst_1) (fun (a : Subgroup.{u1} G _inst_1) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Subgroup.{u1} G _inst_1) => Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1)) a) (Equiv.instFunLikeEquiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1))) (Subgroup.opposite.{u1} G _inst_1) H))) G (Submonoid.smul.{u1, u1} (MulOpposite.{u1} G) G (Monoid.toMulOneClass.{u1} (MulOpposite.{u1} G) (DivInvMonoid.toMonoid.{u1} (MulOpposite.{u1} G) (Group.toDivInvMonoid.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1)))) (Mul.toHasOppositeSMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Subgroup.toSubmonoid.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1))) (Subgroup.{u1} G _inst_1) (fun (a : Subgroup.{u1} G _inst_1) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Subgroup.{u1} G _inst_1) => Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1)) a) (Equiv.instFunLikeEquiv.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} (MulOpposite.{u1} G) (MulOpposite.instGroupMulOpposite.{u1} G _inst_1))) (Subgroup.opposite.{u1} G _inst_1) H)))) h y) s))
Case conversion may be inaccurate. Consider using '#align subgroup.smul_opposite_image_mul_preimage Subgroup.smul_opposite_image_mul_preimageₓ'. -/
@[to_additive]
theorem smul_opposite_image_mul_preimage {H : Subgroup G} (g : G) (h : H.opposite) (s : Set G) :
    (fun y => h • y) '' (Mul.mul g ⁻¹' s) = Mul.mul g ⁻¹' ((fun y => h • y) '' s) :=
  by
  ext x
  cases h
  simp [(· • ·), mul_assoc]
#align subgroup.smul_opposite_image_mul_preimage Subgroup.smul_opposite_image_mul_preimage
#align add_subgroup.vadd_opposite_image_add_preimage AddSubgroup.vadd_opposite_image_add_preimage

/-! ### Pointwise action -/


section Monoid

variable [Monoid α] [MulDistribMulAction α G]

#print Subgroup.pointwiseMulAction /-
/-- The action on a subgroup corresponding to applying the action to every element.

This is available as an instance in the `pointwise` locale. -/
protected def pointwiseMulAction : MulAction α (Subgroup G)
    where
  smul a S := S.map (MulDistribMulAction.toMonoidEnd _ _ a)
  one_smul S := (congr_arg (fun f => S.map f) (MonoidHom.map_one _)).trans S.map_id
  mul_smul a₁ a₂ S :=
    (congr_arg (fun f => S.map f) (MonoidHom.map_mul _ _ _)).trans (S.map_map _ _).symm
#align subgroup.pointwise_mul_action Subgroup.pointwiseMulAction
-/

scoped[Pointwise] attribute [instance] Subgroup.pointwiseMulAction

open Pointwise

/- warning: subgroup.pointwise_smul_def -> Subgroup.pointwise_smul_def is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Monoid.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G _inst_3 (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] {a : α} (S : Subgroup.{u2} G _inst_1), Eq.{succ u2} (Subgroup.{u2} G _inst_1) (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) _inst_3 (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 _inst_3 _inst_4)) a S) (Subgroup.map.{u2, u2} G _inst_1 G _inst_1 (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} α (Monoid.End.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Monoid.toMulOneClass.{u1} α _inst_3) (Monoid.toMulOneClass.{u2} (Monoid.End.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Monoid.End.monoid.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))) (fun (_x : MonoidHom.{u1, u2} α (Monoid.End.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Monoid.toMulOneClass.{u1} α _inst_3) (Monoid.toMulOneClass.{u2} (Monoid.End.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Monoid.End.monoid.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))) => α -> (Monoid.End.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (MonoidHom.hasCoeToFun.{u1, u2} α (Monoid.End.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Monoid.toMulOneClass.{u1} α _inst_3) (Monoid.toMulOneClass.{u2} (Monoid.End.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Monoid.End.monoid.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))) (MulDistribMulAction.toMonoidEnd.{u1, u2} α G _inst_3 (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)) _inst_4) a) S)
but is expected to have type
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Monoid.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G _inst_3 (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] {a : α} (S : Subgroup.{u2} G _inst_1), Eq.{succ u2} (Subgroup.{u2} G _inst_1) (HSMul.hSMul.{u1, u2, u2} α (Subgroup.{u2} G _inst_1) (Subgroup.{u2} G _inst_1) (instHSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) _inst_3 (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 _inst_3 _inst_4))) a S) (Subgroup.map.{u2, u2} G _inst_1 G _inst_1 (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (MonoidHom.{u1, u2} α (Monoid.End.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Monoid.toMulOneClass.{u1} α _inst_3) (Monoid.toMulOneClass.{u2} (Monoid.End.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Monoid.End.instMonoidEnd.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : α) => Monoid.End.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (MonoidHom.{u1, u2} α (Monoid.End.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Monoid.toMulOneClass.{u1} α _inst_3) (Monoid.toMulOneClass.{u2} (Monoid.End.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Monoid.End.instMonoidEnd.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))) α (Monoid.End.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u1} α (Monoid.toMulOneClass.{u1} α _inst_3)) (MulOneClass.toMul.{u2} (Monoid.End.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Monoid.toMulOneClass.{u2} (Monoid.End.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Monoid.End.instMonoidEnd.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u1, u2} (MonoidHom.{u1, u2} α (Monoid.End.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Monoid.toMulOneClass.{u1} α _inst_3) (Monoid.toMulOneClass.{u2} (Monoid.End.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Monoid.End.instMonoidEnd.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))) α (Monoid.End.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Monoid.toMulOneClass.{u1} α _inst_3) (Monoid.toMulOneClass.{u2} (Monoid.End.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Monoid.End.instMonoidEnd.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (MonoidHom.monoidHomClass.{u1, u2} α (Monoid.End.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Monoid.toMulOneClass.{u1} α _inst_3) (Monoid.toMulOneClass.{u2} (Monoid.End.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (Monoid.End.instMonoidEnd.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))))) (MulDistribMulAction.toMonoidEnd.{u1, u2} α G _inst_3 (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)) _inst_4) a) S)
Case conversion may be inaccurate. Consider using '#align subgroup.pointwise_smul_def Subgroup.pointwise_smul_defₓ'. -/
theorem pointwise_smul_def {a : α} (S : Subgroup G) :
    a • S = S.map (MulDistribMulAction.toMonoidEnd _ _ a) :=
  rfl
#align subgroup.pointwise_smul_def Subgroup.pointwise_smul_def

/- warning: subgroup.coe_pointwise_smul -> Subgroup.coe_pointwise_smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Monoid.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G _inst_3 (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] (a : α) (S : Subgroup.{u2} G _inst_1), Eq.{succ u2} (Set.{u2} G) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Subgroup.{u2} G _inst_1) (Set.{u2} G) (HasLiftT.mk.{succ u2, succ u2} (Subgroup.{u2} G _inst_1) (Set.{u2} G) (CoeTCₓ.coe.{succ u2, succ u2} (Subgroup.{u2} G _inst_1) (Set.{u2} G) (SetLike.Set.hasCoeT.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)))) (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) _inst_3 (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 _inst_3 _inst_4)) a S)) (SMul.smul.{u1, u2} α (Set.{u2} G) (Set.smulSet.{u1, u2} α G (MulAction.toHasSmul.{u1, u2} α G _inst_3 (MulDistribMulAction.toMulAction.{u1, u2} α G _inst_3 (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)) _inst_4))) a ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Subgroup.{u2} G _inst_1) (Set.{u2} G) (HasLiftT.mk.{succ u2, succ u2} (Subgroup.{u2} G _inst_1) (Set.{u2} G) (CoeTCₓ.coe.{succ u2, succ u2} (Subgroup.{u2} G _inst_1) (Set.{u2} G) (SetLike.Set.hasCoeT.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)))) S))
but is expected to have type
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Monoid.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G _inst_3 (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] (a : α) (S : Subgroup.{u2} G _inst_1), Eq.{succ u2} (Set.{u2} G) (SetLike.coe.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1) (HSMul.hSMul.{u1, u2, u2} α (Subgroup.{u2} G _inst_1) (Subgroup.{u2} G _inst_1) (instHSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) _inst_3 (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 _inst_3 _inst_4))) a S)) (HSMul.hSMul.{u1, u2, u2} α (Set.{u2} G) (Set.{u2} G) (instHSMul.{u1, u2} α (Set.{u2} G) (Set.smulSet.{u1, u2} α G (MulAction.toSMul.{u1, u2} α G _inst_3 (MulDistribMulAction.toMulAction.{u1, u2} α G _inst_3 (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)) _inst_4)))) a (SetLike.coe.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1) S))
Case conversion may be inaccurate. Consider using '#align subgroup.coe_pointwise_smul Subgroup.coe_pointwise_smulₓ'. -/
@[simp]
theorem coe_pointwise_smul (a : α) (S : Subgroup G) : ↑(a • S) = a • (S : Set G) :=
  rfl
#align subgroup.coe_pointwise_smul Subgroup.coe_pointwise_smul

#print Subgroup.pointwise_smul_toSubmonoid /-
@[simp]
theorem pointwise_smul_toSubmonoid (a : α) (S : Subgroup G) :
    (a • S).toSubmonoid = a • S.toSubmonoid :=
  rfl
#align subgroup.pointwise_smul_to_submonoid Subgroup.pointwise_smul_toSubmonoid
-/

/- warning: subgroup.smul_mem_pointwise_smul -> Subgroup.smul_mem_pointwise_smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Monoid.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G _inst_3 (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] (m : G) (a : α) (S : Subgroup.{u2} G _inst_1), (Membership.Mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)) m S) -> (Membership.Mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)) (SMul.smul.{u1, u2} α G (MulAction.toHasSmul.{u1, u2} α G _inst_3 (MulDistribMulAction.toMulAction.{u1, u2} α G _inst_3 (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)) _inst_4)) a m) (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) _inst_3 (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 _inst_3 _inst_4)) a S))
but is expected to have type
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Monoid.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G _inst_3 (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] (m : G) (a : α) (S : Subgroup.{u2} G _inst_1), (Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) m S) -> (Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) (HSMul.hSMul.{u1, u2, u2} α G G (instHSMul.{u1, u2} α G (MulAction.toSMul.{u1, u2} α G _inst_3 (MulDistribMulAction.toMulAction.{u1, u2} α G _inst_3 (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)) _inst_4))) a m) (HSMul.hSMul.{u1, u2, u2} α (Subgroup.{u2} G _inst_1) (Subgroup.{u2} G _inst_1) (instHSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) _inst_3 (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 _inst_3 _inst_4))) a S))
Case conversion may be inaccurate. Consider using '#align subgroup.smul_mem_pointwise_smul Subgroup.smul_mem_pointwise_smulₓ'. -/
theorem smul_mem_pointwise_smul (m : G) (a : α) (S : Subgroup G) : m ∈ S → a • m ∈ a • S :=
  (Set.smul_mem_smul_set : _ → _ ∈ a • (S : Set G))
#align subgroup.smul_mem_pointwise_smul Subgroup.smul_mem_pointwise_smul

/- warning: subgroup.mem_smul_pointwise_iff_exists -> Subgroup.mem_smul_pointwise_iff_exists is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Monoid.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G _inst_3 (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] (m : G) (a : α) (S : Subgroup.{u2} G _inst_1), Iff (Membership.Mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)) m (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) _inst_3 (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 _inst_3 _inst_4)) a S)) (Exists.{succ u2} G (fun (s : G) => And (Membership.Mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)) s S) (Eq.{succ u2} G (SMul.smul.{u1, u2} α G (MulAction.toHasSmul.{u1, u2} α G _inst_3 (MulDistribMulAction.toMulAction.{u1, u2} α G _inst_3 (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)) _inst_4)) a s) m)))
but is expected to have type
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Monoid.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G _inst_3 (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] (m : G) (a : α) (S : Subgroup.{u2} G _inst_1), Iff (Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) m (HSMul.hSMul.{u1, u2, u2} α (Subgroup.{u2} G _inst_1) (Subgroup.{u2} G _inst_1) (instHSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) _inst_3 (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 _inst_3 _inst_4))) a S)) (Exists.{succ u2} G (fun (s : G) => And (Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) s S) (Eq.{succ u2} G (HSMul.hSMul.{u1, u2, u2} α G G (instHSMul.{u1, u2} α G (MulAction.toSMul.{u1, u2} α G _inst_3 (MulDistribMulAction.toMulAction.{u1, u2} α G _inst_3 (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)) _inst_4))) a s) m)))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_smul_pointwise_iff_exists Subgroup.mem_smul_pointwise_iff_existsₓ'. -/
theorem mem_smul_pointwise_iff_exists (m : G) (a : α) (S : Subgroup G) :
    m ∈ a • S ↔ ∃ s : G, s ∈ S ∧ a • s = m :=
  (Set.mem_smul_set : m ∈ a • (S : Set G) ↔ _)
#align subgroup.mem_smul_pointwise_iff_exists Subgroup.mem_smul_pointwise_iff_exists

/- warning: subgroup.smul_bot -> Subgroup.smul_bot is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Monoid.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G _inst_3 (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] (a : α), Eq.{succ u2} (Subgroup.{u2} G _inst_1) (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) _inst_3 (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 _inst_3 _inst_4)) a (Bot.bot.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.hasBot.{u2} G _inst_1))) (Bot.bot.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.hasBot.{u2} G _inst_1))
but is expected to have type
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Monoid.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G _inst_3 (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] (a : α), Eq.{succ u2} (Subgroup.{u2} G _inst_1) (HSMul.hSMul.{u1, u2, u2} α (Subgroup.{u2} G _inst_1) (Subgroup.{u2} G _inst_1) (instHSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) _inst_3 (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 _inst_3 _inst_4))) a (Bot.bot.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instBotSubgroup.{u2} G _inst_1))) (Bot.bot.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instBotSubgroup.{u2} G _inst_1))
Case conversion may be inaccurate. Consider using '#align subgroup.smul_bot Subgroup.smul_botₓ'. -/
@[simp]
theorem smul_bot (a : α) : a • (⊥ : Subgroup G) = ⊥ :=
  map_bot _
#align subgroup.smul_bot Subgroup.smul_bot

/- warning: subgroup.smul_sup -> Subgroup.smul_sup is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Monoid.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G _inst_3 (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] (a : α) (S : Subgroup.{u2} G _inst_1) (T : Subgroup.{u2} G _inst_1), Eq.{succ u2} (Subgroup.{u2} G _inst_1) (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) _inst_3 (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 _inst_3 _inst_4)) a (HasSup.sup.{u2} (Subgroup.{u2} G _inst_1) (SemilatticeSup.toHasSup.{u2} (Subgroup.{u2} G _inst_1) (Lattice.toSemilatticeSup.{u2} (Subgroup.{u2} G _inst_1) (ConditionallyCompleteLattice.toLattice.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.completeLattice.{u2} G _inst_1))))) S T)) (HasSup.sup.{u2} (Subgroup.{u2} G _inst_1) (SemilatticeSup.toHasSup.{u2} (Subgroup.{u2} G _inst_1) (Lattice.toSemilatticeSup.{u2} (Subgroup.{u2} G _inst_1) (ConditionallyCompleteLattice.toLattice.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.completeLattice.{u2} G _inst_1))))) (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) _inst_3 (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 _inst_3 _inst_4)) a S) (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) _inst_3 (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 _inst_3 _inst_4)) a T))
but is expected to have type
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Monoid.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G _inst_3 (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] (a : α) (S : Subgroup.{u2} G _inst_1) (T : Subgroup.{u2} G _inst_1), Eq.{succ u2} (Subgroup.{u2} G _inst_1) (HSMul.hSMul.{u1, u2, u2} α (Subgroup.{u2} G _inst_1) (Subgroup.{u2} G _inst_1) (instHSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) _inst_3 (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 _inst_3 _inst_4))) a (HasSup.sup.{u2} (Subgroup.{u2} G _inst_1) (SemilatticeSup.toHasSup.{u2} (Subgroup.{u2} G _inst_1) (Lattice.toSemilatticeSup.{u2} (Subgroup.{u2} G _inst_1) (ConditionallyCompleteLattice.toLattice.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))))) S T)) (HasSup.sup.{u2} (Subgroup.{u2} G _inst_1) (SemilatticeSup.toHasSup.{u2} (Subgroup.{u2} G _inst_1) (Lattice.toSemilatticeSup.{u2} (Subgroup.{u2} G _inst_1) (ConditionallyCompleteLattice.toLattice.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))))) (HSMul.hSMul.{u1, u2, u2} α (Subgroup.{u2} G _inst_1) (Subgroup.{u2} G _inst_1) (instHSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) _inst_3 (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 _inst_3 _inst_4))) a S) (HSMul.hSMul.{u1, u2, u2} α (Subgroup.{u2} G _inst_1) (Subgroup.{u2} G _inst_1) (instHSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) _inst_3 (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 _inst_3 _inst_4))) a T))
Case conversion may be inaccurate. Consider using '#align subgroup.smul_sup Subgroup.smul_supₓ'. -/
theorem smul_sup (a : α) (S T : Subgroup G) : a • (S ⊔ T) = a • S ⊔ a • T :=
  map_sup _ _ _
#align subgroup.smul_sup Subgroup.smul_sup

#print Subgroup.smul_closure /-
theorem smul_closure (a : α) (s : Set G) : a • closure s = closure (a • s) :=
  MonoidHom.map_closure _ _
#align subgroup.smul_closure Subgroup.smul_closure
-/

/- warning: subgroup.pointwise_central_scalar -> Subgroup.pointwise_isCentralScalar is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Monoid.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G _inst_3 (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] [_inst_5 : MulDistribMulAction.{u1, u2} (MulOpposite.{u1} α) G (MulOpposite.monoid.{u1} α _inst_3) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] [_inst_6 : IsCentralScalar.{u1, u2} α G (MulAction.toHasSmul.{u1, u2} α G _inst_3 (MulDistribMulAction.toMulAction.{u1, u2} α G _inst_3 (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)) _inst_4)) (MulAction.toHasSmul.{u1, u2} (MulOpposite.{u1} α) G (MulOpposite.monoid.{u1} α _inst_3) (MulDistribMulAction.toMulAction.{u1, u2} (MulOpposite.{u1} α) G (MulOpposite.monoid.{u1} α _inst_3) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)) _inst_5))], IsCentralScalar.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) _inst_3 (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 _inst_3 _inst_4)) (MulAction.toHasSmul.{u1, u2} (MulOpposite.{u1} α) (Subgroup.{u2} G _inst_1) (MulOpposite.monoid.{u1} α _inst_3) (Subgroup.pointwiseMulAction.{u1, u2} (MulOpposite.{u1} α) G _inst_1 (MulOpposite.monoid.{u1} α _inst_3) _inst_5))
but is expected to have type
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Monoid.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G _inst_3 (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] [_inst_5 : MulDistribMulAction.{u1, u2} (MulOpposite.{u1} α) G (MulOpposite.instMonoidMulOpposite.{u1} α _inst_3) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] [_inst_6 : IsCentralScalar.{u1, u2} α G (MulAction.toSMul.{u1, u2} α G _inst_3 (MulDistribMulAction.toMulAction.{u1, u2} α G _inst_3 (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)) _inst_4)) (MulAction.toSMul.{u1, u2} (MulOpposite.{u1} α) G (MulOpposite.instMonoidMulOpposite.{u1} α _inst_3) (MulDistribMulAction.toMulAction.{u1, u2} (MulOpposite.{u1} α) G (MulOpposite.instMonoidMulOpposite.{u1} α _inst_3) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)) _inst_5))], IsCentralScalar.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) _inst_3 (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 _inst_3 _inst_4)) (MulAction.toSMul.{u1, u2} (MulOpposite.{u1} α) (Subgroup.{u2} G _inst_1) (MulOpposite.instMonoidMulOpposite.{u1} α _inst_3) (Subgroup.pointwiseMulAction.{u1, u2} (MulOpposite.{u1} α) G _inst_1 (MulOpposite.instMonoidMulOpposite.{u1} α _inst_3) _inst_5))
Case conversion may be inaccurate. Consider using '#align subgroup.pointwise_central_scalar Subgroup.pointwise_isCentralScalarₓ'. -/
instance pointwise_isCentralScalar [MulDistribMulAction αᵐᵒᵖ G] [IsCentralScalar α G] :
    IsCentralScalar α (Subgroup G) :=
  ⟨fun a S => (congr_arg fun f => S.map f) <| MonoidHom.ext <| op_smul_eq_smul _⟩
#align subgroup.pointwise_central_scalar Subgroup.pointwise_isCentralScalar

/- warning: subgroup.conj_smul_le_of_le -> Subgroup.conj_smul_le_of_le is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {P : Subgroup.{u1} G _inst_1} {H : Subgroup.{u1} G _inst_1}, (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) P H) -> (forall (h : coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H), LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (SMul.smul.{u1, u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Subgroup.{u1} G _inst_1) (MulAction.toHasSmul.{u1, u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Subgroup.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.group.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) (Subgroup.pointwiseMulAction.{u1, u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) G _inst_1 (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.group.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) (MulAut.applyMulDistribMulAction.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.group.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))) (fun (_x : MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.group.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))) => G -> (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (MonoidHom.hasCoeToFun.{u1, u1} G (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.group.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))) (MulAut.conj.{u1} G _inst_1) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H))))) h)) P) H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {P : Subgroup.{u1} G _inst_1} {H : Subgroup.{u1} G _inst_1}, (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) P H) -> (forall (h : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)), LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (HSMul.hSMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) h)) (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (instHSMul.{u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) h)) (Subgroup.{u1} G _inst_1) (MulAction.toSMul.{u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) h)) (Subgroup.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) h)) (Group.toDivInvMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) h)) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) (Subgroup.pointwiseMulAction.{u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) h)) G _inst_1 (DivInvMonoid.toMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) h)) (Group.toDivInvMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) h)) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) (MulAut.applyMulDistribMulAction.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))) G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))) G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))) (MonoidHom.monoidHomClass.{u1, u1} G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))))) (MulAut.conj.{u1} G _inst_1) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) h)) P) H)
Case conversion may be inaccurate. Consider using '#align subgroup.conj_smul_le_of_le Subgroup.conj_smul_le_of_leₓ'. -/
theorem conj_smul_le_of_le {P H : Subgroup G} (hP : P ≤ H) (h : H) : MulAut.conj (h : G) • P ≤ H :=
  by
  rintro - ⟨g, hg, rfl⟩
  exact H.mul_mem (H.mul_mem h.2 (hP hg)) (H.inv_mem h.2)
#align subgroup.conj_smul_le_of_le Subgroup.conj_smul_le_of_le

/- warning: subgroup.conj_smul_subgroup_of -> Subgroup.conj_smul_subgroupOf is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {P : Subgroup.{u1} G _inst_1} {H : Subgroup.{u1} G _inst_1}, (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) P H) -> (forall (h : coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H), Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)) (SMul.smul.{u1, u1} (MulAut.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (MulOneClass.toHasMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)) (MulAction.toHasSmul.{u1, u1} (MulAut.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (MulOneClass.toHasMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (MulOneClass.toHasMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (MulOneClass.toHasMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (MulAut.group.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (MulOneClass.toHasMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))))))) (Subgroup.pointwiseMulAction.{u1, u1} (MulAut.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (MulOneClass.toHasMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (MulOneClass.toHasMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (MulOneClass.toHasMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (MulAut.group.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (MulOneClass.toHasMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))))))) (MulAut.applyMulDistribMulAction.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (MulAut.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (MulOneClass.toHasMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (MulOneClass.toHasMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (MulOneClass.toHasMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (MulOneClass.toHasMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (MulAut.group.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (MulOneClass.toHasMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))))))))) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (MulAut.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (MulOneClass.toHasMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (MulOneClass.toHasMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (MulOneClass.toHasMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (MulOneClass.toHasMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (MulAut.group.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (MulOneClass.toHasMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))))))))) => (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) -> (MulAut.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (MulOneClass.toHasMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H))))))) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (MulAut.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (MulOneClass.toHasMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (MulOneClass.toHasMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (MulOneClass.toHasMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (MulOneClass.toHasMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (MulAut.group.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (MulOneClass.toHasMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)))))))))) (MulAut.conj.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) (Subgroup.toGroup.{u1} G _inst_1 H)) h) (Subgroup.subgroupOf.{u1} G _inst_1 P H)) (Subgroup.subgroupOf.{u1} G _inst_1 (SMul.smul.{u1, u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Subgroup.{u1} G _inst_1) (MulAction.toHasSmul.{u1, u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Subgroup.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.group.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) (Subgroup.pointwiseMulAction.{u1, u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) G _inst_1 (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.group.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) (MulAut.applyMulDistribMulAction.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.group.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))) (fun (_x : MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.group.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))) => G -> (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (MonoidHom.hasCoeToFun.{u1, u1} G (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.group.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))) (MulAut.conj.{u1} G _inst_1) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) H) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x H))))) h)) P) H))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {P : Subgroup.{u1} G _inst_1} {H : Subgroup.{u1} G _inst_1}, (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) P H) -> (forall (h : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)), Eq.{succ u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)) (HSMul.hSMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) => MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) h) (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)) (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)) (instHSMul.{u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) => MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) h) (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)) (MulAction.toSMul.{u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) => MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) h) (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)) (DivInvMonoid.toMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) => MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) h) (Group.toDivInvMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) => MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) h) (MulAut.instGroupMulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))))) (Subgroup.pointwiseMulAction.{u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) => MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) h) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H) (DivInvMonoid.toMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) => MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) h) (Group.toDivInvMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) => MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) h) (MulAut.instGroupMulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))))) (MulAut.applyMulDistribMulAction.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H))))))) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (MulAut.instGroupMulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))))))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (fun (_x : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) => MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (MulAut.instGroupMulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))))))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H))))) (MulOneClass.toMul.{u1} (MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (MulAut.instGroupMulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (MulAut.instGroupMulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))))))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (MulAut.instGroupMulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H))))))))) (MonoidHom.monoidHomClass.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))) (MulAut.instGroupMulAut.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Monoid.toMulOneClass.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (DivInvMonoid.toMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Group.toDivInvMonoid.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)))))))))))) (MulAut.conj.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x H)) (Subgroup.toGroup.{u1} G _inst_1 H)) h) (Subgroup.subgroupOf.{u1} G _inst_1 P H)) (Subgroup.subgroupOf.{u1} G _inst_1 (HSMul.hSMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) h)) (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (instHSMul.{u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) h)) (Subgroup.{u1} G _inst_1) (MulAction.toSMul.{u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) h)) (Subgroup.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) h)) (Group.toDivInvMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) h)) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) (Subgroup.pointwiseMulAction.{u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) h)) G _inst_1 (DivInvMonoid.toMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) h)) (Group.toDivInvMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) h)) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) (MulAut.applyMulDistribMulAction.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))) G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))) G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))) (MonoidHom.monoidHomClass.{u1, u1} G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))))) (MulAut.conj.{u1} G _inst_1) (Subtype.val.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) x (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) h)) P) H))
Case conversion may be inaccurate. Consider using '#align subgroup.conj_smul_subgroup_of Subgroup.conj_smul_subgroupOfₓ'. -/
theorem conj_smul_subgroupOf {P H : Subgroup G} (hP : P ≤ H) (h : H) :
    MulAut.conj h • P.subgroupOf H = (MulAut.conj (h : G) • P).subgroupOf H :=
  by
  refine' le_antisymm _ _
  · rintro - ⟨g, hg, rfl⟩
    exact ⟨g, hg, rfl⟩
  · rintro p ⟨g, hg, hp⟩
    exact ⟨⟨g, hP hg⟩, hg, Subtype.ext hp⟩
#align subgroup.conj_smul_subgroup_of Subgroup.conj_smul_subgroupOf

end Monoid

section Group

variable [Group α] [MulDistribMulAction α G]

open Pointwise

/- warning: subgroup.smul_mem_pointwise_smul_iff -> Subgroup.smul_mem_pointwise_smul_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Group.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] {a : α} {S : Subgroup.{u2} G _inst_1} {x : G}, Iff (Membership.Mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)) (SMul.smul.{u1, u2} α G (MulAction.toHasSmul.{u1, u2} α G (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (MulDistribMulAction.toMulAction.{u1, u2} α G (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)) _inst_4)) a x) (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) a S)) (Membership.Mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)) x S)
but is expected to have type
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Group.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] {a : α} {S : Subgroup.{u2} G _inst_1} {x : G}, Iff (Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) (HSMul.hSMul.{u1, u2, u2} α G G (instHSMul.{u1, u2} α G (MulAction.toSMul.{u1, u2} α G (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (MulDistribMulAction.toMulAction.{u1, u2} α G (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)) _inst_4))) a x) (HSMul.hSMul.{u1, u2, u2} α (Subgroup.{u2} G _inst_1) (Subgroup.{u2} G _inst_1) (instHSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) a S)) (Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x S)
Case conversion may be inaccurate. Consider using '#align subgroup.smul_mem_pointwise_smul_iff Subgroup.smul_mem_pointwise_smul_iffₓ'. -/
@[simp]
theorem smul_mem_pointwise_smul_iff {a : α} {S : Subgroup G} {x : G} : a • x ∈ a • S ↔ x ∈ S :=
  smul_mem_smul_set_iff
#align subgroup.smul_mem_pointwise_smul_iff Subgroup.smul_mem_pointwise_smul_iff

/- warning: subgroup.mem_pointwise_smul_iff_inv_smul_mem -> Subgroup.mem_pointwise_smul_iff_inv_smul_mem is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Group.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] {a : α} {S : Subgroup.{u2} G _inst_1} {x : G}, Iff (Membership.Mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)) x (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) a S)) (Membership.Mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)) (SMul.smul.{u1, u2} α G (MulAction.toHasSmul.{u1, u2} α G (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (MulDistribMulAction.toMulAction.{u1, u2} α G (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)) _inst_4)) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) a) x) S)
but is expected to have type
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Group.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] {a : α} {S : Subgroup.{u2} G _inst_1} {x : G}, Iff (Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x (HSMul.hSMul.{u1, u2, u2} α (Subgroup.{u2} G _inst_1) (Subgroup.{u2} G _inst_1) (instHSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) a S)) (Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) (HSMul.hSMul.{u1, u2, u2} α G G (instHSMul.{u1, u2} α G (MulAction.toSMul.{u1, u2} α G (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (MulDistribMulAction.toMulAction.{u1, u2} α G (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)) _inst_4))) (Inv.inv.{u1} α (InvOneClass.toInv.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (Group.toDivisionMonoid.{u1} α _inst_3)))) a) x) S)
Case conversion may be inaccurate. Consider using '#align subgroup.mem_pointwise_smul_iff_inv_smul_mem Subgroup.mem_pointwise_smul_iff_inv_smul_memₓ'. -/
theorem mem_pointwise_smul_iff_inv_smul_mem {a : α} {S : Subgroup G} {x : G} :
    x ∈ a • S ↔ a⁻¹ • x ∈ S :=
  mem_smul_set_iff_inv_smul_mem
#align subgroup.mem_pointwise_smul_iff_inv_smul_mem Subgroup.mem_pointwise_smul_iff_inv_smul_mem

/- warning: subgroup.mem_inv_pointwise_smul_iff -> Subgroup.mem_inv_pointwise_smul_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Group.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] {a : α} {S : Subgroup.{u2} G _inst_1} {x : G}, Iff (Membership.Mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)) x (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) a) S)) (Membership.Mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)) (SMul.smul.{u1, u2} α G (MulAction.toHasSmul.{u1, u2} α G (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (MulDistribMulAction.toMulAction.{u1, u2} α G (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)) _inst_4)) a x) S)
but is expected to have type
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Group.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] {a : α} {S : Subgroup.{u2} G _inst_1} {x : G}, Iff (Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x (HSMul.hSMul.{u1, u2, u2} α (Subgroup.{u2} G _inst_1) (Subgroup.{u2} G _inst_1) (instHSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) (Inv.inv.{u1} α (InvOneClass.toInv.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (Group.toDivisionMonoid.{u1} α _inst_3)))) a) S)) (Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) (HSMul.hSMul.{u1, u2, u2} α G G (instHSMul.{u1, u2} α G (MulAction.toSMul.{u1, u2} α G (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (MulDistribMulAction.toMulAction.{u1, u2} α G (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)) _inst_4))) a x) S)
Case conversion may be inaccurate. Consider using '#align subgroup.mem_inv_pointwise_smul_iff Subgroup.mem_inv_pointwise_smul_iffₓ'. -/
theorem mem_inv_pointwise_smul_iff {a : α} {S : Subgroup G} {x : G} : x ∈ a⁻¹ • S ↔ a • x ∈ S :=
  mem_inv_smul_set_iff
#align subgroup.mem_inv_pointwise_smul_iff Subgroup.mem_inv_pointwise_smul_iff

/- warning: subgroup.pointwise_smul_le_pointwise_smul_iff -> Subgroup.pointwise_smul_le_pointwise_smul_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Group.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] {a : α} {S : Subgroup.{u2} G _inst_1} {T : Subgroup.{u2} G _inst_1}, Iff (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)))) (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) a S) (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) a T)) (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)))) S T)
but is expected to have type
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Group.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] {a : α} {S : Subgroup.{u2} G _inst_1} {T : Subgroup.{u2} G _inst_1}, Iff (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))))) (HSMul.hSMul.{u1, u2, u2} α (Subgroup.{u2} G _inst_1) (Subgroup.{u2} G _inst_1) (instHSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) a S) (HSMul.hSMul.{u1, u2, u2} α (Subgroup.{u2} G _inst_1) (Subgroup.{u2} G _inst_1) (instHSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) a T)) (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))))) S T)
Case conversion may be inaccurate. Consider using '#align subgroup.pointwise_smul_le_pointwise_smul_iff Subgroup.pointwise_smul_le_pointwise_smul_iffₓ'. -/
@[simp]
theorem pointwise_smul_le_pointwise_smul_iff {a : α} {S T : Subgroup G} : a • S ≤ a • T ↔ S ≤ T :=
  set_smul_subset_set_smul_iff
#align subgroup.pointwise_smul_le_pointwise_smul_iff Subgroup.pointwise_smul_le_pointwise_smul_iff

/- warning: subgroup.pointwise_smul_subset_iff -> Subgroup.pointwise_smul_subset_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Group.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] {a : α} {S : Subgroup.{u2} G _inst_1} {T : Subgroup.{u2} G _inst_1}, Iff (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)))) (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) a S) T) (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)))) S (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) a) T))
but is expected to have type
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Group.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] {a : α} {S : Subgroup.{u2} G _inst_1} {T : Subgroup.{u2} G _inst_1}, Iff (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))))) (HSMul.hSMul.{u1, u2, u2} α (Subgroup.{u2} G _inst_1) (Subgroup.{u2} G _inst_1) (instHSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) a S) T) (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))))) S (HSMul.hSMul.{u1, u2, u2} α (Subgroup.{u2} G _inst_1) (Subgroup.{u2} G _inst_1) (instHSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) (Inv.inv.{u1} α (InvOneClass.toInv.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (Group.toDivisionMonoid.{u1} α _inst_3)))) a) T))
Case conversion may be inaccurate. Consider using '#align subgroup.pointwise_smul_subset_iff Subgroup.pointwise_smul_subset_iffₓ'. -/
theorem pointwise_smul_subset_iff {a : α} {S T : Subgroup G} : a • S ≤ T ↔ S ≤ a⁻¹ • T :=
  set_smul_subset_iff
#align subgroup.pointwise_smul_subset_iff Subgroup.pointwise_smul_subset_iff

/- warning: subgroup.subset_pointwise_smul_iff -> Subgroup.subset_pointwise_smul_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Group.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] {a : α} {S : Subgroup.{u2} G _inst_1} {T : Subgroup.{u2} G _inst_1}, Iff (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)))) S (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) a T)) (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)))) (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) a) S) T)
but is expected to have type
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Group.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] {a : α} {S : Subgroup.{u2} G _inst_1} {T : Subgroup.{u2} G _inst_1}, Iff (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))))) S (HSMul.hSMul.{u1, u2, u2} α (Subgroup.{u2} G _inst_1) (Subgroup.{u2} G _inst_1) (instHSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) a T)) (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))))) (HSMul.hSMul.{u1, u2, u2} α (Subgroup.{u2} G _inst_1) (Subgroup.{u2} G _inst_1) (instHSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) (Inv.inv.{u1} α (InvOneClass.toInv.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (Group.toDivisionMonoid.{u1} α _inst_3)))) a) S) T)
Case conversion may be inaccurate. Consider using '#align subgroup.subset_pointwise_smul_iff Subgroup.subset_pointwise_smul_iffₓ'. -/
theorem subset_pointwise_smul_iff {a : α} {S T : Subgroup G} : S ≤ a • T ↔ a⁻¹ • S ≤ T :=
  subset_set_smul_iff
#align subgroup.subset_pointwise_smul_iff Subgroup.subset_pointwise_smul_iff

/- warning: subgroup.smul_inf -> Subgroup.smul_inf is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Group.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] (a : α) (S : Subgroup.{u2} G _inst_1) (T : Subgroup.{u2} G _inst_1), Eq.{succ u2} (Subgroup.{u2} G _inst_1) (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) a (HasInf.inf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.hasInf.{u2} G _inst_1) S T)) (HasInf.inf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.hasInf.{u2} G _inst_1) (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) a S) (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) a T))
but is expected to have type
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Group.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] (a : α) (S : Subgroup.{u2} G _inst_1) (T : Subgroup.{u2} G _inst_1), Eq.{succ u2} (Subgroup.{u2} G _inst_1) (HSMul.hSMul.{u1, u2, u2} α (Subgroup.{u2} G _inst_1) (Subgroup.{u2} G _inst_1) (instHSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) a (HasInf.inf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instHasInfSubgroup.{u2} G _inst_1) S T)) (HasInf.inf.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instHasInfSubgroup.{u2} G _inst_1) (HSMul.hSMul.{u1, u2, u2} α (Subgroup.{u2} G _inst_1) (Subgroup.{u2} G _inst_1) (instHSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) a S) (HSMul.hSMul.{u1, u2, u2} α (Subgroup.{u2} G _inst_1) (Subgroup.{u2} G _inst_1) (instHSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) a T))
Case conversion may be inaccurate. Consider using '#align subgroup.smul_inf Subgroup.smul_infₓ'. -/
@[simp]
theorem smul_inf (a : α) (S T : Subgroup G) : a • (S ⊓ T) = a • S ⊓ a • T := by
  simp [SetLike.ext_iff, mem_pointwise_smul_iff_inv_smul_mem]
#align subgroup.smul_inf Subgroup.smul_inf

/- warning: subgroup.equiv_smul -> Subgroup.equivSmul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Group.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] (a : α) (H : Subgroup.{u2} G _inst_1), MulEquiv.{u2, u2} (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G _inst_1) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)) H) (coeSort.{succ u2, succ (succ u2)} (Subgroup.{u2} G _inst_1) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)) (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) a H)) (Subgroup.mul.{u2} G _inst_1 H) (Subgroup.mul.{u2} G _inst_1 (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) a H))
but is expected to have type
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : Group.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] (a : α) (H : Subgroup.{u2} G _inst_1), MulEquiv.{u2, u2} (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x H)) (Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x (HSMul.hSMul.{u1, u2, u2} α (Subgroup.{u2} G _inst_1) (Subgroup.{u2} G _inst_1) (instHSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) a H))) (Subgroup.mul.{u2} G _inst_1 H) (Subgroup.mul.{u2} G _inst_1 (HSMul.hSMul.{u1, u2, u2} α (Subgroup.{u2} G _inst_1) (Subgroup.{u2} G _inst_1) (instHSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toSMul.{u1, u2} α (Subgroup.{u2} G _inst_1) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) a H))
Case conversion may be inaccurate. Consider using '#align subgroup.equiv_smul Subgroup.equivSmulₓ'. -/
/-- Applying a `mul_distrib_mul_action` results in an isomorphic subgroup -/
@[simps]
def equivSmul (a : α) (H : Subgroup G) : H ≃* (a • H : Subgroup G) :=
  (MulDistribMulAction.toMulEquiv G a).subgroupMap H
#align subgroup.equiv_smul Subgroup.equivSmul

/- warning: subgroup.subgroup_mul_singleton -> Subgroup.subgroup_mul_singleton is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {h : G}, (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) h H) -> (Eq.{succ u1} (Set.{u1} G) (HMul.hMul.{u1, u1, u1} (Set.{u1} G) (Set.{u1} G) (Set.{u1} G) (instHMul.{u1} (Set.{u1} G) (Set.mul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H) (Singleton.singleton.{u1, u1} G (Set.{u1} G) (Set.hasSingleton.{u1} G) h)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {h : G}, (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) h H) -> (Eq.{succ u1} (Set.{u1} G) (HMul.hMul.{u1, u1, u1} (Set.{u1} G) (Set.{u1} G) (Set.{u1} G) (instHMul.{u1} (Set.{u1} G) (Set.mul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H) (Singleton.singleton.{u1, u1} G (Set.{u1} G) (Set.instSingletonSet.{u1} G) h)) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H))
Case conversion may be inaccurate. Consider using '#align subgroup.subgroup_mul_singleton Subgroup.subgroup_mul_singletonₓ'. -/
theorem subgroup_mul_singleton {H : Subgroup G} {h : G} (hh : h ∈ H) : (H : Set G) * {h} = H :=
  by
  refine'
    le_antisymm _ fun h' hh' =>
      ⟨h' * h⁻¹, h, H.mul_mem hh' (H.inv_mem hh), rfl, inv_mul_cancel_right h' h⟩
  rintro _ ⟨h', h, hh', rfl : _ = _, rfl⟩
  exact H.mul_mem hh' hh
#align subgroup.subgroup_mul_singleton Subgroup.subgroup_mul_singleton

/- warning: subgroup.singleton_mul_subgroup -> Subgroup.singleton_mul_subgroup is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {h : G}, (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) h H) -> (Eq.{succ u1} (Set.{u1} G) (HMul.hMul.{u1, u1, u1} (Set.{u1} G) (Set.{u1} G) (Set.{u1} G) (instHMul.{u1} (Set.{u1} G) (Set.mul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (Singleton.singleton.{u1, u1} G (Set.{u1} G) (Set.hasSingleton.{u1} G) h) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subgroup.{u1} G _inst_1) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Subgroup.{u1} G _inst_1) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Subgroup.{u1} G _inst_1} {h : G}, (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) h H) -> (Eq.{succ u1} (Set.{u1} G) (HMul.hMul.{u1, u1, u1} (Set.{u1} G) (Set.{u1} G) (Set.{u1} G) (instHMul.{u1} (Set.{u1} G) (Set.mul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (Singleton.singleton.{u1, u1} G (Set.{u1} G) (Set.instSingletonSet.{u1} G) h) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H)) (SetLike.coe.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1) H))
Case conversion may be inaccurate. Consider using '#align subgroup.singleton_mul_subgroup Subgroup.singleton_mul_subgroupₓ'. -/
theorem singleton_mul_subgroup {H : Subgroup G} {h : G} (hh : h ∈ H) : {h} * (H : Set G) = H :=
  by
  refine'
    le_antisymm _ fun h' hh' =>
      ⟨h, h⁻¹ * h', rfl, H.mul_mem (H.inv_mem hh) hh', mul_inv_cancel_left h h'⟩
  rintro _ ⟨h, h', rfl : _ = _, hh', rfl⟩
  exact H.mul_mem hh hh'
#align subgroup.singleton_mul_subgroup Subgroup.singleton_mul_subgroup

/- warning: subgroup.normal.conj_act -> Subgroup.Normal.conjAct is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_5 : Group.{u1} G] {H : Subgroup.{u1} G _inst_5}, (Subgroup.Normal.{u1} G _inst_5 H) -> (forall (g : ConjAct.{u1} G), Eq.{succ u1} (Subgroup.{u1} G _inst_5) (SMul.smul.{u1, u1} (ConjAct.{u1} G) (Subgroup.{u1} G _inst_5) (MulAction.toHasSmul.{u1, u1} (ConjAct.{u1} G) (Subgroup.{u1} G _inst_5) (DivInvMonoid.toMonoid.{u1} (ConjAct.{u1} G) (ConjAct.divInvMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_5))) (Subgroup.pointwiseMulAction.{u1, u1} (ConjAct.{u1} G) G _inst_5 (DivInvMonoid.toMonoid.{u1} (ConjAct.{u1} G) (ConjAct.divInvMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_5))) (ConjAct.mulDistribMulAction.{u1} G _inst_5))) g H) H)
but is expected to have type
  forall {G : Type.{u1}} [_inst_5 : Group.{u1} G] {H : Subgroup.{u1} G _inst_5}, (Subgroup.Normal.{u1} G _inst_5 H) -> (forall (g : ConjAct.{u1} G), Eq.{succ u1} (Subgroup.{u1} G _inst_5) (HSMul.hSMul.{u1, u1, u1} (ConjAct.{u1} G) (Subgroup.{u1} G _inst_5) (Subgroup.{u1} G _inst_5) (instHSMul.{u1, u1} (ConjAct.{u1} G) (Subgroup.{u1} G _inst_5) (MulAction.toSMul.{u1, u1} (ConjAct.{u1} G) (Subgroup.{u1} G _inst_5) (DivInvMonoid.toMonoid.{u1} (ConjAct.{u1} G) (ConjAct.instDivInvMonoidConjAct.{u1} G (Group.toDivInvMonoid.{u1} G _inst_5))) (Subgroup.pointwiseMulAction.{u1, u1} (ConjAct.{u1} G) G _inst_5 (DivInvMonoid.toMonoid.{u1} (ConjAct.{u1} G) (ConjAct.instDivInvMonoidConjAct.{u1} G (Group.toDivInvMonoid.{u1} G _inst_5))) (ConjAct.instMulDistribMulActionConjActToMonoidInstDivInvMonoidConjActToDivInvMonoid.{u1} G _inst_5)))) g H) H)
Case conversion may be inaccurate. Consider using '#align subgroup.normal.conj_act Subgroup.Normal.conjActₓ'. -/
theorem Normal.conjAct {G : Type _} [Group G] {H : Subgroup G} (hH : H.Normal) (g : ConjAct G) :
    g • H = H := by
  ext
  constructor
  · intro h
    have := hH.conj_mem (g⁻¹ • x) _ (ConjAct.ofConjAct g)
    rw [Subgroup.mem_pointwise_smul_iff_inv_smul_mem] at h
    dsimp at *
    rw [ConjAct.smul_def] at *
    simp only [ConjAct.ofConjAct_inv, ConjAct.ofConjAct_toConjAct, inv_inv] at *
    convert this
    simp only [← mul_assoc, mul_right_inv, one_mul, mul_inv_cancel_right]
    rw [Subgroup.mem_pointwise_smul_iff_inv_smul_mem] at h
    exact h
  · intro h
    rw [Subgroup.mem_pointwise_smul_iff_inv_smul_mem, ConjAct.smul_def]
    apply hH.conj_mem
    exact h
#align subgroup.normal.conj_act Subgroup.Normal.conjAct

/- warning: subgroup.smul_normal -> Subgroup.smul_normal is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (g : G) (H : Subgroup.{u1} G _inst_1) [h : Subgroup.Normal.{u1} G _inst_1 H], Eq.{succ u1} (Subgroup.{u1} G _inst_1) (SMul.smul.{u1, u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Subgroup.{u1} G _inst_1) (MulAction.toHasSmul.{u1, u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Subgroup.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.group.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) (Subgroup.pointwiseMulAction.{u1, u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) G _inst_1 (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.group.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) (MulAut.applyMulDistribMulAction.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.group.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))) (fun (_x : MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.group.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))) => G -> (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (MonoidHom.hasCoeToFun.{u1, u1} G (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.group.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))) (MulAut.conj.{u1} G _inst_1) g) H) H
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (g : G) (H : Subgroup.{u1} G _inst_1) [h : Subgroup.Normal.{u1} G _inst_1 H], Eq.{succ u1} (Subgroup.{u1} G _inst_1) (HSMul.hSMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g) (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (instHSMul.{u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g) (Subgroup.{u1} G _inst_1) (MulAction.toSMul.{u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g) (Subgroup.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g) (Group.toDivInvMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) (Subgroup.pointwiseMulAction.{u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g) G _inst_1 (DivInvMonoid.toMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g) (Group.toDivInvMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) (MulAut.applyMulDistribMulAction.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))) G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))) G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))) (MonoidHom.monoidHomClass.{u1, u1} G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))))) (MulAut.conj.{u1} G _inst_1) g) H) H
Case conversion may be inaccurate. Consider using '#align subgroup.smul_normal Subgroup.smul_normalₓ'. -/
@[simp]
theorem smul_normal (g : G) (H : Subgroup G) [h : Normal H] : MulAut.conj g • H = H :=
  h.ConjAct g
#align subgroup.smul_normal Subgroup.smul_normal

end Group

section GroupWithZero

variable [GroupWithZero α] [MulDistribMulAction α G]

open Pointwise

/- warning: subgroup.smul_mem_pointwise_smul_iff₀ -> Subgroup.smul_mem_pointwise_smul_iff₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : GroupWithZero.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)))))))) -> (forall (S : Subgroup.{u2} G _inst_1) (x : G), Iff (Membership.Mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)) (SMul.smul.{u1, u2} α G (MulAction.toHasSmul.{u1, u2} α G (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (MulDistribMulAction.toMulAction.{u1, u2} α G (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)) _inst_4)) a x) (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) a S)) (Membership.Mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)) x S))
but is expected to have type
  forall {α : Type.{u2}} {G : Type.{u1}} [_inst_1 : Group.{u1} G] [_inst_3 : GroupWithZero.{u2} α] [_inst_4 : MulDistribMulAction.{u2, u1} α G (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))] {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3))))) -> (forall (S : Subgroup.{u1} G _inst_1) (x : G), Iff (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (HSMul.hSMul.{u2, u1, u1} α G G (instHSMul.{u2, u1} α G (MulAction.toSMul.{u2, u1} α G (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (MulDistribMulAction.toMulAction.{u2, u1} α G (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) _inst_4))) a x) (HSMul.hSMul.{u2, u1, u1} α (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (instHSMul.{u2, u1} α (Subgroup.{u1} G _inst_1) (MulAction.toSMul.{u2, u1} α (Subgroup.{u1} G _inst_1) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (Subgroup.pointwiseMulAction.{u2, u1} α G _inst_1 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) a S)) (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x S))
Case conversion may be inaccurate. Consider using '#align subgroup.smul_mem_pointwise_smul_iff₀ Subgroup.smul_mem_pointwise_smul_iff₀ₓ'. -/
@[simp]
theorem smul_mem_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) (S : Subgroup G) (x : G) :
    a • x ∈ a • S ↔ x ∈ S :=
  smul_mem_smul_set_iff₀ ha (S : Set G) x
#align subgroup.smul_mem_pointwise_smul_iff₀ Subgroup.smul_mem_pointwise_smul_iff₀

/- warning: subgroup.mem_pointwise_smul_iff_inv_smul_mem₀ -> Subgroup.mem_pointwise_smul_iff_inv_smul_mem₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : GroupWithZero.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)))))))) -> (forall (S : Subgroup.{u2} G _inst_1) (x : G), Iff (Membership.Mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)) x (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) a S)) (Membership.Mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)) (SMul.smul.{u1, u2} α G (MulAction.toHasSmul.{u1, u2} α G (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (MulDistribMulAction.toMulAction.{u1, u2} α G (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)) _inst_4)) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α _inst_3)) a) x) S))
but is expected to have type
  forall {α : Type.{u2}} {G : Type.{u1}} [_inst_1 : Group.{u1} G] [_inst_3 : GroupWithZero.{u2} α] [_inst_4 : MulDistribMulAction.{u2, u1} α G (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))] {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3))))) -> (forall (S : Subgroup.{u1} G _inst_1) (x : G), Iff (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (HSMul.hSMul.{u2, u1, u1} α (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (instHSMul.{u2, u1} α (Subgroup.{u1} G _inst_1) (MulAction.toSMul.{u2, u1} α (Subgroup.{u1} G _inst_1) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (Subgroup.pointwiseMulAction.{u2, u1} α G _inst_1 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) a S)) (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (HSMul.hSMul.{u2, u1, u1} α G G (instHSMul.{u2, u1} α G (MulAction.toSMul.{u2, u1} α G (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (MulDistribMulAction.toMulAction.{u2, u1} α G (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) _inst_4))) (Inv.inv.{u2} α (GroupWithZero.toInv.{u2} α _inst_3) a) x) S))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_pointwise_smul_iff_inv_smul_mem₀ Subgroup.mem_pointwise_smul_iff_inv_smul_mem₀ₓ'. -/
theorem mem_pointwise_smul_iff_inv_smul_mem₀ {a : α} (ha : a ≠ 0) (S : Subgroup G) (x : G) :
    x ∈ a • S ↔ a⁻¹ • x ∈ S :=
  mem_smul_set_iff_inv_smul_mem₀ ha (S : Set G) x
#align subgroup.mem_pointwise_smul_iff_inv_smul_mem₀ Subgroup.mem_pointwise_smul_iff_inv_smul_mem₀

/- warning: subgroup.mem_inv_pointwise_smul_iff₀ -> Subgroup.mem_inv_pointwise_smul_iff₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : GroupWithZero.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)))))))) -> (forall (S : Subgroup.{u2} G _inst_1) (x : G), Iff (Membership.Mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)) x (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α _inst_3)) a) S)) (Membership.Mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.hasMem.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)) (SMul.smul.{u1, u2} α G (MulAction.toHasSmul.{u1, u2} α G (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (MulDistribMulAction.toMulAction.{u1, u2} α G (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)) _inst_4)) a x) S))
but is expected to have type
  forall {α : Type.{u2}} {G : Type.{u1}} [_inst_1 : Group.{u1} G] [_inst_3 : GroupWithZero.{u2} α] [_inst_4 : MulDistribMulAction.{u2, u1} α G (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))] {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3))))) -> (forall (S : Subgroup.{u1} G _inst_1) (x : G), Iff (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (HSMul.hSMul.{u2, u1, u1} α (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (instHSMul.{u2, u1} α (Subgroup.{u1} G _inst_1) (MulAction.toSMul.{u2, u1} α (Subgroup.{u1} G _inst_1) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (Subgroup.pointwiseMulAction.{u2, u1} α G _inst_1 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) (Inv.inv.{u2} α (GroupWithZero.toInv.{u2} α _inst_3) a) S)) (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (HSMul.hSMul.{u2, u1, u1} α G G (instHSMul.{u2, u1} α G (MulAction.toSMul.{u2, u1} α G (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (MulDistribMulAction.toMulAction.{u2, u1} α G (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) _inst_4))) a x) S))
Case conversion may be inaccurate. Consider using '#align subgroup.mem_inv_pointwise_smul_iff₀ Subgroup.mem_inv_pointwise_smul_iff₀ₓ'. -/
theorem mem_inv_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) (S : Subgroup G) (x : G) :
    x ∈ a⁻¹ • S ↔ a • x ∈ S :=
  mem_inv_smul_set_iff₀ ha (S : Set G) x
#align subgroup.mem_inv_pointwise_smul_iff₀ Subgroup.mem_inv_pointwise_smul_iff₀

/- warning: subgroup.pointwise_smul_le_pointwise_smul_iff₀ -> Subgroup.pointwise_smul_le_pointwise_smul_iff₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : GroupWithZero.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)))))))) -> (forall {S : Subgroup.{u2} G _inst_1} {T : Subgroup.{u2} G _inst_1}, Iff (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)))) (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) a S) (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) a T)) (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)))) S T))
but is expected to have type
  forall {α : Type.{u2}} {G : Type.{u1}} [_inst_1 : Group.{u1} G] [_inst_3 : GroupWithZero.{u2} α] [_inst_4 : MulDistribMulAction.{u2, u1} α G (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))] {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3))))) -> (forall {S : Subgroup.{u1} G _inst_1} {T : Subgroup.{u1} G _inst_1}, Iff (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (HSMul.hSMul.{u2, u1, u1} α (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (instHSMul.{u2, u1} α (Subgroup.{u1} G _inst_1) (MulAction.toSMul.{u2, u1} α (Subgroup.{u1} G _inst_1) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (Subgroup.pointwiseMulAction.{u2, u1} α G _inst_1 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) a S) (HSMul.hSMul.{u2, u1, u1} α (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (instHSMul.{u2, u1} α (Subgroup.{u1} G _inst_1) (MulAction.toSMul.{u2, u1} α (Subgroup.{u1} G _inst_1) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (Subgroup.pointwiseMulAction.{u2, u1} α G _inst_1 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) a T)) (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) S T))
Case conversion may be inaccurate. Consider using '#align subgroup.pointwise_smul_le_pointwise_smul_iff₀ Subgroup.pointwise_smul_le_pointwise_smul_iff₀ₓ'. -/
@[simp]
theorem pointwise_smul_le_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) {S T : Subgroup G} :
    a • S ≤ a • T ↔ S ≤ T :=
  set_smul_subset_set_smul_iff₀ ha
#align subgroup.pointwise_smul_le_pointwise_smul_iff₀ Subgroup.pointwise_smul_le_pointwise_smul_iff₀

/- warning: subgroup.pointwise_smul_le_iff₀ -> Subgroup.pointwise_smul_le_iff₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : GroupWithZero.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)))))))) -> (forall {S : Subgroup.{u2} G _inst_1} {T : Subgroup.{u2} G _inst_1}, Iff (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)))) (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) a S) T) (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)))) S (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α _inst_3)) a) T)))
but is expected to have type
  forall {α : Type.{u2}} {G : Type.{u1}} [_inst_1 : Group.{u1} G] [_inst_3 : GroupWithZero.{u2} α] [_inst_4 : MulDistribMulAction.{u2, u1} α G (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))] {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3))))) -> (forall {S : Subgroup.{u1} G _inst_1} {T : Subgroup.{u1} G _inst_1}, Iff (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (HSMul.hSMul.{u2, u1, u1} α (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (instHSMul.{u2, u1} α (Subgroup.{u1} G _inst_1) (MulAction.toSMul.{u2, u1} α (Subgroup.{u1} G _inst_1) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (Subgroup.pointwiseMulAction.{u2, u1} α G _inst_1 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) a S) T) (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) S (HSMul.hSMul.{u2, u1, u1} α (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (instHSMul.{u2, u1} α (Subgroup.{u1} G _inst_1) (MulAction.toSMul.{u2, u1} α (Subgroup.{u1} G _inst_1) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (Subgroup.pointwiseMulAction.{u2, u1} α G _inst_1 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) (Inv.inv.{u2} α (GroupWithZero.toInv.{u2} α _inst_3) a) T)))
Case conversion may be inaccurate. Consider using '#align subgroup.pointwise_smul_le_iff₀ Subgroup.pointwise_smul_le_iff₀ₓ'. -/
theorem pointwise_smul_le_iff₀ {a : α} (ha : a ≠ 0) {S T : Subgroup G} : a • S ≤ T ↔ S ≤ a⁻¹ • T :=
  set_smul_subset_iff₀ ha
#align subgroup.pointwise_smul_le_iff₀ Subgroup.pointwise_smul_le_iff₀

/- warning: subgroup.le_pointwise_smul_iff₀ -> Subgroup.le_pointwise_smul_iff₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] [_inst_3 : GroupWithZero.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α G (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))] {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)))))))) -> (forall {S : Subgroup.{u2} G _inst_1} {T : Subgroup.{u2} G _inst_1}, Iff (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)))) S (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) a T)) (LE.le.{u2} (Subgroup.{u2} G _inst_1) (Preorder.toLE.{u2} (Subgroup.{u2} G _inst_1) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G _inst_1) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.setLike.{u2} G _inst_1)))) (SMul.smul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MulAction.toHasSmul.{u1, u2} α (Subgroup.{u2} G _inst_1) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (Subgroup.pointwiseMulAction.{u1, u2} α G _inst_1 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α _inst_3)) a) S) T))
but is expected to have type
  forall {α : Type.{u2}} {G : Type.{u1}} [_inst_1 : Group.{u1} G] [_inst_3 : GroupWithZero.{u2} α] [_inst_4 : MulDistribMulAction.{u2, u1} α G (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))] {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3))))) -> (forall {S : Subgroup.{u1} G _inst_1} {T : Subgroup.{u1} G _inst_1}, Iff (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) S (HSMul.hSMul.{u2, u1, u1} α (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (instHSMul.{u2, u1} α (Subgroup.{u1} G _inst_1) (MulAction.toSMul.{u2, u1} α (Subgroup.{u1} G _inst_1) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (Subgroup.pointwiseMulAction.{u2, u1} α G _inst_1 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) a T)) (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (HSMul.hSMul.{u2, u1, u1} α (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (instHSMul.{u2, u1} α (Subgroup.{u1} G _inst_1) (MulAction.toSMul.{u2, u1} α (Subgroup.{u1} G _inst_1) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (Subgroup.pointwiseMulAction.{u2, u1} α G _inst_1 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) (Inv.inv.{u2} α (GroupWithZero.toInv.{u2} α _inst_3) a) S) T))
Case conversion may be inaccurate. Consider using '#align subgroup.le_pointwise_smul_iff₀ Subgroup.le_pointwise_smul_iff₀ₓ'. -/
theorem le_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) {S T : Subgroup G} : S ≤ a • T ↔ a⁻¹ • S ≤ T :=
  subset_set_smul_iff₀ ha
#align subgroup.le_pointwise_smul_iff₀ Subgroup.le_pointwise_smul_iff₀

end GroupWithZero

end Subgroup

namespace AddSubgroup

section Monoid

variable [Monoid α] [DistribMulAction α A]

#print AddSubgroup.pointwiseMulAction /-
/-- The action on an additive subgroup corresponding to applying the action to every element.

This is available as an instance in the `pointwise` locale. -/
protected def pointwiseMulAction : MulAction α (AddSubgroup A)
    where
  smul a S := S.map (DistribMulAction.toAddMonoidEnd _ _ a)
  one_smul S := (congr_arg (fun f => S.map f) (MonoidHom.map_one _)).trans S.map_id
  mul_smul a₁ a₂ S :=
    (congr_arg (fun f => S.map f) (MonoidHom.map_mul _ _ _)).trans (S.map_map _ _).symm
#align add_subgroup.pointwise_mul_action AddSubgroup.pointwiseMulAction
-/

scoped[Pointwise] attribute [instance] AddSubgroup.pointwiseMulAction

open Pointwise

/- warning: add_subgroup.coe_pointwise_smul -> AddSubgroup.coe_pointwise_smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddGroup.{u2} A] [_inst_3 : Monoid.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A _inst_3 (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))] (a : α) (S : AddSubgroup.{u2} A _inst_2), Eq.{succ u2} (Set.{u2} A) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (AddSubgroup.{u2} A _inst_2) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (AddSubgroup.{u2} A _inst_2) (Set.{u2} A) (CoeTCₓ.coe.{succ u2, succ u2} (AddSubgroup.{u2} A _inst_2) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)))) (SMul.smul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toHasSmul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) _inst_3 (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 _inst_3 _inst_4)) a S)) (SMul.smul.{u1, u2} α (Set.{u2} A) (Set.smulSet.{u1, u2} α A (SMulZeroClass.toHasSmul.{u1, u2} α A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)))) (DistribSMul.toSmulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))) (DistribMulAction.toDistribSMul.{u1, u2} α A _inst_3 (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)) _inst_4)))) a ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (AddSubgroup.{u2} A _inst_2) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (AddSubgroup.{u2} A _inst_2) (Set.{u2} A) (CoeTCₓ.coe.{succ u2, succ u2} (AddSubgroup.{u2} A _inst_2) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)))) S))
but is expected to have type
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddGroup.{u2} A] [_inst_3 : Monoid.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A _inst_3 (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))] (a : α) (S : AddSubgroup.{u2} A _inst_2), Eq.{succ u2} (Set.{u2} A) (SetLike.coe.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.instSetLikeAddSubgroup.{u2} A _inst_2) (HSMul.hSMul.{u1, u2, u2} α (AddSubgroup.{u2} A _inst_2) (AddSubgroup.{u2} A _inst_2) (instHSMul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toSMul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) _inst_3 (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 _inst_3 _inst_4))) a S)) (HSMul.hSMul.{u1, u2, u2} α (Set.{u2} A) (Set.{u2} A) (instHSMul.{u1, u2} α (Set.{u2} A) (Set.smulSet.{u1, u2} α A (SMulZeroClass.toSMul.{u1, u2} α A (NegZeroClass.toZero.{u2} A (SubNegZeroMonoid.toNegZeroClass.{u2} A (SubtractionMonoid.toSubNegZeroMonoid.{u2} A (AddGroup.toSubtractionMonoid.{u2} A _inst_2)))) (DistribSMul.toSMulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))) (DistribMulAction.toDistribSMul.{u1, u2} α A _inst_3 (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)) _inst_4))))) a (SetLike.coe.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.instSetLikeAddSubgroup.{u2} A _inst_2) S))
Case conversion may be inaccurate. Consider using '#align add_subgroup.coe_pointwise_smul AddSubgroup.coe_pointwise_smulₓ'. -/
@[simp]
theorem coe_pointwise_smul (a : α) (S : AddSubgroup A) : ↑(a • S) = a • (S : Set A) :=
  rfl
#align add_subgroup.coe_pointwise_smul AddSubgroup.coe_pointwise_smul

#print AddSubgroup.pointwise_smul_toAddSubmonoid /-
@[simp]
theorem pointwise_smul_toAddSubmonoid (a : α) (S : AddSubgroup A) :
    (a • S).toAddSubmonoid = a • S.toAddSubmonoid :=
  rfl
#align add_subgroup.pointwise_smul_to_add_submonoid AddSubgroup.pointwise_smul_toAddSubmonoid
-/

/- warning: add_subgroup.smul_mem_pointwise_smul -> AddSubgroup.smul_mem_pointwise_smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddGroup.{u2} A] [_inst_3 : Monoid.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A _inst_3 (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))] (m : A) (a : α) (S : AddSubgroup.{u2} A _inst_2), (Membership.Mem.{u2, u2} A (AddSubgroup.{u2} A _inst_2) (SetLike.hasMem.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)) m S) -> (Membership.Mem.{u2, u2} A (AddSubgroup.{u2} A _inst_2) (SetLike.hasMem.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)) (SMul.smul.{u1, u2} α A (SMulZeroClass.toHasSmul.{u1, u2} α A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)))) (DistribSMul.toSmulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))) (DistribMulAction.toDistribSMul.{u1, u2} α A _inst_3 (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)) _inst_4))) a m) (SMul.smul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toHasSmul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) _inst_3 (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 _inst_3 _inst_4)) a S))
but is expected to have type
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddGroup.{u2} A] [_inst_3 : Monoid.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A _inst_3 (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))] (m : A) (a : α) (S : AddSubgroup.{u2} A _inst_2), (Membership.mem.{u2, u2} A (AddSubgroup.{u2} A _inst_2) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.instSetLikeAddSubgroup.{u2} A _inst_2)) m S) -> (Membership.mem.{u2, u2} A (AddSubgroup.{u2} A _inst_2) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.instSetLikeAddSubgroup.{u2} A _inst_2)) (HSMul.hSMul.{u1, u2, u2} α A A (instHSMul.{u1, u2} α A (SMulZeroClass.toSMul.{u1, u2} α A (NegZeroClass.toZero.{u2} A (SubNegZeroMonoid.toNegZeroClass.{u2} A (SubtractionMonoid.toSubNegZeroMonoid.{u2} A (AddGroup.toSubtractionMonoid.{u2} A _inst_2)))) (DistribSMul.toSMulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))) (DistribMulAction.toDistribSMul.{u1, u2} α A _inst_3 (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)) _inst_4)))) a m) (HSMul.hSMul.{u1, u2, u2} α (AddSubgroup.{u2} A _inst_2) (AddSubgroup.{u2} A _inst_2) (instHSMul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toSMul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) _inst_3 (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 _inst_3 _inst_4))) a S))
Case conversion may be inaccurate. Consider using '#align add_subgroup.smul_mem_pointwise_smul AddSubgroup.smul_mem_pointwise_smulₓ'. -/
theorem smul_mem_pointwise_smul (m : A) (a : α) (S : AddSubgroup A) : m ∈ S → a • m ∈ a • S :=
  (Set.smul_mem_smul_set : _ → _ ∈ a • (S : Set A))
#align add_subgroup.smul_mem_pointwise_smul AddSubgroup.smul_mem_pointwise_smul

/- warning: add_subgroup.mem_smul_pointwise_iff_exists -> AddSubgroup.mem_smul_pointwise_iff_exists is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddGroup.{u2} A] [_inst_3 : Monoid.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A _inst_3 (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))] (m : A) (a : α) (S : AddSubgroup.{u2} A _inst_2), Iff (Membership.Mem.{u2, u2} A (AddSubgroup.{u2} A _inst_2) (SetLike.hasMem.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)) m (SMul.smul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toHasSmul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) _inst_3 (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 _inst_3 _inst_4)) a S)) (Exists.{succ u2} A (fun (s : A) => And (Membership.Mem.{u2, u2} A (AddSubgroup.{u2} A _inst_2) (SetLike.hasMem.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)) s S) (Eq.{succ u2} A (SMul.smul.{u1, u2} α A (SMulZeroClass.toHasSmul.{u1, u2} α A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)))) (DistribSMul.toSmulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))) (DistribMulAction.toDistribSMul.{u1, u2} α A _inst_3 (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)) _inst_4))) a s) m)))
but is expected to have type
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddGroup.{u2} A] [_inst_3 : Monoid.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A _inst_3 (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))] (m : A) (a : α) (S : AddSubgroup.{u2} A _inst_2), Iff (Membership.mem.{u2, u2} A (AddSubgroup.{u2} A _inst_2) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.instSetLikeAddSubgroup.{u2} A _inst_2)) m (HSMul.hSMul.{u1, u2, u2} α (AddSubgroup.{u2} A _inst_2) (AddSubgroup.{u2} A _inst_2) (instHSMul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toSMul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) _inst_3 (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 _inst_3 _inst_4))) a S)) (Exists.{succ u2} A (fun (s : A) => And (Membership.mem.{u2, u2} A (AddSubgroup.{u2} A _inst_2) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.instSetLikeAddSubgroup.{u2} A _inst_2)) s S) (Eq.{succ u2} A (HSMul.hSMul.{u1, u2, u2} α A A (instHSMul.{u1, u2} α A (SMulZeroClass.toSMul.{u1, u2} α A (NegZeroClass.toZero.{u2} A (SubNegZeroMonoid.toNegZeroClass.{u2} A (SubtractionMonoid.toSubNegZeroMonoid.{u2} A (AddGroup.toSubtractionMonoid.{u2} A _inst_2)))) (DistribSMul.toSMulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))) (DistribMulAction.toDistribSMul.{u1, u2} α A _inst_3 (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)) _inst_4)))) a s) m)))
Case conversion may be inaccurate. Consider using '#align add_subgroup.mem_smul_pointwise_iff_exists AddSubgroup.mem_smul_pointwise_iff_existsₓ'. -/
theorem mem_smul_pointwise_iff_exists (m : A) (a : α) (S : AddSubgroup A) :
    m ∈ a • S ↔ ∃ s : A, s ∈ S ∧ a • s = m :=
  (Set.mem_smul_set : m ∈ a • (S : Set A) ↔ _)
#align add_subgroup.mem_smul_pointwise_iff_exists AddSubgroup.mem_smul_pointwise_iff_exists

/- warning: add_subgroup.pointwise_central_scalar -> AddSubgroup.pointwise_isCentralScalar is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddGroup.{u2} A] [_inst_3 : Monoid.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A _inst_3 (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))] [_inst_5 : DistribMulAction.{u1, u2} (MulOpposite.{u1} α) A (MulOpposite.monoid.{u1} α _inst_3) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))] [_inst_6 : IsCentralScalar.{u1, u2} α A (SMulZeroClass.toHasSmul.{u1, u2} α A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)))) (DistribSMul.toSmulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))) (DistribMulAction.toDistribSMul.{u1, u2} α A _inst_3 (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)) _inst_4))) (SMulZeroClass.toHasSmul.{u1, u2} (MulOpposite.{u1} α) A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)))) (DistribSMul.toSmulZeroClass.{u1, u2} (MulOpposite.{u1} α) A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))) (DistribMulAction.toDistribSMul.{u1, u2} (MulOpposite.{u1} α) A (MulOpposite.monoid.{u1} α _inst_3) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)) _inst_5)))], IsCentralScalar.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toHasSmul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) _inst_3 (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 _inst_3 _inst_4)) (MulAction.toHasSmul.{u1, u2} (MulOpposite.{u1} α) (AddSubgroup.{u2} A _inst_2) (MulOpposite.monoid.{u1} α _inst_3) (AddSubgroup.pointwiseMulAction.{u1, u2} (MulOpposite.{u1} α) A _inst_2 (MulOpposite.monoid.{u1} α _inst_3) _inst_5))
but is expected to have type
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddGroup.{u2} A] [_inst_3 : Monoid.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A _inst_3 (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))] [_inst_5 : DistribMulAction.{u1, u2} (MulOpposite.{u1} α) A (MulOpposite.instMonoidMulOpposite.{u1} α _inst_3) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))] [_inst_6 : IsCentralScalar.{u1, u2} α A (SMulZeroClass.toSMul.{u1, u2} α A (NegZeroClass.toZero.{u2} A (SubNegZeroMonoid.toNegZeroClass.{u2} A (SubtractionMonoid.toSubNegZeroMonoid.{u2} A (AddGroup.toSubtractionMonoid.{u2} A _inst_2)))) (DistribSMul.toSMulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))) (DistribMulAction.toDistribSMul.{u1, u2} α A _inst_3 (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)) _inst_4))) (SMulZeroClass.toSMul.{u1, u2} (MulOpposite.{u1} α) A (NegZeroClass.toZero.{u2} A (SubNegZeroMonoid.toNegZeroClass.{u2} A (SubtractionMonoid.toSubNegZeroMonoid.{u2} A (AddGroup.toSubtractionMonoid.{u2} A _inst_2)))) (DistribSMul.toSMulZeroClass.{u1, u2} (MulOpposite.{u1} α) A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))) (DistribMulAction.toDistribSMul.{u1, u2} (MulOpposite.{u1} α) A (MulOpposite.instMonoidMulOpposite.{u1} α _inst_3) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)) _inst_5)))], IsCentralScalar.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toSMul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) _inst_3 (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 _inst_3 _inst_4)) (MulAction.toSMul.{u1, u2} (MulOpposite.{u1} α) (AddSubgroup.{u2} A _inst_2) (MulOpposite.instMonoidMulOpposite.{u1} α _inst_3) (AddSubgroup.pointwiseMulAction.{u1, u2} (MulOpposite.{u1} α) A _inst_2 (MulOpposite.instMonoidMulOpposite.{u1} α _inst_3) _inst_5))
Case conversion may be inaccurate. Consider using '#align add_subgroup.pointwise_central_scalar AddSubgroup.pointwise_isCentralScalarₓ'. -/
instance pointwise_isCentralScalar [DistribMulAction αᵐᵒᵖ A] [IsCentralScalar α A] :
    IsCentralScalar α (AddSubgroup A) :=
  ⟨fun a S => (congr_arg fun f => S.map f) <| AddMonoidHom.ext <| op_smul_eq_smul _⟩
#align add_subgroup.pointwise_central_scalar AddSubgroup.pointwise_isCentralScalar

end Monoid

section Group

variable [Group α] [DistribMulAction α A]

open Pointwise

/- warning: add_subgroup.smul_mem_pointwise_smul_iff -> AddSubgroup.smul_mem_pointwise_smul_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddGroup.{u2} A] [_inst_3 : Group.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))] {a : α} {S : AddSubgroup.{u2} A _inst_2} {x : A}, Iff (Membership.Mem.{u2, u2} A (AddSubgroup.{u2} A _inst_2) (SetLike.hasMem.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)) (SMul.smul.{u1, u2} α A (SMulZeroClass.toHasSmul.{u1, u2} α A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)))) (DistribSMul.toSmulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))) (DistribMulAction.toDistribSMul.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)) _inst_4))) a x) (SMul.smul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toHasSmul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) a S)) (Membership.Mem.{u2, u2} A (AddSubgroup.{u2} A _inst_2) (SetLike.hasMem.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)) x S)
but is expected to have type
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddGroup.{u2} A] [_inst_3 : Group.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))] {a : α} {S : AddSubgroup.{u2} A _inst_2} {x : A}, Iff (Membership.mem.{u2, u2} A (AddSubgroup.{u2} A _inst_2) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.instSetLikeAddSubgroup.{u2} A _inst_2)) (HSMul.hSMul.{u1, u2, u2} α A A (instHSMul.{u1, u2} α A (SMulZeroClass.toSMul.{u1, u2} α A (NegZeroClass.toZero.{u2} A (SubNegZeroMonoid.toNegZeroClass.{u2} A (SubtractionMonoid.toSubNegZeroMonoid.{u2} A (AddGroup.toSubtractionMonoid.{u2} A _inst_2)))) (DistribSMul.toSMulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))) (DistribMulAction.toDistribSMul.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)) _inst_4)))) a x) (HSMul.hSMul.{u1, u2, u2} α (AddSubgroup.{u2} A _inst_2) (AddSubgroup.{u2} A _inst_2) (instHSMul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toSMul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) a S)) (Membership.mem.{u2, u2} A (AddSubgroup.{u2} A _inst_2) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.instSetLikeAddSubgroup.{u2} A _inst_2)) x S)
Case conversion may be inaccurate. Consider using '#align add_subgroup.smul_mem_pointwise_smul_iff AddSubgroup.smul_mem_pointwise_smul_iffₓ'. -/
@[simp]
theorem smul_mem_pointwise_smul_iff {a : α} {S : AddSubgroup A} {x : A} : a • x ∈ a • S ↔ x ∈ S :=
  smul_mem_smul_set_iff
#align add_subgroup.smul_mem_pointwise_smul_iff AddSubgroup.smul_mem_pointwise_smul_iff

/- warning: add_subgroup.mem_pointwise_smul_iff_inv_smul_mem -> AddSubgroup.mem_pointwise_smul_iff_inv_smul_mem is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddGroup.{u2} A] [_inst_3 : Group.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))] {a : α} {S : AddSubgroup.{u2} A _inst_2} {x : A}, Iff (Membership.Mem.{u2, u2} A (AddSubgroup.{u2} A _inst_2) (SetLike.hasMem.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)) x (SMul.smul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toHasSmul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) a S)) (Membership.Mem.{u2, u2} A (AddSubgroup.{u2} A _inst_2) (SetLike.hasMem.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)) (SMul.smul.{u1, u2} α A (SMulZeroClass.toHasSmul.{u1, u2} α A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)))) (DistribSMul.toSmulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))) (DistribMulAction.toDistribSMul.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)) _inst_4))) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) a) x) S)
but is expected to have type
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddGroup.{u2} A] [_inst_3 : Group.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))] {a : α} {S : AddSubgroup.{u2} A _inst_2} {x : A}, Iff (Membership.mem.{u2, u2} A (AddSubgroup.{u2} A _inst_2) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.instSetLikeAddSubgroup.{u2} A _inst_2)) x (HSMul.hSMul.{u1, u2, u2} α (AddSubgroup.{u2} A _inst_2) (AddSubgroup.{u2} A _inst_2) (instHSMul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toSMul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) a S)) (Membership.mem.{u2, u2} A (AddSubgroup.{u2} A _inst_2) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.instSetLikeAddSubgroup.{u2} A _inst_2)) (HSMul.hSMul.{u1, u2, u2} α A A (instHSMul.{u1, u2} α A (SMulZeroClass.toSMul.{u1, u2} α A (NegZeroClass.toZero.{u2} A (SubNegZeroMonoid.toNegZeroClass.{u2} A (SubtractionMonoid.toSubNegZeroMonoid.{u2} A (AddGroup.toSubtractionMonoid.{u2} A _inst_2)))) (DistribSMul.toSMulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))) (DistribMulAction.toDistribSMul.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)) _inst_4)))) (Inv.inv.{u1} α (InvOneClass.toInv.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (Group.toDivisionMonoid.{u1} α _inst_3)))) a) x) S)
Case conversion may be inaccurate. Consider using '#align add_subgroup.mem_pointwise_smul_iff_inv_smul_mem AddSubgroup.mem_pointwise_smul_iff_inv_smul_memₓ'. -/
theorem mem_pointwise_smul_iff_inv_smul_mem {a : α} {S : AddSubgroup A} {x : A} :
    x ∈ a • S ↔ a⁻¹ • x ∈ S :=
  mem_smul_set_iff_inv_smul_mem
#align add_subgroup.mem_pointwise_smul_iff_inv_smul_mem AddSubgroup.mem_pointwise_smul_iff_inv_smul_mem

/- warning: add_subgroup.mem_inv_pointwise_smul_iff -> AddSubgroup.mem_inv_pointwise_smul_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddGroup.{u2} A] [_inst_3 : Group.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))] {a : α} {S : AddSubgroup.{u2} A _inst_2} {x : A}, Iff (Membership.Mem.{u2, u2} A (AddSubgroup.{u2} A _inst_2) (SetLike.hasMem.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)) x (SMul.smul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toHasSmul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) a) S)) (Membership.Mem.{u2, u2} A (AddSubgroup.{u2} A _inst_2) (SetLike.hasMem.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)) (SMul.smul.{u1, u2} α A (SMulZeroClass.toHasSmul.{u1, u2} α A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)))) (DistribSMul.toSmulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))) (DistribMulAction.toDistribSMul.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)) _inst_4))) a x) S)
but is expected to have type
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddGroup.{u2} A] [_inst_3 : Group.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))] {a : α} {S : AddSubgroup.{u2} A _inst_2} {x : A}, Iff (Membership.mem.{u2, u2} A (AddSubgroup.{u2} A _inst_2) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.instSetLikeAddSubgroup.{u2} A _inst_2)) x (HSMul.hSMul.{u1, u2, u2} α (AddSubgroup.{u2} A _inst_2) (AddSubgroup.{u2} A _inst_2) (instHSMul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toSMul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) (Inv.inv.{u1} α (InvOneClass.toInv.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (Group.toDivisionMonoid.{u1} α _inst_3)))) a) S)) (Membership.mem.{u2, u2} A (AddSubgroup.{u2} A _inst_2) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.instSetLikeAddSubgroup.{u2} A _inst_2)) (HSMul.hSMul.{u1, u2, u2} α A A (instHSMul.{u1, u2} α A (SMulZeroClass.toSMul.{u1, u2} α A (NegZeroClass.toZero.{u2} A (SubNegZeroMonoid.toNegZeroClass.{u2} A (SubtractionMonoid.toSubNegZeroMonoid.{u2} A (AddGroup.toSubtractionMonoid.{u2} A _inst_2)))) (DistribSMul.toSMulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))) (DistribMulAction.toDistribSMul.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)) _inst_4)))) a x) S)
Case conversion may be inaccurate. Consider using '#align add_subgroup.mem_inv_pointwise_smul_iff AddSubgroup.mem_inv_pointwise_smul_iffₓ'. -/
theorem mem_inv_pointwise_smul_iff {a : α} {S : AddSubgroup A} {x : A} : x ∈ a⁻¹ • S ↔ a • x ∈ S :=
  mem_inv_smul_set_iff
#align add_subgroup.mem_inv_pointwise_smul_iff AddSubgroup.mem_inv_pointwise_smul_iff

/- warning: add_subgroup.pointwise_smul_le_pointwise_smul_iff -> AddSubgroup.pointwise_smul_le_pointwise_smul_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddGroup.{u2} A] [_inst_3 : Group.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))] {a : α} {S : AddSubgroup.{u2} A _inst_2} {T : AddSubgroup.{u2} A _inst_2}, Iff (LE.le.{u2} (AddSubgroup.{u2} A _inst_2) (Preorder.toLE.{u2} (AddSubgroup.{u2} A _inst_2) (PartialOrder.toPreorder.{u2} (AddSubgroup.{u2} A _inst_2) (SetLike.partialOrder.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)))) (SMul.smul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toHasSmul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) a S) (SMul.smul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toHasSmul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) a T)) (LE.le.{u2} (AddSubgroup.{u2} A _inst_2) (Preorder.toLE.{u2} (AddSubgroup.{u2} A _inst_2) (PartialOrder.toPreorder.{u2} (AddSubgroup.{u2} A _inst_2) (SetLike.partialOrder.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)))) S T)
but is expected to have type
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddGroup.{u2} A] [_inst_3 : Group.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))] {a : α} {S : AddSubgroup.{u2} A _inst_2} {T : AddSubgroup.{u2} A _inst_2}, Iff (LE.le.{u2} (AddSubgroup.{u2} A _inst_2) (Preorder.toLE.{u2} (AddSubgroup.{u2} A _inst_2) (PartialOrder.toPreorder.{u2} (AddSubgroup.{u2} A _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u2} (AddSubgroup.{u2} A _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u2} (AddSubgroup.{u2} A _inst_2) (AddSubgroup.instCompleteLatticeAddSubgroup.{u2} A _inst_2))))) (HSMul.hSMul.{u1, u2, u2} α (AddSubgroup.{u2} A _inst_2) (AddSubgroup.{u2} A _inst_2) (instHSMul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toSMul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) a S) (HSMul.hSMul.{u1, u2, u2} α (AddSubgroup.{u2} A _inst_2) (AddSubgroup.{u2} A _inst_2) (instHSMul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toSMul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) a T)) (LE.le.{u2} (AddSubgroup.{u2} A _inst_2) (Preorder.toLE.{u2} (AddSubgroup.{u2} A _inst_2) (PartialOrder.toPreorder.{u2} (AddSubgroup.{u2} A _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u2} (AddSubgroup.{u2} A _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u2} (AddSubgroup.{u2} A _inst_2) (AddSubgroup.instCompleteLatticeAddSubgroup.{u2} A _inst_2))))) S T)
Case conversion may be inaccurate. Consider using '#align add_subgroup.pointwise_smul_le_pointwise_smul_iff AddSubgroup.pointwise_smul_le_pointwise_smul_iffₓ'. -/
@[simp]
theorem pointwise_smul_le_pointwise_smul_iff {a : α} {S T : AddSubgroup A} :
    a • S ≤ a • T ↔ S ≤ T :=
  set_smul_subset_set_smul_iff
#align add_subgroup.pointwise_smul_le_pointwise_smul_iff AddSubgroup.pointwise_smul_le_pointwise_smul_iff

/- warning: add_subgroup.pointwise_smul_le_iff -> AddSubgroup.pointwise_smul_le_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddGroup.{u2} A] [_inst_3 : Group.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))] {a : α} {S : AddSubgroup.{u2} A _inst_2} {T : AddSubgroup.{u2} A _inst_2}, Iff (LE.le.{u2} (AddSubgroup.{u2} A _inst_2) (Preorder.toLE.{u2} (AddSubgroup.{u2} A _inst_2) (PartialOrder.toPreorder.{u2} (AddSubgroup.{u2} A _inst_2) (SetLike.partialOrder.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)))) (SMul.smul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toHasSmul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) a S) T) (LE.le.{u2} (AddSubgroup.{u2} A _inst_2) (Preorder.toLE.{u2} (AddSubgroup.{u2} A _inst_2) (PartialOrder.toPreorder.{u2} (AddSubgroup.{u2} A _inst_2) (SetLike.partialOrder.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)))) S (SMul.smul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toHasSmul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) a) T))
but is expected to have type
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddGroup.{u2} A] [_inst_3 : Group.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))] {a : α} {S : AddSubgroup.{u2} A _inst_2} {T : AddSubgroup.{u2} A _inst_2}, Iff (LE.le.{u2} (AddSubgroup.{u2} A _inst_2) (Preorder.toLE.{u2} (AddSubgroup.{u2} A _inst_2) (PartialOrder.toPreorder.{u2} (AddSubgroup.{u2} A _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u2} (AddSubgroup.{u2} A _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u2} (AddSubgroup.{u2} A _inst_2) (AddSubgroup.instCompleteLatticeAddSubgroup.{u2} A _inst_2))))) (HSMul.hSMul.{u1, u2, u2} α (AddSubgroup.{u2} A _inst_2) (AddSubgroup.{u2} A _inst_2) (instHSMul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toSMul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) a S) T) (LE.le.{u2} (AddSubgroup.{u2} A _inst_2) (Preorder.toLE.{u2} (AddSubgroup.{u2} A _inst_2) (PartialOrder.toPreorder.{u2} (AddSubgroup.{u2} A _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u2} (AddSubgroup.{u2} A _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u2} (AddSubgroup.{u2} A _inst_2) (AddSubgroup.instCompleteLatticeAddSubgroup.{u2} A _inst_2))))) S (HSMul.hSMul.{u1, u2, u2} α (AddSubgroup.{u2} A _inst_2) (AddSubgroup.{u2} A _inst_2) (instHSMul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toSMul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) (Inv.inv.{u1} α (InvOneClass.toInv.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (Group.toDivisionMonoid.{u1} α _inst_3)))) a) T))
Case conversion may be inaccurate. Consider using '#align add_subgroup.pointwise_smul_le_iff AddSubgroup.pointwise_smul_le_iffₓ'. -/
theorem pointwise_smul_le_iff {a : α} {S T : AddSubgroup A} : a • S ≤ T ↔ S ≤ a⁻¹ • T :=
  set_smul_subset_iff
#align add_subgroup.pointwise_smul_le_iff AddSubgroup.pointwise_smul_le_iff

/- warning: add_subgroup.le_pointwise_smul_iff -> AddSubgroup.le_pointwise_smul_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddGroup.{u2} A] [_inst_3 : Group.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))] {a : α} {S : AddSubgroup.{u2} A _inst_2} {T : AddSubgroup.{u2} A _inst_2}, Iff (LE.le.{u2} (AddSubgroup.{u2} A _inst_2) (Preorder.toLE.{u2} (AddSubgroup.{u2} A _inst_2) (PartialOrder.toPreorder.{u2} (AddSubgroup.{u2} A _inst_2) (SetLike.partialOrder.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)))) S (SMul.smul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toHasSmul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) a T)) (LE.le.{u2} (AddSubgroup.{u2} A _inst_2) (Preorder.toLE.{u2} (AddSubgroup.{u2} A _inst_2) (PartialOrder.toPreorder.{u2} (AddSubgroup.{u2} A _inst_2) (SetLike.partialOrder.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)))) (SMul.smul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toHasSmul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) a) S) T)
but is expected to have type
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddGroup.{u2} A] [_inst_3 : Group.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))] {a : α} {S : AddSubgroup.{u2} A _inst_2} {T : AddSubgroup.{u2} A _inst_2}, Iff (LE.le.{u2} (AddSubgroup.{u2} A _inst_2) (Preorder.toLE.{u2} (AddSubgroup.{u2} A _inst_2) (PartialOrder.toPreorder.{u2} (AddSubgroup.{u2} A _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u2} (AddSubgroup.{u2} A _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u2} (AddSubgroup.{u2} A _inst_2) (AddSubgroup.instCompleteLatticeAddSubgroup.{u2} A _inst_2))))) S (HSMul.hSMul.{u1, u2, u2} α (AddSubgroup.{u2} A _inst_2) (AddSubgroup.{u2} A _inst_2) (instHSMul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toSMul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) a T)) (LE.le.{u2} (AddSubgroup.{u2} A _inst_2) (Preorder.toLE.{u2} (AddSubgroup.{u2} A _inst_2) (PartialOrder.toPreorder.{u2} (AddSubgroup.{u2} A _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u2} (AddSubgroup.{u2} A _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u2} (AddSubgroup.{u2} A _inst_2) (AddSubgroup.instCompleteLatticeAddSubgroup.{u2} A _inst_2))))) (HSMul.hSMul.{u1, u2, u2} α (AddSubgroup.{u2} A _inst_2) (AddSubgroup.{u2} A _inst_2) (instHSMul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toSMul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) (Inv.inv.{u1} α (InvOneClass.toInv.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (Group.toDivisionMonoid.{u1} α _inst_3)))) a) S) T)
Case conversion may be inaccurate. Consider using '#align add_subgroup.le_pointwise_smul_iff AddSubgroup.le_pointwise_smul_iffₓ'. -/
theorem le_pointwise_smul_iff {a : α} {S T : AddSubgroup A} : S ≤ a • T ↔ a⁻¹ • S ≤ T :=
  subset_set_smul_iff
#align add_subgroup.le_pointwise_smul_iff AddSubgroup.le_pointwise_smul_iff

end Group

section GroupWithZero

variable [GroupWithZero α] [DistribMulAction α A]

open Pointwise

/- warning: add_subgroup.smul_mem_pointwise_smul_iff₀ -> AddSubgroup.smul_mem_pointwise_smul_iff₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddGroup.{u2} A] [_inst_3 : GroupWithZero.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))] {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)))))))) -> (forall (S : AddSubgroup.{u2} A _inst_2) (x : A), Iff (Membership.Mem.{u2, u2} A (AddSubgroup.{u2} A _inst_2) (SetLike.hasMem.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)) (SMul.smul.{u1, u2} α A (SMulZeroClass.toHasSmul.{u1, u2} α A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)))) (DistribSMul.toSmulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))) (DistribMulAction.toDistribSMul.{u1, u2} α A (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)) _inst_4))) a x) (SMul.smul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toHasSmul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) a S)) (Membership.Mem.{u2, u2} A (AddSubgroup.{u2} A _inst_2) (SetLike.hasMem.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)) x S))
but is expected to have type
  forall {α : Type.{u2}} {A : Type.{u1}} [_inst_2 : AddGroup.{u1} A] [_inst_3 : GroupWithZero.{u2} α] [_inst_4 : DistribMulAction.{u2, u1} α A (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_2))] {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3))))) -> (forall (S : AddSubgroup.{u1} A _inst_2) (x : A), Iff (Membership.mem.{u1, u1} A (AddSubgroup.{u1} A _inst_2) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} A _inst_2) A (AddSubgroup.instSetLikeAddSubgroup.{u1} A _inst_2)) (HSMul.hSMul.{u2, u1, u1} α A A (instHSMul.{u2, u1} α A (SMulZeroClass.toSMul.{u2, u1} α A (NegZeroClass.toZero.{u1} A (SubNegZeroMonoid.toNegZeroClass.{u1} A (SubtractionMonoid.toSubNegZeroMonoid.{u1} A (AddGroup.toSubtractionMonoid.{u1} A _inst_2)))) (DistribSMul.toSMulZeroClass.{u2, u1} α A (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_2))) (DistribMulAction.toDistribSMul.{u2, u1} α A (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_2)) _inst_4)))) a x) (HSMul.hSMul.{u2, u1, u1} α (AddSubgroup.{u1} A _inst_2) (AddSubgroup.{u1} A _inst_2) (instHSMul.{u2, u1} α (AddSubgroup.{u1} A _inst_2) (MulAction.toSMul.{u2, u1} α (AddSubgroup.{u1} A _inst_2) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u2, u1} α A _inst_2 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) a S)) (Membership.mem.{u1, u1} A (AddSubgroup.{u1} A _inst_2) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} A _inst_2) A (AddSubgroup.instSetLikeAddSubgroup.{u1} A _inst_2)) x S))
Case conversion may be inaccurate. Consider using '#align add_subgroup.smul_mem_pointwise_smul_iff₀ AddSubgroup.smul_mem_pointwise_smul_iff₀ₓ'. -/
@[simp]
theorem smul_mem_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) (S : AddSubgroup A) (x : A) :
    a • x ∈ a • S ↔ x ∈ S :=
  smul_mem_smul_set_iff₀ ha (S : Set A) x
#align add_subgroup.smul_mem_pointwise_smul_iff₀ AddSubgroup.smul_mem_pointwise_smul_iff₀

/- warning: add_subgroup.mem_pointwise_smul_iff_inv_smul_mem₀ -> AddSubgroup.mem_pointwise_smul_iff_inv_smul_mem₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddGroup.{u2} A] [_inst_3 : GroupWithZero.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))] {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)))))))) -> (forall (S : AddSubgroup.{u2} A _inst_2) (x : A), Iff (Membership.Mem.{u2, u2} A (AddSubgroup.{u2} A _inst_2) (SetLike.hasMem.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)) x (SMul.smul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toHasSmul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) a S)) (Membership.Mem.{u2, u2} A (AddSubgroup.{u2} A _inst_2) (SetLike.hasMem.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)) (SMul.smul.{u1, u2} α A (SMulZeroClass.toHasSmul.{u1, u2} α A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)))) (DistribSMul.toSmulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))) (DistribMulAction.toDistribSMul.{u1, u2} α A (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)) _inst_4))) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α _inst_3)) a) x) S))
but is expected to have type
  forall {α : Type.{u2}} {A : Type.{u1}} [_inst_2 : AddGroup.{u1} A] [_inst_3 : GroupWithZero.{u2} α] [_inst_4 : DistribMulAction.{u2, u1} α A (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_2))] {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3))))) -> (forall (S : AddSubgroup.{u1} A _inst_2) (x : A), Iff (Membership.mem.{u1, u1} A (AddSubgroup.{u1} A _inst_2) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} A _inst_2) A (AddSubgroup.instSetLikeAddSubgroup.{u1} A _inst_2)) x (HSMul.hSMul.{u2, u1, u1} α (AddSubgroup.{u1} A _inst_2) (AddSubgroup.{u1} A _inst_2) (instHSMul.{u2, u1} α (AddSubgroup.{u1} A _inst_2) (MulAction.toSMul.{u2, u1} α (AddSubgroup.{u1} A _inst_2) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u2, u1} α A _inst_2 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) a S)) (Membership.mem.{u1, u1} A (AddSubgroup.{u1} A _inst_2) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} A _inst_2) A (AddSubgroup.instSetLikeAddSubgroup.{u1} A _inst_2)) (HSMul.hSMul.{u2, u1, u1} α A A (instHSMul.{u2, u1} α A (SMulZeroClass.toSMul.{u2, u1} α A (NegZeroClass.toZero.{u1} A (SubNegZeroMonoid.toNegZeroClass.{u1} A (SubtractionMonoid.toSubNegZeroMonoid.{u1} A (AddGroup.toSubtractionMonoid.{u1} A _inst_2)))) (DistribSMul.toSMulZeroClass.{u2, u1} α A (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_2))) (DistribMulAction.toDistribSMul.{u2, u1} α A (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_2)) _inst_4)))) (Inv.inv.{u2} α (GroupWithZero.toInv.{u2} α _inst_3) a) x) S))
Case conversion may be inaccurate. Consider using '#align add_subgroup.mem_pointwise_smul_iff_inv_smul_mem₀ AddSubgroup.mem_pointwise_smul_iff_inv_smul_mem₀ₓ'. -/
theorem mem_pointwise_smul_iff_inv_smul_mem₀ {a : α} (ha : a ≠ 0) (S : AddSubgroup A) (x : A) :
    x ∈ a • S ↔ a⁻¹ • x ∈ S :=
  mem_smul_set_iff_inv_smul_mem₀ ha (S : Set A) x
#align add_subgroup.mem_pointwise_smul_iff_inv_smul_mem₀ AddSubgroup.mem_pointwise_smul_iff_inv_smul_mem₀

/- warning: add_subgroup.mem_inv_pointwise_smul_iff₀ -> AddSubgroup.mem_inv_pointwise_smul_iff₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddGroup.{u2} A] [_inst_3 : GroupWithZero.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))] {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)))))))) -> (forall (S : AddSubgroup.{u2} A _inst_2) (x : A), Iff (Membership.Mem.{u2, u2} A (AddSubgroup.{u2} A _inst_2) (SetLike.hasMem.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)) x (SMul.smul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toHasSmul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α _inst_3)) a) S)) (Membership.Mem.{u2, u2} A (AddSubgroup.{u2} A _inst_2) (SetLike.hasMem.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)) (SMul.smul.{u1, u2} α A (SMulZeroClass.toHasSmul.{u1, u2} α A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)))) (DistribSMul.toSmulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))) (DistribMulAction.toDistribSMul.{u1, u2} α A (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2)) _inst_4))) a x) S))
but is expected to have type
  forall {α : Type.{u2}} {A : Type.{u1}} [_inst_2 : AddGroup.{u1} A] [_inst_3 : GroupWithZero.{u2} α] [_inst_4 : DistribMulAction.{u2, u1} α A (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_2))] {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3))))) -> (forall (S : AddSubgroup.{u1} A _inst_2) (x : A), Iff (Membership.mem.{u1, u1} A (AddSubgroup.{u1} A _inst_2) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} A _inst_2) A (AddSubgroup.instSetLikeAddSubgroup.{u1} A _inst_2)) x (HSMul.hSMul.{u2, u1, u1} α (AddSubgroup.{u1} A _inst_2) (AddSubgroup.{u1} A _inst_2) (instHSMul.{u2, u1} α (AddSubgroup.{u1} A _inst_2) (MulAction.toSMul.{u2, u1} α (AddSubgroup.{u1} A _inst_2) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u2, u1} α A _inst_2 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) (Inv.inv.{u2} α (GroupWithZero.toInv.{u2} α _inst_3) a) S)) (Membership.mem.{u1, u1} A (AddSubgroup.{u1} A _inst_2) (SetLike.instMembership.{u1, u1} (AddSubgroup.{u1} A _inst_2) A (AddSubgroup.instSetLikeAddSubgroup.{u1} A _inst_2)) (HSMul.hSMul.{u2, u1, u1} α A A (instHSMul.{u2, u1} α A (SMulZeroClass.toSMul.{u2, u1} α A (NegZeroClass.toZero.{u1} A (SubNegZeroMonoid.toNegZeroClass.{u1} A (SubtractionMonoid.toSubNegZeroMonoid.{u1} A (AddGroup.toSubtractionMonoid.{u1} A _inst_2)))) (DistribSMul.toSMulZeroClass.{u2, u1} α A (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_2))) (DistribMulAction.toDistribSMul.{u2, u1} α A (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_2)) _inst_4)))) a x) S))
Case conversion may be inaccurate. Consider using '#align add_subgroup.mem_inv_pointwise_smul_iff₀ AddSubgroup.mem_inv_pointwise_smul_iff₀ₓ'. -/
theorem mem_inv_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) (S : AddSubgroup A) (x : A) :
    x ∈ a⁻¹ • S ↔ a • x ∈ S :=
  mem_inv_smul_set_iff₀ ha (S : Set A) x
#align add_subgroup.mem_inv_pointwise_smul_iff₀ AddSubgroup.mem_inv_pointwise_smul_iff₀

/- warning: add_subgroup.pointwise_smul_le_pointwise_smul_iff₀ -> AddSubgroup.pointwise_smul_le_pointwise_smul_iff₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddGroup.{u2} A] [_inst_3 : GroupWithZero.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))] {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)))))))) -> (forall {S : AddSubgroup.{u2} A _inst_2} {T : AddSubgroup.{u2} A _inst_2}, Iff (LE.le.{u2} (AddSubgroup.{u2} A _inst_2) (Preorder.toLE.{u2} (AddSubgroup.{u2} A _inst_2) (PartialOrder.toPreorder.{u2} (AddSubgroup.{u2} A _inst_2) (SetLike.partialOrder.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)))) (SMul.smul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toHasSmul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) a S) (SMul.smul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toHasSmul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) a T)) (LE.le.{u2} (AddSubgroup.{u2} A _inst_2) (Preorder.toLE.{u2} (AddSubgroup.{u2} A _inst_2) (PartialOrder.toPreorder.{u2} (AddSubgroup.{u2} A _inst_2) (SetLike.partialOrder.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)))) S T))
but is expected to have type
  forall {α : Type.{u2}} {A : Type.{u1}} [_inst_2 : AddGroup.{u1} A] [_inst_3 : GroupWithZero.{u2} α] [_inst_4 : DistribMulAction.{u2, u1} α A (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_2))] {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3))))) -> (forall {S : AddSubgroup.{u1} A _inst_2} {T : AddSubgroup.{u1} A _inst_2}, Iff (LE.le.{u1} (AddSubgroup.{u1} A _inst_2) (Preorder.toLE.{u1} (AddSubgroup.{u1} A _inst_2) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} A _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} A _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} A _inst_2) (AddSubgroup.instCompleteLatticeAddSubgroup.{u1} A _inst_2))))) (HSMul.hSMul.{u2, u1, u1} α (AddSubgroup.{u1} A _inst_2) (AddSubgroup.{u1} A _inst_2) (instHSMul.{u2, u1} α (AddSubgroup.{u1} A _inst_2) (MulAction.toSMul.{u2, u1} α (AddSubgroup.{u1} A _inst_2) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u2, u1} α A _inst_2 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) a S) (HSMul.hSMul.{u2, u1, u1} α (AddSubgroup.{u1} A _inst_2) (AddSubgroup.{u1} A _inst_2) (instHSMul.{u2, u1} α (AddSubgroup.{u1} A _inst_2) (MulAction.toSMul.{u2, u1} α (AddSubgroup.{u1} A _inst_2) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u2, u1} α A _inst_2 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) a T)) (LE.le.{u1} (AddSubgroup.{u1} A _inst_2) (Preorder.toLE.{u1} (AddSubgroup.{u1} A _inst_2) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} A _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} A _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} A _inst_2) (AddSubgroup.instCompleteLatticeAddSubgroup.{u1} A _inst_2))))) S T))
Case conversion may be inaccurate. Consider using '#align add_subgroup.pointwise_smul_le_pointwise_smul_iff₀ AddSubgroup.pointwise_smul_le_pointwise_smul_iff₀ₓ'. -/
@[simp]
theorem pointwise_smul_le_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) {S T : AddSubgroup A} :
    a • S ≤ a • T ↔ S ≤ T :=
  set_smul_subset_set_smul_iff₀ ha
#align add_subgroup.pointwise_smul_le_pointwise_smul_iff₀ AddSubgroup.pointwise_smul_le_pointwise_smul_iff₀

/- warning: add_subgroup.pointwise_smul_le_iff₀ -> AddSubgroup.pointwise_smul_le_iff₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddGroup.{u2} A] [_inst_3 : GroupWithZero.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))] {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)))))))) -> (forall {S : AddSubgroup.{u2} A _inst_2} {T : AddSubgroup.{u2} A _inst_2}, Iff (LE.le.{u2} (AddSubgroup.{u2} A _inst_2) (Preorder.toLE.{u2} (AddSubgroup.{u2} A _inst_2) (PartialOrder.toPreorder.{u2} (AddSubgroup.{u2} A _inst_2) (SetLike.partialOrder.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)))) (SMul.smul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toHasSmul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) a S) T) (LE.le.{u2} (AddSubgroup.{u2} A _inst_2) (Preorder.toLE.{u2} (AddSubgroup.{u2} A _inst_2) (PartialOrder.toPreorder.{u2} (AddSubgroup.{u2} A _inst_2) (SetLike.partialOrder.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)))) S (SMul.smul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toHasSmul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α _inst_3)) a) T)))
but is expected to have type
  forall {α : Type.{u2}} {A : Type.{u1}} [_inst_2 : AddGroup.{u1} A] [_inst_3 : GroupWithZero.{u2} α] [_inst_4 : DistribMulAction.{u2, u1} α A (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_2))] {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3))))) -> (forall {S : AddSubgroup.{u1} A _inst_2} {T : AddSubgroup.{u1} A _inst_2}, Iff (LE.le.{u1} (AddSubgroup.{u1} A _inst_2) (Preorder.toLE.{u1} (AddSubgroup.{u1} A _inst_2) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} A _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} A _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} A _inst_2) (AddSubgroup.instCompleteLatticeAddSubgroup.{u1} A _inst_2))))) (HSMul.hSMul.{u2, u1, u1} α (AddSubgroup.{u1} A _inst_2) (AddSubgroup.{u1} A _inst_2) (instHSMul.{u2, u1} α (AddSubgroup.{u1} A _inst_2) (MulAction.toSMul.{u2, u1} α (AddSubgroup.{u1} A _inst_2) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u2, u1} α A _inst_2 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) a S) T) (LE.le.{u1} (AddSubgroup.{u1} A _inst_2) (Preorder.toLE.{u1} (AddSubgroup.{u1} A _inst_2) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} A _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} A _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} A _inst_2) (AddSubgroup.instCompleteLatticeAddSubgroup.{u1} A _inst_2))))) S (HSMul.hSMul.{u2, u1, u1} α (AddSubgroup.{u1} A _inst_2) (AddSubgroup.{u1} A _inst_2) (instHSMul.{u2, u1} α (AddSubgroup.{u1} A _inst_2) (MulAction.toSMul.{u2, u1} α (AddSubgroup.{u1} A _inst_2) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u2, u1} α A _inst_2 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) (Inv.inv.{u2} α (GroupWithZero.toInv.{u2} α _inst_3) a) T)))
Case conversion may be inaccurate. Consider using '#align add_subgroup.pointwise_smul_le_iff₀ AddSubgroup.pointwise_smul_le_iff₀ₓ'. -/
theorem pointwise_smul_le_iff₀ {a : α} (ha : a ≠ 0) {S T : AddSubgroup A} :
    a • S ≤ T ↔ S ≤ a⁻¹ • T :=
  set_smul_subset_iff₀ ha
#align add_subgroup.pointwise_smul_le_iff₀ AddSubgroup.pointwise_smul_le_iff₀

/- warning: add_subgroup.le_pointwise_smul_iff₀ -> AddSubgroup.le_pointwise_smul_iff₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddGroup.{u2} A] [_inst_3 : GroupWithZero.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (SubNegMonoid.toAddMonoid.{u2} A (AddGroup.toSubNegMonoid.{u2} A _inst_2))] {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)))))))) -> (forall {S : AddSubgroup.{u2} A _inst_2} {T : AddSubgroup.{u2} A _inst_2}, Iff (LE.le.{u2} (AddSubgroup.{u2} A _inst_2) (Preorder.toLE.{u2} (AddSubgroup.{u2} A _inst_2) (PartialOrder.toPreorder.{u2} (AddSubgroup.{u2} A _inst_2) (SetLike.partialOrder.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)))) S (SMul.smul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toHasSmul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) a T)) (LE.le.{u2} (AddSubgroup.{u2} A _inst_2) (Preorder.toLE.{u2} (AddSubgroup.{u2} A _inst_2) (PartialOrder.toPreorder.{u2} (AddSubgroup.{u2} A _inst_2) (SetLike.partialOrder.{u2, u2} (AddSubgroup.{u2} A _inst_2) A (AddSubgroup.setLike.{u2} A _inst_2)))) (SMul.smul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MulAction.toHasSmul.{u1, u2} α (AddSubgroup.{u2} A _inst_2) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u1, u2} α A _inst_2 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α _inst_3)) a) S) T))
but is expected to have type
  forall {α : Type.{u2}} {A : Type.{u1}} [_inst_2 : AddGroup.{u1} A] [_inst_3 : GroupWithZero.{u2} α] [_inst_4 : DistribMulAction.{u2, u1} α A (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_2))] {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3))))) -> (forall {S : AddSubgroup.{u1} A _inst_2} {T : AddSubgroup.{u1} A _inst_2}, Iff (LE.le.{u1} (AddSubgroup.{u1} A _inst_2) (Preorder.toLE.{u1} (AddSubgroup.{u1} A _inst_2) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} A _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} A _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} A _inst_2) (AddSubgroup.instCompleteLatticeAddSubgroup.{u1} A _inst_2))))) S (HSMul.hSMul.{u2, u1, u1} α (AddSubgroup.{u1} A _inst_2) (AddSubgroup.{u1} A _inst_2) (instHSMul.{u2, u1} α (AddSubgroup.{u1} A _inst_2) (MulAction.toSMul.{u2, u1} α (AddSubgroup.{u1} A _inst_2) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u2, u1} α A _inst_2 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) a T)) (LE.le.{u1} (AddSubgroup.{u1} A _inst_2) (Preorder.toLE.{u1} (AddSubgroup.{u1} A _inst_2) (PartialOrder.toPreorder.{u1} (AddSubgroup.{u1} A _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubgroup.{u1} A _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubgroup.{u1} A _inst_2) (AddSubgroup.instCompleteLatticeAddSubgroup.{u1} A _inst_2))))) (HSMul.hSMul.{u2, u1, u1} α (AddSubgroup.{u1} A _inst_2) (AddSubgroup.{u1} A _inst_2) (instHSMul.{u2, u1} α (AddSubgroup.{u1} A _inst_2) (MulAction.toSMul.{u2, u1} α (AddSubgroup.{u1} A _inst_2) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (AddSubgroup.pointwiseMulAction.{u2, u1} α A _inst_2 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) (Inv.inv.{u2} α (GroupWithZero.toInv.{u2} α _inst_3) a) S) T))
Case conversion may be inaccurate. Consider using '#align add_subgroup.le_pointwise_smul_iff₀ AddSubgroup.le_pointwise_smul_iff₀ₓ'. -/
theorem le_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) {S T : AddSubgroup A} :
    S ≤ a • T ↔ a⁻¹ • S ≤ T :=
  subset_set_smul_iff₀ ha
#align add_subgroup.le_pointwise_smul_iff₀ AddSubgroup.le_pointwise_smul_iff₀

end GroupWithZero

end AddSubgroup

