/-
Copyright (c) 2021 Eric Wieser. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Wieser

! This file was ported from Lean 3 source module group_theory.submonoid.pointwise
! leanprover-community/mathlib commit 2bbc7e3884ba234309d2a43b19144105a753292e
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Set.Pointwise.Smul
import Mathbin.GroupTheory.Submonoid.Membership
import Mathbin.Order.WellFoundedSet

/-! # Pointwise instances on `submonoid`s and `add_submonoid`s

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file provides:

* `submonoid.has_inv`
* `add_submonoid.has_neg`

and the actions

* `submonoid.pointwise_mul_action`
* `add_submonoid.pointwise_mul_action`

which matches the action of `mul_action_set`.

These are all available in the `pointwise` locale.

Additionally, it provides various degrees of monoid structure:
* `add_submonoid.has_one`
* `add_submonoid.has_mul`
* `add_submonoid.mul_one_class`
* `add_submonoid.semigroup`
* `add_submonoid.monoid`
which is available globally to match the monoid structure implied by `submodule.idem_semiring`.

## Implementation notes

Most of the lemmas in this file are direct copies of lemmas from `algebra/pointwise.lean`.
While the statements of these lemmas are defeq, we repeat them here due to them not being
syntactically equal. Before adding new lemmas here, consider if they would also apply to the action
on `set`s.

-/


open Set

variable {α : Type _} {G : Type _} {M : Type _} {R : Type _} {A : Type _}

variable [Monoid M] [AddMonoid A]

/-! Some lemmas about pointwise multiplication and submonoids. Ideally we put these in
  `group_theory.submonoid.basic`, but currently we cannot because that file is imported by this. -/


namespace Submonoid

open Pointwise

variable {s t u : Set M}

/- warning: submonoid.mul_subset -> Submonoid.mul_subset is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {s : Set.{u1} M} {t : Set.{u1} M} {S : Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)}, (HasSubset.Subset.{u1} (Set.{u1} M) (Set.hasSubset.{u1} M) s ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Set.{u1} M) (HasLiftT.mk.{succ u1, succ u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Set.{u1} M) (CoeTCₓ.coe.{succ u1, succ u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Set.{u1} M) (SetLike.Set.hasCoeT.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.setLike.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))))) S)) -> (HasSubset.Subset.{u1} (Set.{u1} M) (Set.hasSubset.{u1} M) t ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Set.{u1} M) (HasLiftT.mk.{succ u1, succ u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Set.{u1} M) (CoeTCₓ.coe.{succ u1, succ u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Set.{u1} M) (SetLike.Set.hasCoeT.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.setLike.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))))) S)) -> (HasSubset.Subset.{u1} (Set.{u1} M) (Set.hasSubset.{u1} M) (HMul.hMul.{u1, u1, u1} (Set.{u1} M) (Set.{u1} M) (Set.{u1} M) (instHMul.{u1} (Set.{u1} M) (Set.mul.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)))) s t) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Set.{u1} M) (HasLiftT.mk.{succ u1, succ u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Set.{u1} M) (CoeTCₓ.coe.{succ u1, succ u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Set.{u1} M) (SetLike.Set.hasCoeT.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.setLike.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))))) S))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {s : Set.{u1} M} {t : Set.{u1} M} {S : Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)}, (HasSubset.Subset.{u1} (Set.{u1} M) (Set.instHasSubsetSet.{u1} M) s (SetLike.coe.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) S)) -> (HasSubset.Subset.{u1} (Set.{u1} M) (Set.instHasSubsetSet.{u1} M) t (SetLike.coe.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) S)) -> (HasSubset.Subset.{u1} (Set.{u1} M) (Set.instHasSubsetSet.{u1} M) (HMul.hMul.{u1, u1, u1} (Set.{u1} M) (Set.{u1} M) (Set.{u1} M) (instHMul.{u1} (Set.{u1} M) (Set.mul.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)))) s t) (SetLike.coe.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) S))
Case conversion may be inaccurate. Consider using '#align submonoid.mul_subset Submonoid.mul_subsetₓ'. -/
@[to_additive]
theorem mul_subset {S : Submonoid M} (hs : s ⊆ S) (ht : t ⊆ S) : s * t ⊆ S :=
  by
  rintro _ ⟨p, q, hp, hq, rfl⟩
  exact Submonoid.mul_mem _ (hs hp) (ht hq)
#align submonoid.mul_subset Submonoid.mul_subset
#align add_submonoid.add_subset AddSubmonoid.add_subset

/- warning: submonoid.mul_subset_closure -> Submonoid.mul_subset_closure is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {s : Set.{u1} M} {t : Set.{u1} M} {u : Set.{u1} M}, (HasSubset.Subset.{u1} (Set.{u1} M) (Set.hasSubset.{u1} M) s u) -> (HasSubset.Subset.{u1} (Set.{u1} M) (Set.hasSubset.{u1} M) t u) -> (HasSubset.Subset.{u1} (Set.{u1} M) (Set.hasSubset.{u1} M) (HMul.hMul.{u1, u1, u1} (Set.{u1} M) (Set.{u1} M) (Set.{u1} M) (instHMul.{u1} (Set.{u1} M) (Set.mul.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)))) s t) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Set.{u1} M) (HasLiftT.mk.{succ u1, succ u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Set.{u1} M) (CoeTCₓ.coe.{succ u1, succ u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Set.{u1} M) (SetLike.Set.hasCoeT.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.setLike.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))))) (Submonoid.closure.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1) u)))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {s : Set.{u1} M} {t : Set.{u1} M} {u : Set.{u1} M}, (HasSubset.Subset.{u1} (Set.{u1} M) (Set.instHasSubsetSet.{u1} M) s u) -> (HasSubset.Subset.{u1} (Set.{u1} M) (Set.instHasSubsetSet.{u1} M) t u) -> (HasSubset.Subset.{u1} (Set.{u1} M) (Set.instHasSubsetSet.{u1} M) (HMul.hMul.{u1, u1, u1} (Set.{u1} M) (Set.{u1} M) (Set.{u1} M) (instHMul.{u1} (Set.{u1} M) (Set.mul.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)))) s t) (SetLike.coe.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Submonoid.closure.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1) u)))
Case conversion may be inaccurate. Consider using '#align submonoid.mul_subset_closure Submonoid.mul_subset_closureₓ'. -/
@[to_additive]
theorem mul_subset_closure (hs : s ⊆ u) (ht : t ⊆ u) : s * t ⊆ Submonoid.closure u :=
  mul_subset (Subset.trans hs Submonoid.subset_closure) (Subset.trans ht Submonoid.subset_closure)
#align submonoid.mul_subset_closure Submonoid.mul_subset_closure
#align add_submonoid.add_subset_closure AddSubmonoid.add_subset_closure

/- warning: submonoid.coe_mul_self_eq -> Submonoid.coe_mul_self_eq is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (s : Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)), Eq.{succ u1} (Set.{u1} M) (HMul.hMul.{u1, u1, u1} (Set.{u1} M) (Set.{u1} M) (Set.{u1} M) (instHMul.{u1} (Set.{u1} M) (Set.mul.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Set.{u1} M) (HasLiftT.mk.{succ u1, succ u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Set.{u1} M) (CoeTCₓ.coe.{succ u1, succ u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Set.{u1} M) (SetLike.Set.hasCoeT.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.setLike.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))))) s) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Set.{u1} M) (HasLiftT.mk.{succ u1, succ u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Set.{u1} M) (CoeTCₓ.coe.{succ u1, succ u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Set.{u1} M) (SetLike.Set.hasCoeT.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.setLike.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))))) s)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Set.{u1} M) (HasLiftT.mk.{succ u1, succ u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Set.{u1} M) (CoeTCₓ.coe.{succ u1, succ u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Set.{u1} M) (SetLike.Set.hasCoeT.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.setLike.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))))) s)
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (s : Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)), Eq.{succ u1} (Set.{u1} M) (HMul.hMul.{u1, u1, u1} (Set.{u1} M) (Set.{u1} M) (Set.{u1} M) (instHMul.{u1} (Set.{u1} M) (Set.mul.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)))) (SetLike.coe.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) s) (SetLike.coe.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) s)) (SetLike.coe.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) s)
Case conversion may be inaccurate. Consider using '#align submonoid.coe_mul_self_eq Submonoid.coe_mul_self_eqₓ'. -/
@[to_additive]
theorem coe_mul_self_eq (s : Submonoid M) : (s : Set M) * s = s :=
  by
  ext x
  refine' ⟨_, fun h => ⟨x, 1, h, s.one_mem, mul_one x⟩⟩
  rintro ⟨a, b, ha, hb, rfl⟩
  exact s.mul_mem ha hb
#align submonoid.coe_mul_self_eq Submonoid.coe_mul_self_eq
#align add_submonoid.coe_add_self_eq AddSubmonoid.coe_add_self_eq

/- warning: submonoid.closure_mul_le -> Submonoid.closure_mul_le is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (S : Set.{u1} M) (T : Set.{u1} M), LE.le.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Preorder.toLE.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.partialOrder.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.setLike.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))))) (Submonoid.closure.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1) (HMul.hMul.{u1, u1, u1} (Set.{u1} M) (Set.{u1} M) (Set.{u1} M) (instHMul.{u1} (Set.{u1} M) (Set.mul.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)))) S T)) (HasSup.sup.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SemilatticeSup.toHasSup.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Lattice.toSemilatticeSup.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (ConditionallyCompleteLattice.toLattice.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Submonoid.completeLattice.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)))))) (Submonoid.closure.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1) S) (Submonoid.closure.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1) T))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (S : Set.{u1} M) (T : Set.{u1} M), LE.le.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Preorder.toLE.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Submonoid.instCompleteLatticeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)))))) (Submonoid.closure.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1) (HMul.hMul.{u1, u1, u1} (Set.{u1} M) (Set.{u1} M) (Set.{u1} M) (instHMul.{u1} (Set.{u1} M) (Set.mul.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)))) S T)) (HasSup.sup.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SemilatticeSup.toHasSup.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Lattice.toSemilatticeSup.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (ConditionallyCompleteLattice.toLattice.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Submonoid.instCompleteLatticeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)))))) (Submonoid.closure.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1) S) (Submonoid.closure.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1) T))
Case conversion may be inaccurate. Consider using '#align submonoid.closure_mul_le Submonoid.closure_mul_leₓ'. -/
@[to_additive]
theorem closure_mul_le (S T : Set M) : closure (S * T) ≤ closure S ⊔ closure T :=
  infₛ_le fun x ⟨s, t, hs, ht, hx⟩ =>
    hx ▸
      (closure S ⊔ closure T).mul_mem (SetLike.le_def.mp le_sup_left <| subset_closure hs)
        (SetLike.le_def.mp le_sup_right <| subset_closure ht)
#align submonoid.closure_mul_le Submonoid.closure_mul_le
#align add_submonoid.closure_add_le AddSubmonoid.closure_add_le

/- warning: submonoid.sup_eq_closure -> Submonoid.sup_eq_closure is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (H : Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (K : Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)), Eq.{succ u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (HasSup.sup.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SemilatticeSup.toHasSup.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Lattice.toSemilatticeSup.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (ConditionallyCompleteLattice.toLattice.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Submonoid.completeLattice.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)))))) H K) (Submonoid.closure.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1) (HMul.hMul.{u1, u1, u1} (Set.{u1} M) (Set.{u1} M) (Set.{u1} M) (instHMul.{u1} (Set.{u1} M) (Set.mul.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Set.{u1} M) (HasLiftT.mk.{succ u1, succ u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Set.{u1} M) (CoeTCₓ.coe.{succ u1, succ u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Set.{u1} M) (SetLike.Set.hasCoeT.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.setLike.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))))) H) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Set.{u1} M) (HasLiftT.mk.{succ u1, succ u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Set.{u1} M) (CoeTCₓ.coe.{succ u1, succ u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Set.{u1} M) (SetLike.Set.hasCoeT.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.setLike.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))))) K)))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (H : Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (K : Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)), Eq.{succ u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (HasSup.sup.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SemilatticeSup.toHasSup.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Lattice.toSemilatticeSup.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (ConditionallyCompleteLattice.toLattice.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Submonoid.instCompleteLatticeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)))))) H K) (Submonoid.closure.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1) (HMul.hMul.{u1, u1, u1} (Set.{u1} M) (Set.{u1} M) (Set.{u1} M) (instHMul.{u1} (Set.{u1} M) (Set.mul.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)))) (SetLike.coe.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) H) (SetLike.coe.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) K)))
Case conversion may be inaccurate. Consider using '#align submonoid.sup_eq_closure Submonoid.sup_eq_closureₓ'. -/
@[to_additive]
theorem sup_eq_closure (H K : Submonoid M) : H ⊔ K = closure (H * K) :=
  le_antisymm
    (sup_le (fun h hh => subset_closure ⟨h, 1, hh, K.one_mem, mul_one h⟩) fun k hk =>
      subset_closure ⟨1, k, H.one_mem, hk, one_mul k⟩)
    (by conv_rhs => rw [← closure_eq H, ← closure_eq K] <;> apply closure_mul_le)
#align submonoid.sup_eq_closure Submonoid.sup_eq_closure
#align add_submonoid.sup_eq_closure AddSubmonoid.sup_eq_closure

/- warning: submonoid.pow_smul_mem_closure_smul -> Submonoid.pow_smul_mem_closure_smul is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {N : Type.{u2}} [_inst_3 : CommMonoid.{u2} N] [_inst_4 : MulAction.{u1, u2} M N _inst_1] [_inst_5 : IsScalarTower.{u1, u2, u2} M N N (MulAction.toHasSmul.{u1, u2} M N _inst_1 _inst_4) (Mul.toSMul.{u2} N (MulOneClass.toHasMul.{u2} N (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_3)))) (MulAction.toHasSmul.{u1, u2} M N _inst_1 _inst_4)] (r : M) (s : Set.{u2} N) {x : N}, (Membership.Mem.{u2, u2} N (Submonoid.{u2} N (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_3))) (SetLike.hasMem.{u2, u2} (Submonoid.{u2} N (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_3))) N (Submonoid.setLike.{u2} N (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_3)))) x (Submonoid.closure.{u2} N (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_3)) s)) -> (Exists.{1} Nat (fun (n : Nat) => Membership.Mem.{u2, u2} N (Submonoid.{u2} N (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_3))) (SetLike.hasMem.{u2, u2} (Submonoid.{u2} N (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_3))) N (Submonoid.setLike.{u2} N (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_3)))) (SMul.smul.{u1, u2} M N (MulAction.toHasSmul.{u1, u2} M N _inst_1 _inst_4) (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) r n) x) (Submonoid.closure.{u2} N (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_3)) (SMul.smul.{u1, u2} M (Set.{u2} N) (Set.smulSet.{u1, u2} M N (MulAction.toHasSmul.{u1, u2} M N _inst_1 _inst_4)) r s))))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {N : Type.{u2}} [_inst_3 : CommMonoid.{u2} N] [_inst_4 : MulAction.{u1, u2} M N _inst_1] [_inst_5 : IsScalarTower.{u1, u2, u2} M N N (MulAction.toSMul.{u1, u2} M N _inst_1 _inst_4) (MulAction.toSMul.{u2, u2} N N (CommMonoid.toMonoid.{u2} N _inst_3) (Monoid.toMulAction.{u2} N (CommMonoid.toMonoid.{u2} N _inst_3))) (MulAction.toSMul.{u1, u2} M N _inst_1 _inst_4)] (r : M) (s : Set.{u2} N) {x : N}, (Membership.mem.{u2, u2} N (Submonoid.{u2} N (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_3))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} N (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_3))) N (Submonoid.instSetLikeSubmonoid.{u2} N (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_3)))) x (Submonoid.closure.{u2} N (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_3)) s)) -> (Exists.{1} Nat (fun (n : Nat) => Membership.mem.{u2, u2} N (Submonoid.{u2} N (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_3))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} N (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_3))) N (Submonoid.instSetLikeSubmonoid.{u2} N (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_3)))) (HSMul.hSMul.{u1, u2, u2} M N N (instHSMul.{u1, u2} M N (MulAction.toSMul.{u1, u2} M N _inst_1 _inst_4)) (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) r n) x) (Submonoid.closure.{u2} N (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_3)) (HSMul.hSMul.{u1, u2, u2} M (Set.{u2} N) (Set.{u2} N) (instHSMul.{u1, u2} M (Set.{u2} N) (Set.smulSet.{u1, u2} M N (MulAction.toSMul.{u1, u2} M N _inst_1 _inst_4))) r s))))
Case conversion may be inaccurate. Consider using '#align submonoid.pow_smul_mem_closure_smul Submonoid.pow_smul_mem_closure_smulₓ'. -/
@[to_additive]
theorem pow_smul_mem_closure_smul {N : Type _} [CommMonoid N] [MulAction M N] [IsScalarTower M N N]
    (r : M) (s : Set N) {x : N} (hx : x ∈ closure s) : ∃ n : ℕ, r ^ n • x ∈ closure (r • s) :=
  by
  apply @closure_induction N _ s (fun x : N => ∃ n : ℕ, r ^ n • x ∈ closure (r • s)) _ hx
  · intro x hx
    exact ⟨1, subset_closure ⟨_, hx, by rw [pow_one]⟩⟩
  · exact ⟨0, by simpa using one_mem _⟩
  · rintro x y ⟨nx, hx⟩ ⟨ny, hy⟩
    use nx + ny
    convert mul_mem hx hy
    rw [pow_add, smul_mul_assoc, mul_smul, mul_comm, ← smul_mul_assoc, mul_comm]
#align submonoid.pow_smul_mem_closure_smul Submonoid.pow_smul_mem_closure_smul
#align add_submonoid.nsmul_vadd_mem_closure_vadd AddSubmonoid.nsmul_vadd_mem_closure_vadd

variable [Group G]

open Pointwise

#print Submonoid.inv /-
/-- The submonoid with every element inverted. -/
@[to_additive " The additive submonoid with every element negated. "]
protected def inv : Inv (Submonoid G)
    where inv S :=
    { carrier := (S : Set G)⁻¹
      one_mem' :=
        show (1 : G)⁻¹ ∈ S by
          rw [inv_one]
          exact S.one_mem
      mul_mem' := fun a b (ha : a⁻¹ ∈ S) (hb : b⁻¹ ∈ S) =>
        show (a * b)⁻¹ ∈ S by
          rw [mul_inv_rev]
          exact S.mul_mem hb ha }
#align submonoid.has_inv Submonoid.inv
#align add_submonoid.has_neg AddSubmonoid.neg
-/

scoped[Pointwise] attribute [instance] Submonoid.inv

open Pointwise

/- warning: submonoid.coe_inv -> Submonoid.coe_inv is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_3 : Group.{u1} G] (S : Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))), Eq.{succ u1} (Set.{u1} G) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) G (Submonoid.setLike.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))))) (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) S)) (Inv.inv.{u1} (Set.{u1} G) (Set.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Set.{u1} G) (HasLiftT.mk.{succ u1, succ u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Set.{u1} G) (CoeTCₓ.coe.{succ u1, succ u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Set.{u1} G) (SetLike.Set.hasCoeT.{u1, u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) G (Submonoid.setLike.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))))) S))
but is expected to have type
  forall {G : Type.{u1}} [_inst_3 : Group.{u1} G] (S : Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))), Eq.{succ u1} (Set.{u1} G) (SetLike.coe.{u1, u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) G (Submonoid.instSetLikeSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) S)) (Inv.inv.{u1} (Set.{u1} G) (Set.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_3))))) (SetLike.coe.{u1, u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) G (Submonoid.instSetLikeSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) S))
Case conversion may be inaccurate. Consider using '#align submonoid.coe_inv Submonoid.coe_invₓ'. -/
@[simp, to_additive]
theorem coe_inv (S : Submonoid G) : ↑S⁻¹ = (S : Set G)⁻¹ :=
  rfl
#align submonoid.coe_inv Submonoid.coe_inv
#align add_submonoid.coe_neg AddSubmonoid.coe_neg

/- warning: submonoid.mem_inv -> Submonoid.mem_inv is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_3 : Group.{u1} G] {g : G} {S : Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))}, Iff (Membership.Mem.{u1, u1} G (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) G (Submonoid.setLike.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) g (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) S)) (Membership.Mem.{u1, u1} G (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) G (Submonoid.setLike.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) g) S)
but is expected to have type
  forall {G : Type.{u1}} [_inst_3 : Group.{u1} G] {g : G} {S : Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))}, Iff (Membership.mem.{u1, u1} G (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) G (Submonoid.instSetLikeSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) g (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) S)) (Membership.mem.{u1, u1} G (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) G (Submonoid.instSetLikeSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_3)))) g) S)
Case conversion may be inaccurate. Consider using '#align submonoid.mem_inv Submonoid.mem_invₓ'. -/
@[simp, to_additive]
theorem mem_inv {g : G} {S : Submonoid G} : g ∈ S⁻¹ ↔ g⁻¹ ∈ S :=
  Iff.rfl
#align submonoid.mem_inv Submonoid.mem_inv
#align add_submonoid.mem_neg AddSubmonoid.mem_neg

@[to_additive]
instance : InvolutiveInv (Submonoid G) :=
  SetLike.coe_injective.InvolutiveInv _ fun _ => rfl

/- warning: submonoid.inv_le_inv -> Submonoid.inv_le_inv is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_3 : Group.{u1} G] (S : Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (T : Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))), Iff (LE.le.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Preorder.toLE.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (SetLike.partialOrder.{u1, u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) G (Submonoid.setLike.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))))) (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) S) (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) T)) (LE.le.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Preorder.toLE.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (SetLike.partialOrder.{u1, u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) G (Submonoid.setLike.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))))) S T)
but is expected to have type
  forall {G : Type.{u1}} [_inst_3 : Group.{u1} G] (S : Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (T : Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))), Iff (LE.le.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Preorder.toLE.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.instCompleteLatticeSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))))))) (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) S) (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) T)) (LE.le.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Preorder.toLE.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.instCompleteLatticeSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))))))) S T)
Case conversion may be inaccurate. Consider using '#align submonoid.inv_le_inv Submonoid.inv_le_invₓ'. -/
@[simp, to_additive]
theorem inv_le_inv (S T : Submonoid G) : S⁻¹ ≤ T⁻¹ ↔ S ≤ T :=
  SetLike.coe_subset_coe.symm.trans Set.inv_subset_inv
#align submonoid.inv_le_inv Submonoid.inv_le_inv
#align add_submonoid.neg_le_neg AddSubmonoid.neg_le_neg

/- warning: submonoid.inv_le -> Submonoid.inv_le is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_3 : Group.{u1} G] (S : Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (T : Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))), Iff (LE.le.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Preorder.toLE.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (SetLike.partialOrder.{u1, u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) G (Submonoid.setLike.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))))) (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) S) T) (LE.le.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Preorder.toLE.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (SetLike.partialOrder.{u1, u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) G (Submonoid.setLike.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))))) S (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) T))
but is expected to have type
  forall {G : Type.{u1}} [_inst_3 : Group.{u1} G] (S : Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (T : Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))), Iff (LE.le.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Preorder.toLE.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.instCompleteLatticeSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))))))) (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) S) T) (LE.le.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Preorder.toLE.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.instCompleteLatticeSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))))))) S (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) T))
Case conversion may be inaccurate. Consider using '#align submonoid.inv_le Submonoid.inv_leₓ'. -/
@[to_additive]
theorem inv_le (S T : Submonoid G) : S⁻¹ ≤ T ↔ S ≤ T⁻¹ :=
  SetLike.coe_subset_coe.symm.trans Set.inv_subset
#align submonoid.inv_le Submonoid.inv_le
#align add_submonoid.neg_le AddSubmonoid.neg_le

/- warning: submonoid.inv_order_iso -> Submonoid.invOrderIso is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_3 : Group.{u1} G], OrderIso.{u1, u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Preorder.toLE.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (SetLike.partialOrder.{u1, u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) G (Submonoid.setLike.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))))) (Preorder.toLE.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (SetLike.partialOrder.{u1, u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) G (Submonoid.setLike.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_3 : Group.{u1} G], OrderIso.{u1, u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Preorder.toLE.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.instCompleteLatticeSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))))))) (Preorder.toLE.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.instCompleteLatticeSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))))))
Case conversion may be inaccurate. Consider using '#align submonoid.inv_order_iso Submonoid.invOrderIsoₓ'. -/
/-- `submonoid.has_inv` as an order isomorphism. -/
@[to_additive " `add_submonoid.has_neg` as an order isomorphism ", simps]
def invOrderIso : Submonoid G ≃o Submonoid G
    where
  toEquiv := Equiv.inv _
  map_rel_iff' := inv_le_inv
#align submonoid.inv_order_iso Submonoid.invOrderIso
#align add_submonoid.neg_order_iso AddSubmonoid.negOrderIso

/- warning: submonoid.closure_inv -> Submonoid.closure_inv is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_3 : Group.{u1} G] (s : Set.{u1} G), Eq.{succ u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.closure.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Inv.inv.{u1} (Set.{u1} G) (Set.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) s)) (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) (Submonoid.closure.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) s))
but is expected to have type
  forall {G : Type.{u1}} [_inst_3 : Group.{u1} G] (s : Set.{u1} G), Eq.{succ u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.closure.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Inv.inv.{u1} (Set.{u1} G) (Set.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_3))))) s)) (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) (Submonoid.closure.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) s))
Case conversion may be inaccurate. Consider using '#align submonoid.closure_inv Submonoid.closure_invₓ'. -/
@[to_additive]
theorem closure_inv (s : Set G) : closure s⁻¹ = (closure s)⁻¹ :=
  by
  apply le_antisymm
  · rw [closure_le, coe_inv, ← Set.inv_subset, inv_inv]
    exact subset_closure
  · rw [inv_le, closure_le, coe_inv, ← Set.inv_subset]
    exact subset_closure
#align submonoid.closure_inv Submonoid.closure_inv
#align add_submonoid.closure_neg AddSubmonoid.closure_neg

/- warning: submonoid.inv_inf -> Submonoid.inv_inf is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_3 : Group.{u1} G] (S : Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (T : Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))), Eq.{succ u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) (HasInf.inf.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.hasInf.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) S T)) (HasInf.inf.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.hasInf.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) S) (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) T))
but is expected to have type
  forall {G : Type.{u1}} [_inst_3 : Group.{u1} G] (S : Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (T : Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))), Eq.{succ u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) (HasInf.inf.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.instHasInfSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) S T)) (HasInf.inf.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.instHasInfSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) S) (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) T))
Case conversion may be inaccurate. Consider using '#align submonoid.inv_inf Submonoid.inv_infₓ'. -/
@[simp, to_additive]
theorem inv_inf (S T : Submonoid G) : (S ⊓ T)⁻¹ = S⁻¹ ⊓ T⁻¹ :=
  SetLike.coe_injective Set.inter_inv
#align submonoid.inv_inf Submonoid.inv_inf
#align add_submonoid.neg_inf AddSubmonoid.neg_inf

/- warning: submonoid.inv_sup -> Submonoid.inv_sup is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_3 : Group.{u1} G] (S : Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (T : Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))), Eq.{succ u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) (HasSup.sup.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (SemilatticeSup.toHasSup.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Lattice.toSemilatticeSup.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (ConditionallyCompleteLattice.toLattice.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.completeLattice.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))))))) S T)) (HasSup.sup.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (SemilatticeSup.toHasSup.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Lattice.toSemilatticeSup.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (ConditionallyCompleteLattice.toLattice.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.completeLattice.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))))))) (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) S) (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) T))
but is expected to have type
  forall {G : Type.{u1}} [_inst_3 : Group.{u1} G] (S : Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (T : Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))), Eq.{succ u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) (HasSup.sup.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (SemilatticeSup.toHasSup.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Lattice.toSemilatticeSup.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (ConditionallyCompleteLattice.toLattice.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.instCompleteLatticeSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))))))) S T)) (HasSup.sup.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (SemilatticeSup.toHasSup.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Lattice.toSemilatticeSup.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (ConditionallyCompleteLattice.toLattice.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.instCompleteLatticeSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))))))) (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) S) (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) T))
Case conversion may be inaccurate. Consider using '#align submonoid.inv_sup Submonoid.inv_supₓ'. -/
@[simp, to_additive]
theorem inv_sup (S T : Submonoid G) : (S ⊔ T)⁻¹ = S⁻¹ ⊔ T⁻¹ :=
  (invOrderIso : Submonoid G ≃o Submonoid G).map_sup S T
#align submonoid.inv_sup Submonoid.inv_sup
#align add_submonoid.neg_sup AddSubmonoid.neg_sup

/- warning: submonoid.inv_bot -> Submonoid.inv_bot is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_3 : Group.{u1} G], Eq.{succ u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) (Bot.bot.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.hasBot.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))))) (Bot.bot.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.hasBot.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_3 : Group.{u1} G], Eq.{succ u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) (Bot.bot.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.instBotSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))))) (Bot.bot.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.instBotSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))))
Case conversion may be inaccurate. Consider using '#align submonoid.inv_bot Submonoid.inv_botₓ'. -/
@[simp, to_additive]
theorem inv_bot : (⊥ : Submonoid G)⁻¹ = ⊥ :=
  SetLike.coe_injective <| (Set.inv_singleton 1).trans <| congr_arg _ inv_one
#align submonoid.inv_bot Submonoid.inv_bot
#align add_submonoid.neg_bot AddSubmonoid.neg_bot

/- warning: submonoid.inv_top -> Submonoid.inv_top is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_3 : Group.{u1} G], Eq.{succ u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) (Top.top.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.hasTop.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))))) (Top.top.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.hasTop.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_3 : Group.{u1} G], Eq.{succ u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) (Top.top.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.instTopSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))))) (Top.top.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.instTopSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))))
Case conversion may be inaccurate. Consider using '#align submonoid.inv_top Submonoid.inv_topₓ'. -/
@[simp, to_additive]
theorem inv_top : (⊤ : Submonoid G)⁻¹ = ⊤ :=
  SetLike.coe_injective <| Set.inv_univ
#align submonoid.inv_top Submonoid.inv_top
#align add_submonoid.neg_top AddSubmonoid.neg_top

#print Submonoid.inv_infᵢ /-
@[simp, to_additive]
theorem inv_infᵢ {ι : Sort _} (S : ι → Submonoid G) : (⨅ i, S i)⁻¹ = ⨅ i, (S i)⁻¹ :=
  (invOrderIso : Submonoid G ≃o Submonoid G).map_infᵢ _
#align submonoid.inv_infi Submonoid.inv_infᵢ
#align add_submonoid.neg_infi AddSubmonoid.neg_infᵢ
-/

/- warning: submonoid.inv_supr -> Submonoid.inv_supᵢ is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_3 : Group.{u1} G] {ι : Sort.{u2}} (S : ι -> (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))), Eq.{succ u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) (supᵢ.{u1, u2} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (ConditionallyCompleteLattice.toHasSup.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.completeLattice.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))))) ι (fun (i : ι) => S i))) (supᵢ.{u1, u2} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (ConditionallyCompleteLattice.toHasSup.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.completeLattice.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))))) ι (fun (i : ι) => Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) (S i)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_3 : Group.{u1} G] {ι : Sort.{u2}} (S : ι -> (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))), Eq.{succ u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) (supᵢ.{u1, u2} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (ConditionallyCompleteLattice.toSupSet.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.instCompleteLatticeSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))))) ι (fun (i : ι) => S i))) (supᵢ.{u1, u2} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (ConditionallyCompleteLattice.toSupSet.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.instCompleteLatticeSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))))) ι (fun (i : ι) => Inv.inv.{u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (Submonoid.inv.{u1} G _inst_3) (S i)))
Case conversion may be inaccurate. Consider using '#align submonoid.inv_supr Submonoid.inv_supᵢₓ'. -/
@[simp, to_additive]
theorem inv_supᵢ {ι : Sort _} (S : ι → Submonoid G) : (⨆ i, S i)⁻¹ = ⨆ i, (S i)⁻¹ :=
  (invOrderIso : Submonoid G ≃o Submonoid G).map_supᵢ _
#align submonoid.inv_supr Submonoid.inv_supᵢ
#align add_submonoid.neg_supr AddSubmonoid.neg_supᵢ

end Submonoid

namespace Submonoid

section Monoid

variable [Monoid α] [MulDistribMulAction α M]

#print Submonoid.pointwiseMulAction /-
/-- The action on a submonoid corresponding to applying the action to every element.

This is available as an instance in the `pointwise` locale. -/
protected def pointwiseMulAction : MulAction α (Submonoid M)
    where
  smul a S := S.map (MulDistribMulAction.toMonoidEnd _ M a)
  one_smul S := by
    ext
    simp
  mul_smul a₁ a₂ S :=
    (congr_arg (fun f : Monoid.End M => S.map f) (MonoidHom.map_mul _ _ _)).trans
      (S.map_map _ _).symm
#align submonoid.pointwise_mul_action Submonoid.pointwiseMulAction
-/

scoped[Pointwise] attribute [instance] Submonoid.pointwiseMulAction

open Pointwise

/- warning: submonoid.coe_pointwise_smul -> Submonoid.coe_pointwise_smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] [_inst_3 : Monoid.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α M _inst_3 _inst_1] (a : α) (S : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)), Eq.{succ u2} (Set.{u2} M) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))))) (SMul.smul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toHasSmul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) _inst_3 (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 _inst_3 _inst_4)) a S)) (SMul.smul.{u1, u2} α (Set.{u2} M) (Set.smulSet.{u1, u2} α M (MulAction.toHasSmul.{u1, u2} α M _inst_3 (MulDistribMulAction.toMulAction.{u1, u2} α M _inst_3 _inst_1 _inst_4))) a ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))))) S))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] [_inst_3 : Monoid.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α M _inst_3 _inst_1] (a : α) (S : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)), Eq.{succ u2} (Set.{u2} M) (SetLike.coe.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (HSMul.hSMul.{u1, u2, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (instHSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) _inst_3 (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 _inst_3 _inst_4))) a S)) (HSMul.hSMul.{u1, u2, u2} α (Set.{u2} M) (Set.{u2} M) (instHSMul.{u1, u2} α (Set.{u2} M) (Set.smulSet.{u1, u2} α M (MulAction.toSMul.{u1, u2} α M _inst_3 (MulDistribMulAction.toMulAction.{u1, u2} α M _inst_3 _inst_1 _inst_4)))) a (SetLike.coe.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) S))
Case conversion may be inaccurate. Consider using '#align submonoid.coe_pointwise_smul Submonoid.coe_pointwise_smulₓ'. -/
@[simp]
theorem coe_pointwise_smul (a : α) (S : Submonoid M) : ↑(a • S) = a • (S : Set M) :=
  rfl
#align submonoid.coe_pointwise_smul Submonoid.coe_pointwise_smul

/- warning: submonoid.smul_mem_pointwise_smul -> Submonoid.smul_mem_pointwise_smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] [_inst_3 : Monoid.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α M _inst_3 _inst_1] (m : M) (a : α) (S : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)), (Membership.Mem.{u2, u2} M (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.hasMem.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) m S) -> (Membership.Mem.{u2, u2} M (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.hasMem.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) (SMul.smul.{u1, u2} α M (MulAction.toHasSmul.{u1, u2} α M _inst_3 (MulDistribMulAction.toMulAction.{u1, u2} α M _inst_3 _inst_1 _inst_4)) a m) (SMul.smul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toHasSmul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) _inst_3 (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 _inst_3 _inst_4)) a S))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] [_inst_3 : Monoid.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α M _inst_3 _inst_1] (m : M) (a : α) (S : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)), (Membership.mem.{u2, u2} M (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) m S) -> (Membership.mem.{u2, u2} M (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) (HSMul.hSMul.{u1, u2, u2} α M M (instHSMul.{u1, u2} α M (MulAction.toSMul.{u1, u2} α M _inst_3 (MulDistribMulAction.toMulAction.{u1, u2} α M _inst_3 _inst_1 _inst_4))) a m) (HSMul.hSMul.{u1, u2, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (instHSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) _inst_3 (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 _inst_3 _inst_4))) a S))
Case conversion may be inaccurate. Consider using '#align submonoid.smul_mem_pointwise_smul Submonoid.smul_mem_pointwise_smulₓ'. -/
theorem smul_mem_pointwise_smul (m : M) (a : α) (S : Submonoid M) : m ∈ S → a • m ∈ a • S :=
  (Set.smul_mem_smul_set : _ → _ ∈ a • (S : Set M))
#align submonoid.smul_mem_pointwise_smul Submonoid.smul_mem_pointwise_smul

/- warning: submonoid.mem_smul_pointwise_iff_exists -> Submonoid.mem_smul_pointwise_iff_exists is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] [_inst_3 : Monoid.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α M _inst_3 _inst_1] (m : M) (a : α) (S : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)), Iff (Membership.Mem.{u2, u2} M (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.hasMem.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) m (SMul.smul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toHasSmul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) _inst_3 (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 _inst_3 _inst_4)) a S)) (Exists.{succ u2} M (fun (s : M) => And (Membership.Mem.{u2, u2} M (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.hasMem.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) s S) (Eq.{succ u2} M (SMul.smul.{u1, u2} α M (MulAction.toHasSmul.{u1, u2} α M _inst_3 (MulDistribMulAction.toMulAction.{u1, u2} α M _inst_3 _inst_1 _inst_4)) a s) m)))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] [_inst_3 : Monoid.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α M _inst_3 _inst_1] (m : M) (a : α) (S : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)), Iff (Membership.mem.{u2, u2} M (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) m (HSMul.hSMul.{u1, u2, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (instHSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) _inst_3 (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 _inst_3 _inst_4))) a S)) (Exists.{succ u2} M (fun (s : M) => And (Membership.mem.{u2, u2} M (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) s S) (Eq.{succ u2} M (HSMul.hSMul.{u1, u2, u2} α M M (instHSMul.{u1, u2} α M (MulAction.toSMul.{u1, u2} α M _inst_3 (MulDistribMulAction.toMulAction.{u1, u2} α M _inst_3 _inst_1 _inst_4))) a s) m)))
Case conversion may be inaccurate. Consider using '#align submonoid.mem_smul_pointwise_iff_exists Submonoid.mem_smul_pointwise_iff_existsₓ'. -/
theorem mem_smul_pointwise_iff_exists (m : M) (a : α) (S : Submonoid M) :
    m ∈ a • S ↔ ∃ s : M, s ∈ S ∧ a • s = m :=
  (Set.mem_smul_set : m ∈ a • (S : Set M) ↔ _)
#align submonoid.mem_smul_pointwise_iff_exists Submonoid.mem_smul_pointwise_iff_exists

/- warning: submonoid.smul_bot -> Submonoid.smul_bot is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] [_inst_3 : Monoid.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α M _inst_3 _inst_1] (a : α), Eq.{succ u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SMul.smul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toHasSmul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) _inst_3 (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 _inst_3 _inst_4)) a (Bot.bot.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.hasBot.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)))) (Bot.bot.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.hasBot.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] [_inst_3 : Monoid.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α M _inst_3 _inst_1] (a : α), Eq.{succ u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (HSMul.hSMul.{u1, u2, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (instHSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) _inst_3 (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 _inst_3 _inst_4))) a (Bot.bot.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.instBotSubmonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)))) (Bot.bot.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.instBotSubmonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)))
Case conversion may be inaccurate. Consider using '#align submonoid.smul_bot Submonoid.smul_botₓ'. -/
@[simp]
theorem smul_bot (a : α) : a • (⊥ : Submonoid M) = ⊥ :=
  map_bot _
#align submonoid.smul_bot Submonoid.smul_bot

/- warning: submonoid.smul_sup -> Submonoid.smul_sup is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] [_inst_3 : Monoid.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α M _inst_3 _inst_1] (a : α) (S : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (T : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)), Eq.{succ u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SMul.smul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toHasSmul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) _inst_3 (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 _inst_3 _inst_4)) a (HasSup.sup.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SemilatticeSup.toHasSup.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Lattice.toSemilatticeSup.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (ConditionallyCompleteLattice.toLattice.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.completeLattice.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)))))) S T)) (HasSup.sup.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SemilatticeSup.toHasSup.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Lattice.toSemilatticeSup.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (ConditionallyCompleteLattice.toLattice.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.completeLattice.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)))))) (SMul.smul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toHasSmul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) _inst_3 (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 _inst_3 _inst_4)) a S) (SMul.smul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toHasSmul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) _inst_3 (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 _inst_3 _inst_4)) a T))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] [_inst_3 : Monoid.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α M _inst_3 _inst_1] (a : α) (S : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (T : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)), Eq.{succ u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (HSMul.hSMul.{u1, u2, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (instHSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) _inst_3 (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 _inst_3 _inst_4))) a (HasSup.sup.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SemilatticeSup.toHasSup.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Lattice.toSemilatticeSup.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (ConditionallyCompleteLattice.toLattice.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.instCompleteLatticeSubmonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)))))) S T)) (HasSup.sup.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SemilatticeSup.toHasSup.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Lattice.toSemilatticeSup.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (ConditionallyCompleteLattice.toLattice.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.instCompleteLatticeSubmonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)))))) (HSMul.hSMul.{u1, u2, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (instHSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) _inst_3 (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 _inst_3 _inst_4))) a S) (HSMul.hSMul.{u1, u2, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (instHSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) _inst_3 (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 _inst_3 _inst_4))) a T))
Case conversion may be inaccurate. Consider using '#align submonoid.smul_sup Submonoid.smul_supₓ'. -/
theorem smul_sup (a : α) (S T : Submonoid M) : a • (S ⊔ T) = a • S ⊔ a • T :=
  map_sup _ _ _
#align submonoid.smul_sup Submonoid.smul_sup

#print Submonoid.smul_closure /-
theorem smul_closure (a : α) (s : Set M) : a • closure s = closure (a • s) :=
  MonoidHom.map_mclosure _ _
#align submonoid.smul_closure Submonoid.smul_closure
-/

/- warning: submonoid.pointwise_central_scalar -> Submonoid.pointwise_isCentralScalar is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] [_inst_3 : Monoid.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α M _inst_3 _inst_1] [_inst_5 : MulDistribMulAction.{u1, u2} (MulOpposite.{u1} α) M (MulOpposite.monoid.{u1} α _inst_3) _inst_1] [_inst_6 : IsCentralScalar.{u1, u2} α M (MulAction.toHasSmul.{u1, u2} α M _inst_3 (MulDistribMulAction.toMulAction.{u1, u2} α M _inst_3 _inst_1 _inst_4)) (MulAction.toHasSmul.{u1, u2} (MulOpposite.{u1} α) M (MulOpposite.monoid.{u1} α _inst_3) (MulDistribMulAction.toMulAction.{u1, u2} (MulOpposite.{u1} α) M (MulOpposite.monoid.{u1} α _inst_3) _inst_1 _inst_5))], IsCentralScalar.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toHasSmul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) _inst_3 (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 _inst_3 _inst_4)) (MulAction.toHasSmul.{u1, u2} (MulOpposite.{u1} α) (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulOpposite.monoid.{u1} α _inst_3) (Submonoid.pointwiseMulAction.{u1, u2} (MulOpposite.{u1} α) M _inst_1 (MulOpposite.monoid.{u1} α _inst_3) _inst_5))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] [_inst_3 : Monoid.{u2} α] [_inst_4 : MulDistribMulAction.{u2, u1} α M _inst_3 _inst_1] [_inst_5 : MulDistribMulAction.{u2, u1} (MulOpposite.{u2} α) M (MulOpposite.instMonoidMulOpposite.{u2} α _inst_3) _inst_1] [_inst_6 : IsCentralScalar.{u2, u1} α M (MulAction.toSMul.{u2, u1} α M _inst_3 (MulDistribMulAction.toMulAction.{u2, u1} α M _inst_3 _inst_1 _inst_4)) (MulAction.toSMul.{u2, u1} (MulOpposite.{u2} α) M (MulOpposite.instMonoidMulOpposite.{u2} α _inst_3) (MulDistribMulAction.toMulAction.{u2, u1} (MulOpposite.{u2} α) M (MulOpposite.instMonoidMulOpposite.{u2} α _inst_3) _inst_1 _inst_5))], IsCentralScalar.{u2, u1} α (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MulAction.toSMul.{u2, u1} α (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) _inst_3 (Submonoid.pointwiseMulAction.{u2, u1} α M _inst_1 _inst_3 _inst_4)) (MulAction.toSMul.{u2, u1} (MulOpposite.{u2} α) (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MulOpposite.instMonoidMulOpposite.{u2} α _inst_3) (Submonoid.pointwiseMulAction.{u2, u1} (MulOpposite.{u2} α) M _inst_1 (MulOpposite.instMonoidMulOpposite.{u2} α _inst_3) _inst_5))
Case conversion may be inaccurate. Consider using '#align submonoid.pointwise_central_scalar Submonoid.pointwise_isCentralScalarₓ'. -/
instance pointwise_isCentralScalar [MulDistribMulAction αᵐᵒᵖ M] [IsCentralScalar α M] :
    IsCentralScalar α (Submonoid M) :=
  ⟨fun a S => (congr_arg fun f : Monoid.End M => S.map f) <| MonoidHom.ext <| op_smul_eq_smul _⟩
#align submonoid.pointwise_central_scalar Submonoid.pointwise_isCentralScalar

end Monoid

section Group

variable [Group α] [MulDistribMulAction α M]

open Pointwise

/- warning: submonoid.smul_mem_pointwise_smul_iff -> Submonoid.smul_mem_pointwise_smul_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] [_inst_3 : Group.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α M (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_1] {a : α} {S : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)} {x : M}, Iff (Membership.Mem.{u2, u2} M (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.hasMem.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) (SMul.smul.{u1, u2} α M (MulAction.toHasSmul.{u1, u2} α M (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (MulDistribMulAction.toMulAction.{u1, u2} α M (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_1 _inst_4)) a x) (SMul.smul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toHasSmul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) a S)) (Membership.Mem.{u2, u2} M (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.hasMem.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) x S)
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] [_inst_3 : Group.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α M (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_1] {a : α} {S : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)} {x : M}, Iff (Membership.mem.{u2, u2} M (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) (HSMul.hSMul.{u1, u2, u2} α M M (instHSMul.{u1, u2} α M (MulAction.toSMul.{u1, u2} α M (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (MulDistribMulAction.toMulAction.{u1, u2} α M (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_1 _inst_4))) a x) (HSMul.hSMul.{u1, u2, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (instHSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) a S)) (Membership.mem.{u2, u2} M (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) x S)
Case conversion may be inaccurate. Consider using '#align submonoid.smul_mem_pointwise_smul_iff Submonoid.smul_mem_pointwise_smul_iffₓ'. -/
@[simp]
theorem smul_mem_pointwise_smul_iff {a : α} {S : Submonoid M} {x : M} : a • x ∈ a • S ↔ x ∈ S :=
  smul_mem_smul_set_iff
#align submonoid.smul_mem_pointwise_smul_iff Submonoid.smul_mem_pointwise_smul_iff

/- warning: submonoid.mem_pointwise_smul_iff_inv_smul_mem -> Submonoid.mem_pointwise_smul_iff_inv_smul_mem is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] [_inst_3 : Group.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α M (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_1] {a : α} {S : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)} {x : M}, Iff (Membership.Mem.{u2, u2} M (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.hasMem.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) x (SMul.smul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toHasSmul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) a S)) (Membership.Mem.{u2, u2} M (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.hasMem.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) (SMul.smul.{u1, u2} α M (MulAction.toHasSmul.{u1, u2} α M (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (MulDistribMulAction.toMulAction.{u1, u2} α M (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_1 _inst_4)) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) a) x) S)
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] [_inst_3 : Group.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α M (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_1] {a : α} {S : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)} {x : M}, Iff (Membership.mem.{u2, u2} M (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) x (HSMul.hSMul.{u1, u2, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (instHSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) a S)) (Membership.mem.{u2, u2} M (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) (HSMul.hSMul.{u1, u2, u2} α M M (instHSMul.{u1, u2} α M (MulAction.toSMul.{u1, u2} α M (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (MulDistribMulAction.toMulAction.{u1, u2} α M (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_1 _inst_4))) (Inv.inv.{u1} α (InvOneClass.toInv.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (Group.toDivisionMonoid.{u1} α _inst_3)))) a) x) S)
Case conversion may be inaccurate. Consider using '#align submonoid.mem_pointwise_smul_iff_inv_smul_mem Submonoid.mem_pointwise_smul_iff_inv_smul_memₓ'. -/
theorem mem_pointwise_smul_iff_inv_smul_mem {a : α} {S : Submonoid M} {x : M} :
    x ∈ a • S ↔ a⁻¹ • x ∈ S :=
  mem_smul_set_iff_inv_smul_mem
#align submonoid.mem_pointwise_smul_iff_inv_smul_mem Submonoid.mem_pointwise_smul_iff_inv_smul_mem

/- warning: submonoid.mem_inv_pointwise_smul_iff -> Submonoid.mem_inv_pointwise_smul_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] [_inst_3 : Group.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α M (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_1] {a : α} {S : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)} {x : M}, Iff (Membership.Mem.{u2, u2} M (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.hasMem.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) x (SMul.smul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toHasSmul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) a) S)) (Membership.Mem.{u2, u2} M (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.hasMem.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) (SMul.smul.{u1, u2} α M (MulAction.toHasSmul.{u1, u2} α M (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (MulDistribMulAction.toMulAction.{u1, u2} α M (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_1 _inst_4)) a x) S)
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] [_inst_3 : Group.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α M (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_1] {a : α} {S : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)} {x : M}, Iff (Membership.mem.{u2, u2} M (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) x (HSMul.hSMul.{u1, u2, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (instHSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) (Inv.inv.{u1} α (InvOneClass.toInv.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (Group.toDivisionMonoid.{u1} α _inst_3)))) a) S)) (Membership.mem.{u2, u2} M (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) (HSMul.hSMul.{u1, u2, u2} α M M (instHSMul.{u1, u2} α M (MulAction.toSMul.{u1, u2} α M (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (MulDistribMulAction.toMulAction.{u1, u2} α M (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_1 _inst_4))) a x) S)
Case conversion may be inaccurate. Consider using '#align submonoid.mem_inv_pointwise_smul_iff Submonoid.mem_inv_pointwise_smul_iffₓ'. -/
theorem mem_inv_pointwise_smul_iff {a : α} {S : Submonoid M} {x : M} : x ∈ a⁻¹ • S ↔ a • x ∈ S :=
  mem_inv_smul_set_iff
#align submonoid.mem_inv_pointwise_smul_iff Submonoid.mem_inv_pointwise_smul_iff

/- warning: submonoid.pointwise_smul_le_pointwise_smul_iff -> Submonoid.pointwise_smul_le_pointwise_smul_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] [_inst_3 : Group.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α M (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_1] {a : α} {S : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)} {T : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)}, Iff (LE.le.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Preorder.toLE.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (PartialOrder.toPreorder.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.partialOrder.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))))) (SMul.smul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toHasSmul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) a S) (SMul.smul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toHasSmul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) a T)) (LE.le.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Preorder.toLE.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (PartialOrder.toPreorder.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.partialOrder.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))))) S T)
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] [_inst_3 : Group.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α M (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_1] {a : α} {S : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)} {T : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)}, Iff (LE.le.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Preorder.toLE.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (PartialOrder.toPreorder.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.instCompleteLatticeSubmonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)))))) (HSMul.hSMul.{u1, u2, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (instHSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) a S) (HSMul.hSMul.{u1, u2, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (instHSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) a T)) (LE.le.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Preorder.toLE.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (PartialOrder.toPreorder.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.instCompleteLatticeSubmonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)))))) S T)
Case conversion may be inaccurate. Consider using '#align submonoid.pointwise_smul_le_pointwise_smul_iff Submonoid.pointwise_smul_le_pointwise_smul_iffₓ'. -/
@[simp]
theorem pointwise_smul_le_pointwise_smul_iff {a : α} {S T : Submonoid M} : a • S ≤ a • T ↔ S ≤ T :=
  set_smul_subset_set_smul_iff
#align submonoid.pointwise_smul_le_pointwise_smul_iff Submonoid.pointwise_smul_le_pointwise_smul_iff

/- warning: submonoid.pointwise_smul_subset_iff -> Submonoid.pointwise_smul_subset_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] [_inst_3 : Group.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α M (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_1] {a : α} {S : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)} {T : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)}, Iff (LE.le.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Preorder.toLE.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (PartialOrder.toPreorder.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.partialOrder.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))))) (SMul.smul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toHasSmul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) a S) T) (LE.le.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Preorder.toLE.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (PartialOrder.toPreorder.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.partialOrder.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))))) S (SMul.smul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toHasSmul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) a) T))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] [_inst_3 : Group.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α M (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_1] {a : α} {S : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)} {T : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)}, Iff (LE.le.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Preorder.toLE.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (PartialOrder.toPreorder.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.instCompleteLatticeSubmonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)))))) (HSMul.hSMul.{u1, u2, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (instHSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) a S) T) (LE.le.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Preorder.toLE.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (PartialOrder.toPreorder.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.instCompleteLatticeSubmonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)))))) S (HSMul.hSMul.{u1, u2, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (instHSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) (Inv.inv.{u1} α (InvOneClass.toInv.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (Group.toDivisionMonoid.{u1} α _inst_3)))) a) T))
Case conversion may be inaccurate. Consider using '#align submonoid.pointwise_smul_subset_iff Submonoid.pointwise_smul_subset_iffₓ'. -/
theorem pointwise_smul_subset_iff {a : α} {S T : Submonoid M} : a • S ≤ T ↔ S ≤ a⁻¹ • T :=
  set_smul_subset_iff
#align submonoid.pointwise_smul_subset_iff Submonoid.pointwise_smul_subset_iff

/- warning: submonoid.subset_pointwise_smul_iff -> Submonoid.subset_pointwise_smul_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] [_inst_3 : Group.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α M (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_1] {a : α} {S : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)} {T : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)}, Iff (LE.le.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Preorder.toLE.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (PartialOrder.toPreorder.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.partialOrder.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))))) S (SMul.smul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toHasSmul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) a T)) (LE.le.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Preorder.toLE.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (PartialOrder.toPreorder.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.partialOrder.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))))) (SMul.smul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toHasSmul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) a) S) T)
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] [_inst_3 : Group.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α M (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_1] {a : α} {S : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)} {T : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)}, Iff (LE.le.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Preorder.toLE.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (PartialOrder.toPreorder.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.instCompleteLatticeSubmonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)))))) S (HSMul.hSMul.{u1, u2, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (instHSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) a T)) (LE.le.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Preorder.toLE.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (PartialOrder.toPreorder.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.instCompleteLatticeSubmonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)))))) (HSMul.hSMul.{u1, u2, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (instHSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toSMul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) (Inv.inv.{u1} α (InvOneClass.toInv.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (Group.toDivisionMonoid.{u1} α _inst_3)))) a) S) T)
Case conversion may be inaccurate. Consider using '#align submonoid.subset_pointwise_smul_iff Submonoid.subset_pointwise_smul_iffₓ'. -/
theorem subset_pointwise_smul_iff {a : α} {S T : Submonoid M} : S ≤ a • T ↔ a⁻¹ • S ≤ T :=
  subset_set_smul_iff
#align submonoid.subset_pointwise_smul_iff Submonoid.subset_pointwise_smul_iff

end Group

section GroupWithZero

variable [GroupWithZero α] [MulDistribMulAction α M]

open Pointwise

/- warning: submonoid.smul_mem_pointwise_smul_iff₀ -> Submonoid.smul_mem_pointwise_smul_iff₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] [_inst_3 : GroupWithZero.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α M (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_1] {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)))))))) -> (forall (S : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (x : M), Iff (Membership.Mem.{u2, u2} M (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.hasMem.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) (SMul.smul.{u1, u2} α M (MulAction.toHasSmul.{u1, u2} α M (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (MulDistribMulAction.toMulAction.{u1, u2} α M (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_1 _inst_4)) a x) (SMul.smul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toHasSmul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) a S)) (Membership.Mem.{u2, u2} M (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.hasMem.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) x S))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] [_inst_3 : GroupWithZero.{u2} α] [_inst_4 : MulDistribMulAction.{u2, u1} α M (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_1] {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3))))) -> (forall (S : Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (x : M), Iff (Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) (HSMul.hSMul.{u2, u1, u1} α M M (instHSMul.{u2, u1} α M (MulAction.toSMul.{u2, u1} α M (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (MulDistribMulAction.toMulAction.{u2, u1} α M (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_1 _inst_4))) a x) (HSMul.hSMul.{u2, u1, u1} α (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (instHSMul.{u2, u1} α (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MulAction.toSMul.{u2, u1} α (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (Submonoid.pointwiseMulAction.{u2, u1} α M _inst_1 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) a S)) (Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) x S))
Case conversion may be inaccurate. Consider using '#align submonoid.smul_mem_pointwise_smul_iff₀ Submonoid.smul_mem_pointwise_smul_iff₀ₓ'. -/
@[simp]
theorem smul_mem_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) (S : Submonoid M) (x : M) :
    a • x ∈ a • S ↔ x ∈ S :=
  smul_mem_smul_set_iff₀ ha (S : Set M) x
#align submonoid.smul_mem_pointwise_smul_iff₀ Submonoid.smul_mem_pointwise_smul_iff₀

/- warning: submonoid.mem_pointwise_smul_iff_inv_smul_mem₀ -> Submonoid.mem_pointwise_smul_iff_inv_smul_mem₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] [_inst_3 : GroupWithZero.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α M (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_1] {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)))))))) -> (forall (S : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (x : M), Iff (Membership.Mem.{u2, u2} M (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.hasMem.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) x (SMul.smul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toHasSmul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) a S)) (Membership.Mem.{u2, u2} M (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.hasMem.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) (SMul.smul.{u1, u2} α M (MulAction.toHasSmul.{u1, u2} α M (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (MulDistribMulAction.toMulAction.{u1, u2} α M (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_1 _inst_4)) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α _inst_3)) a) x) S))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] [_inst_3 : GroupWithZero.{u2} α] [_inst_4 : MulDistribMulAction.{u2, u1} α M (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_1] {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3))))) -> (forall (S : Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (x : M), Iff (Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) x (HSMul.hSMul.{u2, u1, u1} α (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (instHSMul.{u2, u1} α (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MulAction.toSMul.{u2, u1} α (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (Submonoid.pointwiseMulAction.{u2, u1} α M _inst_1 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) a S)) (Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) (HSMul.hSMul.{u2, u1, u1} α M M (instHSMul.{u2, u1} α M (MulAction.toSMul.{u2, u1} α M (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (MulDistribMulAction.toMulAction.{u2, u1} α M (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_1 _inst_4))) (Inv.inv.{u2} α (GroupWithZero.toInv.{u2} α _inst_3) a) x) S))
Case conversion may be inaccurate. Consider using '#align submonoid.mem_pointwise_smul_iff_inv_smul_mem₀ Submonoid.mem_pointwise_smul_iff_inv_smul_mem₀ₓ'. -/
theorem mem_pointwise_smul_iff_inv_smul_mem₀ {a : α} (ha : a ≠ 0) (S : Submonoid M) (x : M) :
    x ∈ a • S ↔ a⁻¹ • x ∈ S :=
  mem_smul_set_iff_inv_smul_mem₀ ha (S : Set M) x
#align submonoid.mem_pointwise_smul_iff_inv_smul_mem₀ Submonoid.mem_pointwise_smul_iff_inv_smul_mem₀

/- warning: submonoid.mem_inv_pointwise_smul_iff₀ -> Submonoid.mem_inv_pointwise_smul_iff₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] [_inst_3 : GroupWithZero.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α M (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_1] {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)))))))) -> (forall (S : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (x : M), Iff (Membership.Mem.{u2, u2} M (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.hasMem.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) x (SMul.smul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toHasSmul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α _inst_3)) a) S)) (Membership.Mem.{u2, u2} M (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.hasMem.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) (SMul.smul.{u1, u2} α M (MulAction.toHasSmul.{u1, u2} α M (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (MulDistribMulAction.toMulAction.{u1, u2} α M (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_1 _inst_4)) a x) S))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] [_inst_3 : GroupWithZero.{u2} α] [_inst_4 : MulDistribMulAction.{u2, u1} α M (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_1] {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3))))) -> (forall (S : Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (x : M), Iff (Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) x (HSMul.hSMul.{u2, u1, u1} α (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (instHSMul.{u2, u1} α (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MulAction.toSMul.{u2, u1} α (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (Submonoid.pointwiseMulAction.{u2, u1} α M _inst_1 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) (Inv.inv.{u2} α (GroupWithZero.toInv.{u2} α _inst_3) a) S)) (Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) (HSMul.hSMul.{u2, u1, u1} α M M (instHSMul.{u2, u1} α M (MulAction.toSMul.{u2, u1} α M (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (MulDistribMulAction.toMulAction.{u2, u1} α M (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_1 _inst_4))) a x) S))
Case conversion may be inaccurate. Consider using '#align submonoid.mem_inv_pointwise_smul_iff₀ Submonoid.mem_inv_pointwise_smul_iff₀ₓ'. -/
theorem mem_inv_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) (S : Submonoid M) (x : M) :
    x ∈ a⁻¹ • S ↔ a • x ∈ S :=
  mem_inv_smul_set_iff₀ ha (S : Set M) x
#align submonoid.mem_inv_pointwise_smul_iff₀ Submonoid.mem_inv_pointwise_smul_iff₀

/- warning: submonoid.pointwise_smul_le_pointwise_smul_iff₀ -> Submonoid.pointwise_smul_le_pointwise_smul_iff₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] [_inst_3 : GroupWithZero.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α M (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_1] {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)))))))) -> (forall {S : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)} {T : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)}, Iff (LE.le.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Preorder.toLE.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (PartialOrder.toPreorder.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.partialOrder.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))))) (SMul.smul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toHasSmul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) a S) (SMul.smul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toHasSmul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) a T)) (LE.le.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Preorder.toLE.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (PartialOrder.toPreorder.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.partialOrder.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))))) S T))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] [_inst_3 : GroupWithZero.{u2} α] [_inst_4 : MulDistribMulAction.{u2, u1} α M (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_1] {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3))))) -> (forall {S : Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)} {T : Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)}, Iff (LE.le.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Preorder.toLE.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Submonoid.instCompleteLatticeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)))))) (HSMul.hSMul.{u2, u1, u1} α (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (instHSMul.{u2, u1} α (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MulAction.toSMul.{u2, u1} α (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (Submonoid.pointwiseMulAction.{u2, u1} α M _inst_1 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) a S) (HSMul.hSMul.{u2, u1, u1} α (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (instHSMul.{u2, u1} α (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MulAction.toSMul.{u2, u1} α (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (Submonoid.pointwiseMulAction.{u2, u1} α M _inst_1 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) a T)) (LE.le.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Preorder.toLE.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Submonoid.instCompleteLatticeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)))))) S T))
Case conversion may be inaccurate. Consider using '#align submonoid.pointwise_smul_le_pointwise_smul_iff₀ Submonoid.pointwise_smul_le_pointwise_smul_iff₀ₓ'. -/
@[simp]
theorem pointwise_smul_le_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) {S T : Submonoid M} :
    a • S ≤ a • T ↔ S ≤ T :=
  set_smul_subset_set_smul_iff₀ ha
#align submonoid.pointwise_smul_le_pointwise_smul_iff₀ Submonoid.pointwise_smul_le_pointwise_smul_iff₀

/- warning: submonoid.pointwise_smul_le_iff₀ -> Submonoid.pointwise_smul_le_iff₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] [_inst_3 : GroupWithZero.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α M (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_1] {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)))))))) -> (forall {S : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)} {T : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)}, Iff (LE.le.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Preorder.toLE.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (PartialOrder.toPreorder.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.partialOrder.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))))) (SMul.smul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toHasSmul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) a S) T) (LE.le.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Preorder.toLE.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (PartialOrder.toPreorder.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.partialOrder.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))))) S (SMul.smul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toHasSmul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α _inst_3)) a) T)))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] [_inst_3 : GroupWithZero.{u2} α] [_inst_4 : MulDistribMulAction.{u2, u1} α M (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_1] {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3))))) -> (forall {S : Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)} {T : Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)}, Iff (LE.le.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Preorder.toLE.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Submonoid.instCompleteLatticeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)))))) (HSMul.hSMul.{u2, u1, u1} α (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (instHSMul.{u2, u1} α (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MulAction.toSMul.{u2, u1} α (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (Submonoid.pointwiseMulAction.{u2, u1} α M _inst_1 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) a S) T) (LE.le.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Preorder.toLE.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Submonoid.instCompleteLatticeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)))))) S (HSMul.hSMul.{u2, u1, u1} α (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (instHSMul.{u2, u1} α (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MulAction.toSMul.{u2, u1} α (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (Submonoid.pointwiseMulAction.{u2, u1} α M _inst_1 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) (Inv.inv.{u2} α (GroupWithZero.toInv.{u2} α _inst_3) a) T)))
Case conversion may be inaccurate. Consider using '#align submonoid.pointwise_smul_le_iff₀ Submonoid.pointwise_smul_le_iff₀ₓ'. -/
theorem pointwise_smul_le_iff₀ {a : α} (ha : a ≠ 0) {S T : Submonoid M} : a • S ≤ T ↔ S ≤ a⁻¹ • T :=
  set_smul_subset_iff₀ ha
#align submonoid.pointwise_smul_le_iff₀ Submonoid.pointwise_smul_le_iff₀

/- warning: submonoid.le_pointwise_smul_iff₀ -> Submonoid.le_pointwise_smul_iff₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] [_inst_3 : GroupWithZero.{u1} α] [_inst_4 : MulDistribMulAction.{u1, u2} α M (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_1] {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)))))))) -> (forall {S : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)} {T : Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)}, Iff (LE.le.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Preorder.toLE.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (PartialOrder.toPreorder.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.partialOrder.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))))) S (SMul.smul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toHasSmul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) a T)) (LE.le.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (Preorder.toLE.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (PartialOrder.toPreorder.{u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.partialOrder.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))))) (SMul.smul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulAction.toHasSmul.{u1, u2} α (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (Submonoid.pointwiseMulAction.{u1, u2} α M _inst_1 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α _inst_3)) a) S) T))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] [_inst_3 : GroupWithZero.{u2} α] [_inst_4 : MulDistribMulAction.{u2, u1} α M (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_1] {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3))))) -> (forall {S : Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)} {T : Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)}, Iff (LE.le.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Preorder.toLE.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Submonoid.instCompleteLatticeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)))))) S (HSMul.hSMul.{u2, u1, u1} α (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (instHSMul.{u2, u1} α (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MulAction.toSMul.{u2, u1} α (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (Submonoid.pointwiseMulAction.{u2, u1} α M _inst_1 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) a T)) (LE.le.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Preorder.toLE.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Submonoid.instCompleteLatticeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)))))) (HSMul.hSMul.{u2, u1, u1} α (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (instHSMul.{u2, u1} α (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MulAction.toSMul.{u2, u1} α (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (Submonoid.pointwiseMulAction.{u2, u1} α M _inst_1 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) (Inv.inv.{u2} α (GroupWithZero.toInv.{u2} α _inst_3) a) S) T))
Case conversion may be inaccurate. Consider using '#align submonoid.le_pointwise_smul_iff₀ Submonoid.le_pointwise_smul_iff₀ₓ'. -/
theorem le_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) {S T : Submonoid M} : S ≤ a • T ↔ a⁻¹ • S ≤ T :=
  subset_set_smul_iff₀ ha
#align submonoid.le_pointwise_smul_iff₀ Submonoid.le_pointwise_smul_iff₀

end GroupWithZero

open Pointwise

/- warning: submonoid.mem_closure_inv -> Submonoid.mem_closure_inv is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_3 : Group.{u1} G] (S : Set.{u1} G) (x : G), Iff (Membership.Mem.{u1, u1} G (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) G (Submonoid.setLike.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) x (Submonoid.closure.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Inv.inv.{u1} (Set.{u1} G) (Set.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) S))) (Membership.Mem.{u1, u1} G (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) G (Submonoid.setLike.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) x) (Submonoid.closure.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) S))
but is expected to have type
  forall {G : Type.{u1}} [_inst_3 : Group.{u1} G] (S : Set.{u1} G) (x : G), Iff (Membership.mem.{u1, u1} G (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) G (Submonoid.instSetLikeSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) x (Submonoid.closure.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Inv.inv.{u1} (Set.{u1} G) (Set.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_3))))) S))) (Membership.mem.{u1, u1} G (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) G (Submonoid.instSetLikeSubmonoid.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_3)))) x) (Submonoid.closure.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) S))
Case conversion may be inaccurate. Consider using '#align submonoid.mem_closure_inv Submonoid.mem_closure_invₓ'. -/
@[to_additive]
theorem mem_closure_inv {G : Type _} [Group G] (S : Set G) (x : G) :
    x ∈ Submonoid.closure S⁻¹ ↔ x⁻¹ ∈ Submonoid.closure S := by rw [closure_inv, mem_inv]
#align submonoid.mem_closure_inv Submonoid.mem_closure_inv
#align add_submonoid.mem_closure_neg AddSubmonoid.mem_closure_neg

end Submonoid

namespace AddSubmonoid

section Monoid

variable [Monoid α] [DistribMulAction α A]

#print AddSubmonoid.pointwiseMulAction /-
/-- The action on an additive submonoid corresponding to applying the action to every element.

This is available as an instance in the `pointwise` locale. -/
protected def pointwiseMulAction : MulAction α (AddSubmonoid A)
    where
  smul a S := S.map (DistribMulAction.toAddMonoidEnd _ A a)
  one_smul S :=
    (congr_arg (fun f : AddMonoid.End A => S.map f) (MonoidHom.map_one _)).trans S.map_id
  mul_smul a₁ a₂ S :=
    (congr_arg (fun f : AddMonoid.End A => S.map f) (MonoidHom.map_mul _ _ _)).trans
      (S.map_map _ _).symm
#align add_submonoid.pointwise_mul_action AddSubmonoid.pointwiseMulAction
-/

scoped[Pointwise] attribute [instance] AddSubmonoid.pointwiseMulAction

open Pointwise

/- warning: add_submonoid.coe_pointwise_smul -> AddSubmonoid.coe_pointwise_smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : Monoid.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A _inst_3 _inst_2] (a : α) (S : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)), Eq.{succ u2} (Set.{u2} A) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (Set.{u2} A) (CoeTCₓ.coe.{succ u2, succ u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))))) (SMul.smul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toHasSmul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) _inst_3 (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 _inst_3 _inst_4)) a S)) (SMul.smul.{u1, u2} α (Set.{u2} A) (Set.smulSet.{u1, u2} α A (SMulZeroClass.toHasSmul.{u1, u2} α A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DistribSMul.toSmulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A _inst_2) (DistribMulAction.toDistribSMul.{u1, u2} α A _inst_3 _inst_2 _inst_4)))) a ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (Set.{u2} A) (CoeTCₓ.coe.{succ u2, succ u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))))) S))
but is expected to have type
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : Monoid.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A _inst_3 _inst_2] (a : α) (S : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)), Eq.{succ u2} (Set.{u2} A) (SetLike.coe.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.instSetLikeAddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (HSMul.hSMul.{u1, u2, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (instHSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) _inst_3 (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 _inst_3 _inst_4))) a S)) (HSMul.hSMul.{u1, u2, u2} α (Set.{u2} A) (Set.{u2} A) (instHSMul.{u1, u2} α (Set.{u2} A) (Set.smulSet.{u1, u2} α A (SMulZeroClass.toSMul.{u1, u2} α A (AddMonoid.toZero.{u2} A _inst_2) (DistribSMul.toSMulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A _inst_2) (DistribMulAction.toDistribSMul.{u1, u2} α A _inst_3 _inst_2 _inst_4))))) a (SetLike.coe.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.instSetLikeAddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) S))
Case conversion may be inaccurate. Consider using '#align add_submonoid.coe_pointwise_smul AddSubmonoid.coe_pointwise_smulₓ'. -/
@[simp]
theorem coe_pointwise_smul (a : α) (S : AddSubmonoid A) : ↑(a • S) = a • (S : Set A) :=
  rfl
#align add_submonoid.coe_pointwise_smul AddSubmonoid.coe_pointwise_smul

/- warning: add_submonoid.smul_mem_pointwise_smul -> AddSubmonoid.smul_mem_pointwise_smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : Monoid.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A _inst_3 _inst_2] (m : A) (a : α) (S : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)), (Membership.Mem.{u2, u2} A (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.hasMem.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))) m S) -> (Membership.Mem.{u2, u2} A (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.hasMem.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))) (SMul.smul.{u1, u2} α A (SMulZeroClass.toHasSmul.{u1, u2} α A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DistribSMul.toSmulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A _inst_2) (DistribMulAction.toDistribSMul.{u1, u2} α A _inst_3 _inst_2 _inst_4))) a m) (SMul.smul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toHasSmul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) _inst_3 (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 _inst_3 _inst_4)) a S))
but is expected to have type
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : Monoid.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A _inst_3 _inst_2] (m : A) (a : α) (S : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)), (Membership.mem.{u2, u2} A (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.instSetLikeAddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))) m S) -> (Membership.mem.{u2, u2} A (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.instSetLikeAddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))) (HSMul.hSMul.{u1, u2, u2} α A A (instHSMul.{u1, u2} α A (SMulZeroClass.toSMul.{u1, u2} α A (AddMonoid.toZero.{u2} A _inst_2) (DistribSMul.toSMulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A _inst_2) (DistribMulAction.toDistribSMul.{u1, u2} α A _inst_3 _inst_2 _inst_4)))) a m) (HSMul.hSMul.{u1, u2, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (instHSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) _inst_3 (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 _inst_3 _inst_4))) a S))
Case conversion may be inaccurate. Consider using '#align add_submonoid.smul_mem_pointwise_smul AddSubmonoid.smul_mem_pointwise_smulₓ'. -/
theorem smul_mem_pointwise_smul (m : A) (a : α) (S : AddSubmonoid A) : m ∈ S → a • m ∈ a • S :=
  (Set.smul_mem_smul_set : _ → _ ∈ a • (S : Set A))
#align add_submonoid.smul_mem_pointwise_smul AddSubmonoid.smul_mem_pointwise_smul

/- warning: add_submonoid.mem_smul_pointwise_iff_exists -> AddSubmonoid.mem_smul_pointwise_iff_exists is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : Monoid.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A _inst_3 _inst_2] (m : A) (a : α) (S : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)), Iff (Membership.Mem.{u2, u2} A (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.hasMem.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))) m (SMul.smul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toHasSmul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) _inst_3 (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 _inst_3 _inst_4)) a S)) (Exists.{succ u2} A (fun (s : A) => And (Membership.Mem.{u2, u2} A (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.hasMem.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))) s S) (Eq.{succ u2} A (SMul.smul.{u1, u2} α A (SMulZeroClass.toHasSmul.{u1, u2} α A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DistribSMul.toSmulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A _inst_2) (DistribMulAction.toDistribSMul.{u1, u2} α A _inst_3 _inst_2 _inst_4))) a s) m)))
but is expected to have type
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : Monoid.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A _inst_3 _inst_2] (m : A) (a : α) (S : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)), Iff (Membership.mem.{u2, u2} A (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.instSetLikeAddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))) m (HSMul.hSMul.{u1, u2, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (instHSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) _inst_3 (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 _inst_3 _inst_4))) a S)) (Exists.{succ u2} A (fun (s : A) => And (Membership.mem.{u2, u2} A (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.instSetLikeAddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))) s S) (Eq.{succ u2} A (HSMul.hSMul.{u1, u2, u2} α A A (instHSMul.{u1, u2} α A (SMulZeroClass.toSMul.{u1, u2} α A (AddMonoid.toZero.{u2} A _inst_2) (DistribSMul.toSMulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A _inst_2) (DistribMulAction.toDistribSMul.{u1, u2} α A _inst_3 _inst_2 _inst_4)))) a s) m)))
Case conversion may be inaccurate. Consider using '#align add_submonoid.mem_smul_pointwise_iff_exists AddSubmonoid.mem_smul_pointwise_iff_existsₓ'. -/
theorem mem_smul_pointwise_iff_exists (m : A) (a : α) (S : AddSubmonoid A) :
    m ∈ a • S ↔ ∃ s : A, s ∈ S ∧ a • s = m :=
  (Set.mem_smul_set : m ∈ a • (S : Set A) ↔ _)
#align add_submonoid.mem_smul_pointwise_iff_exists AddSubmonoid.mem_smul_pointwise_iff_exists

/- warning: add_submonoid.smul_bot -> AddSubmonoid.smul_bot is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : Monoid.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A _inst_3 _inst_2] (a : α), Eq.{succ u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SMul.smul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toHasSmul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) _inst_3 (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 _inst_3 _inst_4)) a (Bot.bot.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.hasBot.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)))) (Bot.bot.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.hasBot.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)))
but is expected to have type
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : Monoid.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A _inst_3 _inst_2] (a : α), Eq.{succ u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (HSMul.hSMul.{u1, u2, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (instHSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) _inst_3 (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 _inst_3 _inst_4))) a (Bot.bot.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.instBotAddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)))) (Bot.bot.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.instBotAddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)))
Case conversion may be inaccurate. Consider using '#align add_submonoid.smul_bot AddSubmonoid.smul_botₓ'. -/
@[simp]
theorem smul_bot (a : α) : a • (⊥ : AddSubmonoid A) = ⊥ :=
  map_bot _
#align add_submonoid.smul_bot AddSubmonoid.smul_bot

/- warning: add_submonoid.smul_sup -> AddSubmonoid.smul_sup is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : Monoid.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A _inst_3 _inst_2] (a : α) (S : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (T : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)), Eq.{succ u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SMul.smul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toHasSmul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) _inst_3 (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 _inst_3 _inst_4)) a (HasSup.sup.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SemilatticeSup.toHasSup.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (Lattice.toSemilatticeSup.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (ConditionallyCompleteLattice.toLattice.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (CompleteLattice.toConditionallyCompleteLattice.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.completeLattice.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)))))) S T)) (HasSup.sup.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SemilatticeSup.toHasSup.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (Lattice.toSemilatticeSup.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (ConditionallyCompleteLattice.toLattice.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (CompleteLattice.toConditionallyCompleteLattice.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.completeLattice.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)))))) (SMul.smul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toHasSmul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) _inst_3 (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 _inst_3 _inst_4)) a S) (SMul.smul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toHasSmul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) _inst_3 (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 _inst_3 _inst_4)) a T))
but is expected to have type
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : Monoid.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A _inst_3 _inst_2] (a : α) (S : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (T : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)), Eq.{succ u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (HSMul.hSMul.{u1, u2, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (instHSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) _inst_3 (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 _inst_3 _inst_4))) a (HasSup.sup.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SemilatticeSup.toHasSup.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (Lattice.toSemilatticeSup.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (ConditionallyCompleteLattice.toLattice.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (CompleteLattice.toConditionallyCompleteLattice.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)))))) S T)) (HasSup.sup.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SemilatticeSup.toHasSup.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (Lattice.toSemilatticeSup.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (ConditionallyCompleteLattice.toLattice.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (CompleteLattice.toConditionallyCompleteLattice.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)))))) (HSMul.hSMul.{u1, u2, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (instHSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) _inst_3 (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 _inst_3 _inst_4))) a S) (HSMul.hSMul.{u1, u2, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (instHSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) _inst_3 (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 _inst_3 _inst_4))) a T))
Case conversion may be inaccurate. Consider using '#align add_submonoid.smul_sup AddSubmonoid.smul_supₓ'. -/
theorem smul_sup (a : α) (S T : AddSubmonoid A) : a • (S ⊔ T) = a • S ⊔ a • T :=
  map_sup _ _ _
#align add_submonoid.smul_sup AddSubmonoid.smul_sup

/- warning: add_submonoid.smul_closure -> AddSubmonoid.smul_closure is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : Monoid.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A _inst_3 _inst_2] (a : α) (s : Set.{u2} A), Eq.{succ u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SMul.smul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toHasSmul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) _inst_3 (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 _inst_3 _inst_4)) a (AddSubmonoid.closure.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2) s)) (AddSubmonoid.closure.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2) (SMul.smul.{u1, u2} α (Set.{u2} A) (Set.smulSet.{u1, u2} α A (SMulZeroClass.toHasSmul.{u1, u2} α A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DistribSMul.toSmulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A _inst_2) (DistribMulAction.toDistribSMul.{u1, u2} α A _inst_3 _inst_2 _inst_4)))) a s))
but is expected to have type
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : Monoid.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A _inst_3 _inst_2] (a : α) (s : Set.{u2} A), Eq.{succ u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (HSMul.hSMul.{u1, u2, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (instHSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) _inst_3 (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 _inst_3 _inst_4))) a (AddSubmonoid.closure.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2) s)) (AddSubmonoid.closure.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2) (HSMul.hSMul.{u1, u2, u2} α (Set.{u2} A) (Set.{u2} A) (instHSMul.{u1, u2} α (Set.{u2} A) (Set.smulSet.{u1, u2} α A (SMulZeroClass.toSMul.{u1, u2} α A (AddMonoid.toZero.{u2} A _inst_2) (DistribSMul.toSMulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A _inst_2) (DistribMulAction.toDistribSMul.{u1, u2} α A _inst_3 _inst_2 _inst_4))))) a s))
Case conversion may be inaccurate. Consider using '#align add_submonoid.smul_closure AddSubmonoid.smul_closureₓ'. -/
@[simp]
theorem smul_closure (a : α) (s : Set A) : a • closure s = closure (a • s) :=
  AddMonoidHom.map_mclosure _ _
#align add_submonoid.smul_closure AddSubmonoid.smul_closure

/- warning: add_submonoid.pointwise_central_scalar -> AddSubmonoid.pointwise_isCentralScalar is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : Monoid.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A _inst_3 _inst_2] [_inst_5 : DistribMulAction.{u1, u2} (MulOpposite.{u1} α) A (MulOpposite.monoid.{u1} α _inst_3) _inst_2] [_inst_6 : IsCentralScalar.{u1, u2} α A (SMulZeroClass.toHasSmul.{u1, u2} α A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DistribSMul.toSmulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A _inst_2) (DistribMulAction.toDistribSMul.{u1, u2} α A _inst_3 _inst_2 _inst_4))) (SMulZeroClass.toHasSmul.{u1, u2} (MulOpposite.{u1} α) A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DistribSMul.toSmulZeroClass.{u1, u2} (MulOpposite.{u1} α) A (AddMonoid.toAddZeroClass.{u2} A _inst_2) (DistribMulAction.toDistribSMul.{u1, u2} (MulOpposite.{u1} α) A (MulOpposite.monoid.{u1} α _inst_3) _inst_2 _inst_5)))], IsCentralScalar.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toHasSmul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) _inst_3 (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 _inst_3 _inst_4)) (MulAction.toHasSmul.{u1, u2} (MulOpposite.{u1} α) (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulOpposite.monoid.{u1} α _inst_3) (AddSubmonoid.pointwiseMulAction.{u1, u2} (MulOpposite.{u1} α) A _inst_2 (MulOpposite.monoid.{u1} α _inst_3) _inst_5))
but is expected to have type
  forall {α : Type.{u2}} {A : Type.{u1}} [_inst_2 : AddMonoid.{u1} A] [_inst_3 : Monoid.{u2} α] [_inst_4 : DistribMulAction.{u2, u1} α A _inst_3 _inst_2] [_inst_5 : DistribMulAction.{u2, u1} (MulOpposite.{u2} α) A (MulOpposite.instMonoidMulOpposite.{u2} α _inst_3) _inst_2] [_inst_6 : IsCentralScalar.{u2, u1} α A (SMulZeroClass.toSMul.{u2, u1} α A (AddMonoid.toZero.{u1} A _inst_2) (DistribSMul.toSMulZeroClass.{u2, u1} α A (AddMonoid.toAddZeroClass.{u1} A _inst_2) (DistribMulAction.toDistribSMul.{u2, u1} α A _inst_3 _inst_2 _inst_4))) (SMulZeroClass.toSMul.{u2, u1} (MulOpposite.{u2} α) A (AddMonoid.toZero.{u1} A _inst_2) (DistribSMul.toSMulZeroClass.{u2, u1} (MulOpposite.{u2} α) A (AddMonoid.toAddZeroClass.{u1} A _inst_2) (DistribMulAction.toDistribSMul.{u2, u1} (MulOpposite.{u2} α) A (MulOpposite.instMonoidMulOpposite.{u2} α _inst_3) _inst_2 _inst_5)))], IsCentralScalar.{u2, u1} α (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (MulAction.toSMul.{u2, u1} α (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) _inst_3 (AddSubmonoid.pointwiseMulAction.{u2, u1} α A _inst_2 _inst_3 _inst_4)) (MulAction.toSMul.{u2, u1} (MulOpposite.{u2} α) (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (MulOpposite.instMonoidMulOpposite.{u2} α _inst_3) (AddSubmonoid.pointwiseMulAction.{u2, u1} (MulOpposite.{u2} α) A _inst_2 (MulOpposite.instMonoidMulOpposite.{u2} α _inst_3) _inst_5))
Case conversion may be inaccurate. Consider using '#align add_submonoid.pointwise_central_scalar AddSubmonoid.pointwise_isCentralScalarₓ'. -/
instance pointwise_isCentralScalar [DistribMulAction αᵐᵒᵖ A] [IsCentralScalar α A] :
    IsCentralScalar α (AddSubmonoid A) :=
  ⟨fun a S =>
    (congr_arg fun f : AddMonoid.End A => S.map f) <| AddMonoidHom.ext <| op_smul_eq_smul _⟩
#align add_submonoid.pointwise_central_scalar AddSubmonoid.pointwise_isCentralScalar

end Monoid

section Group

variable [Group α] [DistribMulAction α A]

open Pointwise

/- warning: add_submonoid.smul_mem_pointwise_smul_iff -> AddSubmonoid.smul_mem_pointwise_smul_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : Group.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_2] {a : α} {S : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)} {x : A}, Iff (Membership.Mem.{u2, u2} A (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.hasMem.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))) (SMul.smul.{u1, u2} α A (SMulZeroClass.toHasSmul.{u1, u2} α A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DistribSMul.toSmulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A _inst_2) (DistribMulAction.toDistribSMul.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_2 _inst_4))) a x) (SMul.smul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toHasSmul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) a S)) (Membership.Mem.{u2, u2} A (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.hasMem.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))) x S)
but is expected to have type
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : Group.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_2] {a : α} {S : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)} {x : A}, Iff (Membership.mem.{u2, u2} A (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.instSetLikeAddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))) (HSMul.hSMul.{u1, u2, u2} α A A (instHSMul.{u1, u2} α A (SMulZeroClass.toSMul.{u1, u2} α A (AddMonoid.toZero.{u2} A _inst_2) (DistribSMul.toSMulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A _inst_2) (DistribMulAction.toDistribSMul.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_2 _inst_4)))) a x) (HSMul.hSMul.{u1, u2, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (instHSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) a S)) (Membership.mem.{u2, u2} A (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.instSetLikeAddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))) x S)
Case conversion may be inaccurate. Consider using '#align add_submonoid.smul_mem_pointwise_smul_iff AddSubmonoid.smul_mem_pointwise_smul_iffₓ'. -/
@[simp]
theorem smul_mem_pointwise_smul_iff {a : α} {S : AddSubmonoid A} {x : A} : a • x ∈ a • S ↔ x ∈ S :=
  smul_mem_smul_set_iff
#align add_submonoid.smul_mem_pointwise_smul_iff AddSubmonoid.smul_mem_pointwise_smul_iff

/- warning: add_submonoid.mem_pointwise_smul_iff_inv_smul_mem -> AddSubmonoid.mem_pointwise_smul_iff_inv_smul_mem is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : Group.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_2] {a : α} {S : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)} {x : A}, Iff (Membership.Mem.{u2, u2} A (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.hasMem.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))) x (SMul.smul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toHasSmul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) a S)) (Membership.Mem.{u2, u2} A (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.hasMem.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))) (SMul.smul.{u1, u2} α A (SMulZeroClass.toHasSmul.{u1, u2} α A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DistribSMul.toSmulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A _inst_2) (DistribMulAction.toDistribSMul.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_2 _inst_4))) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) a) x) S)
but is expected to have type
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : Group.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_2] {a : α} {S : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)} {x : A}, Iff (Membership.mem.{u2, u2} A (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.instSetLikeAddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))) x (HSMul.hSMul.{u1, u2, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (instHSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) a S)) (Membership.mem.{u2, u2} A (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.instSetLikeAddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))) (HSMul.hSMul.{u1, u2, u2} α A A (instHSMul.{u1, u2} α A (SMulZeroClass.toSMul.{u1, u2} α A (AddMonoid.toZero.{u2} A _inst_2) (DistribSMul.toSMulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A _inst_2) (DistribMulAction.toDistribSMul.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_2 _inst_4)))) (Inv.inv.{u1} α (InvOneClass.toInv.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (Group.toDivisionMonoid.{u1} α _inst_3)))) a) x) S)
Case conversion may be inaccurate. Consider using '#align add_submonoid.mem_pointwise_smul_iff_inv_smul_mem AddSubmonoid.mem_pointwise_smul_iff_inv_smul_memₓ'. -/
theorem mem_pointwise_smul_iff_inv_smul_mem {a : α} {S : AddSubmonoid A} {x : A} :
    x ∈ a • S ↔ a⁻¹ • x ∈ S :=
  mem_smul_set_iff_inv_smul_mem
#align add_submonoid.mem_pointwise_smul_iff_inv_smul_mem AddSubmonoid.mem_pointwise_smul_iff_inv_smul_mem

/- warning: add_submonoid.mem_inv_pointwise_smul_iff -> AddSubmonoid.mem_inv_pointwise_smul_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : Group.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_2] {a : α} {S : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)} {x : A}, Iff (Membership.Mem.{u2, u2} A (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.hasMem.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))) x (SMul.smul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toHasSmul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) a) S)) (Membership.Mem.{u2, u2} A (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.hasMem.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))) (SMul.smul.{u1, u2} α A (SMulZeroClass.toHasSmul.{u1, u2} α A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DistribSMul.toSmulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A _inst_2) (DistribMulAction.toDistribSMul.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_2 _inst_4))) a x) S)
but is expected to have type
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : Group.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_2] {a : α} {S : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)} {x : A}, Iff (Membership.mem.{u2, u2} A (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.instSetLikeAddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))) x (HSMul.hSMul.{u1, u2, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (instHSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) (Inv.inv.{u1} α (InvOneClass.toInv.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (Group.toDivisionMonoid.{u1} α _inst_3)))) a) S)) (Membership.mem.{u2, u2} A (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.instSetLikeAddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))) (HSMul.hSMul.{u1, u2, u2} α A A (instHSMul.{u1, u2} α A (SMulZeroClass.toSMul.{u1, u2} α A (AddMonoid.toZero.{u2} A _inst_2) (DistribSMul.toSMulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A _inst_2) (DistribMulAction.toDistribSMul.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_2 _inst_4)))) a x) S)
Case conversion may be inaccurate. Consider using '#align add_submonoid.mem_inv_pointwise_smul_iff AddSubmonoid.mem_inv_pointwise_smul_iffₓ'. -/
theorem mem_inv_pointwise_smul_iff {a : α} {S : AddSubmonoid A} {x : A} : x ∈ a⁻¹ • S ↔ a • x ∈ S :=
  mem_inv_smul_set_iff
#align add_submonoid.mem_inv_pointwise_smul_iff AddSubmonoid.mem_inv_pointwise_smul_iff

/- warning: add_submonoid.pointwise_smul_le_pointwise_smul_iff -> AddSubmonoid.pointwise_smul_le_pointwise_smul_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : Group.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_2] {a : α} {S : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)} {T : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)}, Iff (LE.le.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (Preorder.toLE.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (PartialOrder.toPreorder.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.partialOrder.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))))) (SMul.smul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toHasSmul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) a S) (SMul.smul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toHasSmul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) a T)) (LE.le.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (Preorder.toLE.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (PartialOrder.toPreorder.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.partialOrder.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))))) S T)
but is expected to have type
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : Group.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_2] {a : α} {S : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)} {T : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)}, Iff (LE.le.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (Preorder.toLE.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (PartialOrder.toPreorder.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (CompleteSemilatticeInf.toPartialOrder.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)))))) (HSMul.hSMul.{u1, u2, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (instHSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) a S) (HSMul.hSMul.{u1, u2, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (instHSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) a T)) (LE.le.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (Preorder.toLE.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (PartialOrder.toPreorder.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (CompleteSemilatticeInf.toPartialOrder.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)))))) S T)
Case conversion may be inaccurate. Consider using '#align add_submonoid.pointwise_smul_le_pointwise_smul_iff AddSubmonoid.pointwise_smul_le_pointwise_smul_iffₓ'. -/
@[simp]
theorem pointwise_smul_le_pointwise_smul_iff {a : α} {S T : AddSubmonoid A} :
    a • S ≤ a • T ↔ S ≤ T :=
  set_smul_subset_set_smul_iff
#align add_submonoid.pointwise_smul_le_pointwise_smul_iff AddSubmonoid.pointwise_smul_le_pointwise_smul_iff

/- warning: add_submonoid.pointwise_smul_le_iff -> AddSubmonoid.pointwise_smul_le_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : Group.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_2] {a : α} {S : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)} {T : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)}, Iff (LE.le.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (Preorder.toLE.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (PartialOrder.toPreorder.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.partialOrder.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))))) (SMul.smul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toHasSmul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) a S) T) (LE.le.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (Preorder.toLE.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (PartialOrder.toPreorder.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.partialOrder.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))))) S (SMul.smul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toHasSmul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) a) T))
but is expected to have type
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : Group.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_2] {a : α} {S : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)} {T : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)}, Iff (LE.le.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (Preorder.toLE.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (PartialOrder.toPreorder.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (CompleteSemilatticeInf.toPartialOrder.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)))))) (HSMul.hSMul.{u1, u2, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (instHSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) a S) T) (LE.le.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (Preorder.toLE.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (PartialOrder.toPreorder.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (CompleteSemilatticeInf.toPartialOrder.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)))))) S (HSMul.hSMul.{u1, u2, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (instHSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) (Inv.inv.{u1} α (InvOneClass.toInv.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (Group.toDivisionMonoid.{u1} α _inst_3)))) a) T))
Case conversion may be inaccurate. Consider using '#align add_submonoid.pointwise_smul_le_iff AddSubmonoid.pointwise_smul_le_iffₓ'. -/
theorem pointwise_smul_le_iff {a : α} {S T : AddSubmonoid A} : a • S ≤ T ↔ S ≤ a⁻¹ • T :=
  set_smul_subset_iff
#align add_submonoid.pointwise_smul_le_iff AddSubmonoid.pointwise_smul_le_iff

/- warning: add_submonoid.le_pointwise_smul_iff -> AddSubmonoid.le_pointwise_smul_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : Group.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_2] {a : α} {S : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)} {T : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)}, Iff (LE.le.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (Preorder.toLE.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (PartialOrder.toPreorder.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.partialOrder.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))))) S (SMul.smul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toHasSmul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) a T)) (LE.le.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (Preorder.toLE.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (PartialOrder.toPreorder.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.partialOrder.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))))) (SMul.smul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toHasSmul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4)) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) a) S) T)
but is expected to have type
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : Group.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_2] {a : α} {S : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)} {T : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)}, Iff (LE.le.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (Preorder.toLE.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (PartialOrder.toPreorder.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (CompleteSemilatticeInf.toPartialOrder.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)))))) S (HSMul.hSMul.{u1, u2, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (instHSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) a T)) (LE.le.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (Preorder.toLE.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (PartialOrder.toPreorder.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (CompleteSemilatticeInf.toPartialOrder.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)))))) (HSMul.hSMul.{u1, u2, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (instHSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toSMul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α _inst_3)) _inst_4))) (Inv.inv.{u1} α (InvOneClass.toInv.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (Group.toDivisionMonoid.{u1} α _inst_3)))) a) S) T)
Case conversion may be inaccurate. Consider using '#align add_submonoid.le_pointwise_smul_iff AddSubmonoid.le_pointwise_smul_iffₓ'. -/
theorem le_pointwise_smul_iff {a : α} {S T : AddSubmonoid A} : S ≤ a • T ↔ a⁻¹ • S ≤ T :=
  subset_set_smul_iff
#align add_submonoid.le_pointwise_smul_iff AddSubmonoid.le_pointwise_smul_iff

end Group

section GroupWithZero

variable [GroupWithZero α] [DistribMulAction α A]

open Pointwise

/- warning: add_submonoid.smul_mem_pointwise_smul_iff₀ -> AddSubmonoid.smul_mem_pointwise_smul_iff₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : GroupWithZero.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_2] {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)))))))) -> (forall (S : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (x : A), Iff (Membership.Mem.{u2, u2} A (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.hasMem.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))) (SMul.smul.{u1, u2} α A (SMulZeroClass.toHasSmul.{u1, u2} α A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DistribSMul.toSmulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A _inst_2) (DistribMulAction.toDistribSMul.{u1, u2} α A (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_2 _inst_4))) a x) (SMul.smul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toHasSmul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) a S)) (Membership.Mem.{u2, u2} A (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.hasMem.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))) x S))
but is expected to have type
  forall {α : Type.{u2}} {A : Type.{u1}} [_inst_2 : AddMonoid.{u1} A] [_inst_3 : GroupWithZero.{u2} α] [_inst_4 : DistribMulAction.{u2, u1} α A (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_2] {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3))))) -> (forall (S : AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (x : A), Iff (Membership.mem.{u1, u1} A (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (SetLike.instMembership.{u1, u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) A (AddSubmonoid.instSetLikeAddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) (HSMul.hSMul.{u2, u1, u1} α A A (instHSMul.{u2, u1} α A (SMulZeroClass.toSMul.{u2, u1} α A (AddMonoid.toZero.{u1} A _inst_2) (DistribSMul.toSMulZeroClass.{u2, u1} α A (AddMonoid.toAddZeroClass.{u1} A _inst_2) (DistribMulAction.toDistribSMul.{u2, u1} α A (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_2 _inst_4)))) a x) (HSMul.hSMul.{u2, u1, u1} α (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (instHSMul.{u2, u1} α (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (MulAction.toSMul.{u2, u1} α (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u2, u1} α A _inst_2 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) a S)) (Membership.mem.{u1, u1} A (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (SetLike.instMembership.{u1, u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) A (AddSubmonoid.instSetLikeAddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) x S))
Case conversion may be inaccurate. Consider using '#align add_submonoid.smul_mem_pointwise_smul_iff₀ AddSubmonoid.smul_mem_pointwise_smul_iff₀ₓ'. -/
@[simp]
theorem smul_mem_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) (S : AddSubmonoid A) (x : A) :
    a • x ∈ a • S ↔ x ∈ S :=
  smul_mem_smul_set_iff₀ ha (S : Set A) x
#align add_submonoid.smul_mem_pointwise_smul_iff₀ AddSubmonoid.smul_mem_pointwise_smul_iff₀

/- warning: add_submonoid.mem_pointwise_smul_iff_inv_smul_mem₀ -> AddSubmonoid.mem_pointwise_smul_iff_inv_smul_mem₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : GroupWithZero.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_2] {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)))))))) -> (forall (S : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (x : A), Iff (Membership.Mem.{u2, u2} A (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.hasMem.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))) x (SMul.smul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toHasSmul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) a S)) (Membership.Mem.{u2, u2} A (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.hasMem.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))) (SMul.smul.{u1, u2} α A (SMulZeroClass.toHasSmul.{u1, u2} α A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DistribSMul.toSmulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A _inst_2) (DistribMulAction.toDistribSMul.{u1, u2} α A (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_2 _inst_4))) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α _inst_3)) a) x) S))
but is expected to have type
  forall {α : Type.{u2}} {A : Type.{u1}} [_inst_2 : AddMonoid.{u1} A] [_inst_3 : GroupWithZero.{u2} α] [_inst_4 : DistribMulAction.{u2, u1} α A (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_2] {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3))))) -> (forall (S : AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (x : A), Iff (Membership.mem.{u1, u1} A (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (SetLike.instMembership.{u1, u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) A (AddSubmonoid.instSetLikeAddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) x (HSMul.hSMul.{u2, u1, u1} α (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (instHSMul.{u2, u1} α (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (MulAction.toSMul.{u2, u1} α (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u2, u1} α A _inst_2 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) a S)) (Membership.mem.{u1, u1} A (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (SetLike.instMembership.{u1, u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) A (AddSubmonoid.instSetLikeAddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) (HSMul.hSMul.{u2, u1, u1} α A A (instHSMul.{u2, u1} α A (SMulZeroClass.toSMul.{u2, u1} α A (AddMonoid.toZero.{u1} A _inst_2) (DistribSMul.toSMulZeroClass.{u2, u1} α A (AddMonoid.toAddZeroClass.{u1} A _inst_2) (DistribMulAction.toDistribSMul.{u2, u1} α A (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_2 _inst_4)))) (Inv.inv.{u2} α (GroupWithZero.toInv.{u2} α _inst_3) a) x) S))
Case conversion may be inaccurate. Consider using '#align add_submonoid.mem_pointwise_smul_iff_inv_smul_mem₀ AddSubmonoid.mem_pointwise_smul_iff_inv_smul_mem₀ₓ'. -/
theorem mem_pointwise_smul_iff_inv_smul_mem₀ {a : α} (ha : a ≠ 0) (S : AddSubmonoid A) (x : A) :
    x ∈ a • S ↔ a⁻¹ • x ∈ S :=
  mem_smul_set_iff_inv_smul_mem₀ ha (S : Set A) x
#align add_submonoid.mem_pointwise_smul_iff_inv_smul_mem₀ AddSubmonoid.mem_pointwise_smul_iff_inv_smul_mem₀

/- warning: add_submonoid.mem_inv_pointwise_smul_iff₀ -> AddSubmonoid.mem_inv_pointwise_smul_iff₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : GroupWithZero.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_2] {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)))))))) -> (forall (S : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (x : A), Iff (Membership.Mem.{u2, u2} A (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.hasMem.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))) x (SMul.smul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toHasSmul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α _inst_3)) a) S)) (Membership.Mem.{u2, u2} A (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.hasMem.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))) (SMul.smul.{u1, u2} α A (SMulZeroClass.toHasSmul.{u1, u2} α A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (DistribSMul.toSmulZeroClass.{u1, u2} α A (AddMonoid.toAddZeroClass.{u2} A _inst_2) (DistribMulAction.toDistribSMul.{u1, u2} α A (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_2 _inst_4))) a x) S))
but is expected to have type
  forall {α : Type.{u2}} {A : Type.{u1}} [_inst_2 : AddMonoid.{u1} A] [_inst_3 : GroupWithZero.{u2} α] [_inst_4 : DistribMulAction.{u2, u1} α A (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_2] {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3))))) -> (forall (S : AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (x : A), Iff (Membership.mem.{u1, u1} A (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (SetLike.instMembership.{u1, u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) A (AddSubmonoid.instSetLikeAddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) x (HSMul.hSMul.{u2, u1, u1} α (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (instHSMul.{u2, u1} α (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (MulAction.toSMul.{u2, u1} α (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u2, u1} α A _inst_2 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) (Inv.inv.{u2} α (GroupWithZero.toInv.{u2} α _inst_3) a) S)) (Membership.mem.{u1, u1} A (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (SetLike.instMembership.{u1, u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) A (AddSubmonoid.instSetLikeAddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) (HSMul.hSMul.{u2, u1, u1} α A A (instHSMul.{u2, u1} α A (SMulZeroClass.toSMul.{u2, u1} α A (AddMonoid.toZero.{u1} A _inst_2) (DistribSMul.toSMulZeroClass.{u2, u1} α A (AddMonoid.toAddZeroClass.{u1} A _inst_2) (DistribMulAction.toDistribSMul.{u2, u1} α A (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_2 _inst_4)))) a x) S))
Case conversion may be inaccurate. Consider using '#align add_submonoid.mem_inv_pointwise_smul_iff₀ AddSubmonoid.mem_inv_pointwise_smul_iff₀ₓ'. -/
theorem mem_inv_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) (S : AddSubmonoid A) (x : A) :
    x ∈ a⁻¹ • S ↔ a • x ∈ S :=
  mem_inv_smul_set_iff₀ ha (S : Set A) x
#align add_submonoid.mem_inv_pointwise_smul_iff₀ AddSubmonoid.mem_inv_pointwise_smul_iff₀

/- warning: add_submonoid.pointwise_smul_le_pointwise_smul_iff₀ -> AddSubmonoid.pointwise_smul_le_pointwise_smul_iff₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : GroupWithZero.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_2] {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)))))))) -> (forall {S : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)} {T : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)}, Iff (LE.le.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (Preorder.toLE.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (PartialOrder.toPreorder.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.partialOrder.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))))) (SMul.smul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toHasSmul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) a S) (SMul.smul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toHasSmul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) a T)) (LE.le.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (Preorder.toLE.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (PartialOrder.toPreorder.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.partialOrder.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))))) S T))
but is expected to have type
  forall {α : Type.{u2}} {A : Type.{u1}} [_inst_2 : AddMonoid.{u1} A] [_inst_3 : GroupWithZero.{u2} α] [_inst_4 : DistribMulAction.{u2, u1} α A (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_2] {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3))))) -> (forall {S : AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)} {T : AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)}, Iff (LE.le.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (Preorder.toLE.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)))))) (HSMul.hSMul.{u2, u1, u1} α (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (instHSMul.{u2, u1} α (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (MulAction.toSMul.{u2, u1} α (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u2, u1} α A _inst_2 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) a S) (HSMul.hSMul.{u2, u1, u1} α (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (instHSMul.{u2, u1} α (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (MulAction.toSMul.{u2, u1} α (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u2, u1} α A _inst_2 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) a T)) (LE.le.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (Preorder.toLE.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)))))) S T))
Case conversion may be inaccurate. Consider using '#align add_submonoid.pointwise_smul_le_pointwise_smul_iff₀ AddSubmonoid.pointwise_smul_le_pointwise_smul_iff₀ₓ'. -/
@[simp]
theorem pointwise_smul_le_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) {S T : AddSubmonoid A} :
    a • S ≤ a • T ↔ S ≤ T :=
  set_smul_subset_set_smul_iff₀ ha
#align add_submonoid.pointwise_smul_le_pointwise_smul_iff₀ AddSubmonoid.pointwise_smul_le_pointwise_smul_iff₀

/- warning: add_submonoid.pointwise_smul_le_iff₀ -> AddSubmonoid.pointwise_smul_le_iff₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : GroupWithZero.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_2] {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)))))))) -> (forall {S : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)} {T : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)}, Iff (LE.le.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (Preorder.toLE.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (PartialOrder.toPreorder.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.partialOrder.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))))) (SMul.smul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toHasSmul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) a S) T) (LE.le.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (Preorder.toLE.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (PartialOrder.toPreorder.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.partialOrder.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))))) S (SMul.smul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toHasSmul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α _inst_3)) a) T)))
but is expected to have type
  forall {α : Type.{u2}} {A : Type.{u1}} [_inst_2 : AddMonoid.{u1} A] [_inst_3 : GroupWithZero.{u2} α] [_inst_4 : DistribMulAction.{u2, u1} α A (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_2] {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3))))) -> (forall {S : AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)} {T : AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)}, Iff (LE.le.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (Preorder.toLE.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)))))) (HSMul.hSMul.{u2, u1, u1} α (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (instHSMul.{u2, u1} α (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (MulAction.toSMul.{u2, u1} α (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u2, u1} α A _inst_2 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) a S) T) (LE.le.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (Preorder.toLE.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)))))) S (HSMul.hSMul.{u2, u1, u1} α (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (instHSMul.{u2, u1} α (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (MulAction.toSMul.{u2, u1} α (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u2, u1} α A _inst_2 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) (Inv.inv.{u2} α (GroupWithZero.toInv.{u2} α _inst_3) a) T)))
Case conversion may be inaccurate. Consider using '#align add_submonoid.pointwise_smul_le_iff₀ AddSubmonoid.pointwise_smul_le_iff₀ₓ'. -/
theorem pointwise_smul_le_iff₀ {a : α} (ha : a ≠ 0) {S T : AddSubmonoid A} :
    a • S ≤ T ↔ S ≤ a⁻¹ • T :=
  set_smul_subset_iff₀ ha
#align add_submonoid.pointwise_smul_le_iff₀ AddSubmonoid.pointwise_smul_le_iff₀

/- warning: add_submonoid.le_pointwise_smul_iff₀ -> AddSubmonoid.le_pointwise_smul_iff₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {A : Type.{u2}} [_inst_2 : AddMonoid.{u2} A] [_inst_3 : GroupWithZero.{u1} α] [_inst_4 : DistribMulAction.{u1, u2} α A (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_2] {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)))))))) -> (forall {S : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)} {T : AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)}, Iff (LE.le.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (Preorder.toLE.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (PartialOrder.toPreorder.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.partialOrder.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))))) S (SMul.smul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toHasSmul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) a T)) (LE.le.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (Preorder.toLE.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (PartialOrder.toPreorder.{u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (SetLike.partialOrder.{u2, u2} (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) A (AddSubmonoid.setLike.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2))))) (SMul.smul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MulAction.toHasSmul.{u1, u2} α (AddSubmonoid.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_2)) (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u1, u2} α A _inst_2 (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α _inst_3)) _inst_4)) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α _inst_3)) a) S) T))
but is expected to have type
  forall {α : Type.{u2}} {A : Type.{u1}} [_inst_2 : AddMonoid.{u1} A] [_inst_3 : GroupWithZero.{u2} α] [_inst_4 : DistribMulAction.{u2, u1} α A (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_2] {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3))))) -> (forall {S : AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)} {T : AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)}, Iff (LE.le.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (Preorder.toLE.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)))))) S (HSMul.hSMul.{u2, u1, u1} α (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (instHSMul.{u2, u1} α (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (MulAction.toSMul.{u2, u1} α (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u2, u1} α A _inst_2 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) a T)) (LE.le.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (Preorder.toLE.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)))))) (HSMul.hSMul.{u2, u1, u1} α (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (instHSMul.{u2, u1} α (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (MulAction.toSMul.{u2, u1} α (AddSubmonoid.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) (AddSubmonoid.pointwiseMulAction.{u2, u1} α A _inst_2 (MonoidWithZero.toMonoid.{u2} α (GroupWithZero.toMonoidWithZero.{u2} α _inst_3)) _inst_4))) (Inv.inv.{u2} α (GroupWithZero.toInv.{u2} α _inst_3) a) S) T))
Case conversion may be inaccurate. Consider using '#align add_submonoid.le_pointwise_smul_iff₀ AddSubmonoid.le_pointwise_smul_iff₀ₓ'. -/
theorem le_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) {S T : AddSubmonoid A} :
    S ≤ a • T ↔ a⁻¹ • S ≤ T :=
  subset_set_smul_iff₀ ha
#align add_submonoid.le_pointwise_smul_iff₀ AddSubmonoid.le_pointwise_smul_iff₀

end GroupWithZero

end AddSubmonoid

/-! ### Elementwise monoid structure of additive submonoids

These definitions are a cut-down versions of the ones around `submodule.has_mul`, as that API is
usually more useful. -/


namespace AddSubmonoid

open Pointwise

section AddMonoidWithOne

variable [AddMonoidWithOne R]

instance : One (AddSubmonoid R) :=
  ⟨(Nat.castAddMonoidHom R).mrange⟩

#print AddSubmonoid.one_eq_mrange /-
theorem one_eq_mrange : (1 : AddSubmonoid R) = (Nat.castAddMonoidHom R).mrange :=
  rfl
#align add_submonoid.one_eq_mrange AddSubmonoid.one_eq_mrange
-/

/- warning: add_submonoid.nat_cast_mem_one -> AddSubmonoid.natCast_mem_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : AddMonoidWithOne.{u1} R] (n : Nat), Membership.Mem.{u1, u1} R (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R _inst_3))) (SetLike.hasMem.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R _inst_3))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R _inst_3)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u1} Nat R (CoeTCₓ.coe.{1, succ u1} Nat R (Nat.castCoe.{u1} R (AddMonoidWithOne.toNatCast.{u1} R _inst_3)))) n) (OfNat.ofNat.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R _inst_3))) 1 (OfNat.mk.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R _inst_3))) 1 (One.one.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R _inst_3))) (AddSubmonoid.hasOne.{u1} R _inst_3))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : AddMonoidWithOne.{u1} R] (n : Nat), Membership.mem.{u1, u1} R (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R _inst_3))) (SetLike.instMembership.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R _inst_3))) R (AddSubmonoid.instSetLikeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R _inst_3)))) (Nat.cast.{u1} R (AddMonoidWithOne.toNatCast.{u1} R _inst_3) n) (OfNat.ofNat.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R _inst_3))) 1 (One.toOfNat1.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R _inst_3))) (AddSubmonoid.one.{u1} R _inst_3)))
Case conversion may be inaccurate. Consider using '#align add_submonoid.nat_cast_mem_one AddSubmonoid.natCast_mem_oneₓ'. -/
theorem natCast_mem_one (n : ℕ) : (n : R) ∈ (1 : AddSubmonoid R) :=
  ⟨_, rfl⟩
#align add_submonoid.nat_cast_mem_one AddSubmonoid.natCast_mem_one

/- warning: add_submonoid.mem_one -> AddSubmonoid.mem_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : AddMonoidWithOne.{u1} R] {x : R}, Iff (Membership.Mem.{u1, u1} R (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R _inst_3))) (SetLike.hasMem.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R _inst_3))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R _inst_3)))) x (OfNat.ofNat.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R _inst_3))) 1 (OfNat.mk.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R _inst_3))) 1 (One.one.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R _inst_3))) (AddSubmonoid.hasOne.{u1} R _inst_3))))) (Exists.{1} Nat (fun (n : Nat) => Eq.{succ u1} R ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u1} Nat R (CoeTCₓ.coe.{1, succ u1} Nat R (Nat.castCoe.{u1} R (AddMonoidWithOne.toNatCast.{u1} R _inst_3)))) n) x))
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : AddMonoidWithOne.{u1} R] {x : R}, Iff (Membership.mem.{u1, u1} R (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R _inst_3))) (SetLike.instMembership.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R _inst_3))) R (AddSubmonoid.instSetLikeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R _inst_3)))) x (OfNat.ofNat.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R _inst_3))) 1 (One.toOfNat1.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R _inst_3))) (AddSubmonoid.one.{u1} R _inst_3)))) (Exists.{1} Nat (fun (n : Nat) => Eq.{succ u1} R (Nat.cast.{u1} R (AddMonoidWithOne.toNatCast.{u1} R _inst_3) n) x))
Case conversion may be inaccurate. Consider using '#align add_submonoid.mem_one AddSubmonoid.mem_oneₓ'. -/
@[simp]
theorem mem_one {x : R} : x ∈ (1 : AddSubmonoid R) ↔ ∃ n : ℕ, ↑n = x :=
  Iff.rfl
#align add_submonoid.mem_one AddSubmonoid.mem_one

#print AddSubmonoid.one_eq_closure /-
theorem one_eq_closure : (1 : AddSubmonoid R) = closure {1} :=
  by
  simp only [closure_singleton_eq, mul_one, one_eq_mrange]
  congr 1 with n
  simp
#align add_submonoid.one_eq_closure AddSubmonoid.one_eq_closure
-/

#print AddSubmonoid.one_eq_closure_one_set /-
theorem one_eq_closure_one_set : (1 : AddSubmonoid R) = closure 1 :=
  one_eq_closure
#align add_submonoid.one_eq_closure_one_set AddSubmonoid.one_eq_closure_one_set
-/

end AddMonoidWithOne

section NonUnitalNonAssocSemiring

variable [NonUnitalNonAssocSemiring R]

/-- Multiplication of additive submonoids of a semiring R. The additive submonoid `S * T` is the
smallest R-submodule of `R` containing the elements `s * t` for `s ∈ S` and `t ∈ T`. -/
instance : Mul (AddSubmonoid R) :=
  ⟨fun M N => ⨆ s : M, N.map <| AddMonoidHom.mul s.1⟩

/- warning: add_submonoid.mul_mem_mul -> AddSubmonoid.mul_mem_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : NonUnitalNonAssocSemiring.{u1} R] {M : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))} {N : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))} {m : R} {n : R}, (Membership.Mem.{u1, u1} R (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (SetLike.hasMem.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))) m M) -> (Membership.Mem.{u1, u1} R (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (SetLike.hasMem.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))) n N) -> (Membership.Mem.{u1, u1} R (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (SetLike.hasMem.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_3))) m n) (HMul.hMul.{u1, u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (instHMul.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.hasMul.{u1} R _inst_3)) M N))
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : NonUnitalNonAssocSemiring.{u1} R] {M : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))} {N : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))} {m : R} {n : R}, (Membership.mem.{u1, u1} R (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (SetLike.instMembership.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.instSetLikeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))) m M) -> (Membership.mem.{u1, u1} R (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (SetLike.instMembership.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.instSetLikeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))) n N) -> (Membership.mem.{u1, u1} R (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (SetLike.instMembership.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.instSetLikeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_3)) m n) (HMul.hMul.{u1, u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (instHMul.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.mul.{u1} R _inst_3)) M N))
Case conversion may be inaccurate. Consider using '#align add_submonoid.mul_mem_mul AddSubmonoid.mul_mem_mulₓ'. -/
theorem mul_mem_mul {M N : AddSubmonoid R} {m n : R} (hm : m ∈ M) (hn : n ∈ N) : m * n ∈ M * N :=
  (le_supᵢ _ ⟨m, hm⟩ : _ ≤ M * N) ⟨n, hn, rfl⟩
#align add_submonoid.mul_mem_mul AddSubmonoid.mul_mem_mul

/- warning: add_submonoid.mul_le -> AddSubmonoid.mul_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : NonUnitalNonAssocSemiring.{u1} R] {M : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))} {N : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))} {P : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))}, Iff (LE.le.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (SetLike.partialOrder.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))))) (HMul.hMul.{u1, u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (instHMul.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.hasMul.{u1} R _inst_3)) M N) P) (forall (m : R), (Membership.Mem.{u1, u1} R (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (SetLike.hasMem.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))) m M) -> (forall (n : R), (Membership.Mem.{u1, u1} R (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (SetLike.hasMem.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))) n N) -> (Membership.Mem.{u1, u1} R (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (SetLike.hasMem.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_3))) m n) P)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : NonUnitalNonAssocSemiring.{u1} R] {M : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))} {N : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))} {P : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))}, Iff (LE.le.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))))))) (HMul.hMul.{u1, u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (instHMul.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.mul.{u1} R _inst_3)) M N) P) (forall (m : R), (Membership.mem.{u1, u1} R (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (SetLike.instMembership.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.instSetLikeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))) m M) -> (forall (n : R), (Membership.mem.{u1, u1} R (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (SetLike.instMembership.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.instSetLikeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))) n N) -> (Membership.mem.{u1, u1} R (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (SetLike.instMembership.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.instSetLikeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_3)) m n) P)))
Case conversion may be inaccurate. Consider using '#align add_submonoid.mul_le AddSubmonoid.mul_leₓ'. -/
theorem mul_le {M N P : AddSubmonoid R} : M * N ≤ P ↔ ∀ m ∈ M, ∀ n ∈ N, m * n ∈ P :=
  ⟨fun H m hm n hn => H <| mul_mem_mul hm hn, fun H =>
    supᵢ_le fun ⟨m, hm⟩ => map_le_iff_le_comap.2 fun n hn => H m hm n hn⟩
#align add_submonoid.mul_le AddSubmonoid.mul_le

/- warning: add_submonoid.mul_induction_on -> AddSubmonoid.mul_induction_on is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : NonUnitalNonAssocSemiring.{u1} R] {M : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))} {N : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))} {C : R -> Prop} {r : R}, (Membership.Mem.{u1, u1} R (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (SetLike.hasMem.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))) r (HMul.hMul.{u1, u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (instHMul.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.hasMul.{u1} R _inst_3)) M N)) -> (forall (m : R), (Membership.Mem.{u1, u1} R (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (SetLike.hasMem.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))) m M) -> (forall (n : R), (Membership.Mem.{u1, u1} R (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (SetLike.hasMem.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))) n N) -> (C (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_3))) m n)))) -> (forall (x : R) (y : R), (C x) -> (C y) -> (C (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_3))) x y))) -> (C r)
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : NonUnitalNonAssocSemiring.{u1} R] {M : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))} {N : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))} {C : R -> Prop} {r : R}, (Membership.mem.{u1, u1} R (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (SetLike.instMembership.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.instSetLikeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))) r (HMul.hMul.{u1, u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (instHMul.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.mul.{u1} R _inst_3)) M N)) -> (forall (m : R), (Membership.mem.{u1, u1} R (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (SetLike.instMembership.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.instSetLikeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))) m M) -> (forall (n : R), (Membership.mem.{u1, u1} R (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (SetLike.instMembership.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.instSetLikeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))) n N) -> (C (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_3)) m n)))) -> (forall (x : R) (y : R), (C x) -> (C y) -> (C (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_3))) x y))) -> (C r)
Case conversion may be inaccurate. Consider using '#align add_submonoid.mul_induction_on AddSubmonoid.mul_induction_onₓ'. -/
@[elab_as_elim]
protected theorem mul_induction_on {M N : AddSubmonoid R} {C : R → Prop} {r : R} (hr : r ∈ M * N)
    (hm : ∀ m ∈ M, ∀ n ∈ N, C (m * n)) (ha : ∀ x y, C x → C y → C (x + y)) : C r :=
  (@mul_le _ _ _ _ ⟨C, ha, by simpa only [zero_mul] using hm _ (zero_mem _) _ (zero_mem _)⟩).2 hm hr
#align add_submonoid.mul_induction_on AddSubmonoid.mul_induction_on

open Pointwise

/- warning: add_submonoid.closure_mul_closure -> AddSubmonoid.closure_mul_closure is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : NonUnitalNonAssocSemiring.{u1} R] (S : Set.{u1} R) (T : Set.{u1} R), Eq.{succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (HMul.hMul.{u1, u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (instHMul.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.hasMul.{u1} R _inst_3)) (AddSubmonoid.closure.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))) S) (AddSubmonoid.closure.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))) T)) (AddSubmonoid.closure.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))) (HMul.hMul.{u1, u1, u1} (Set.{u1} R) (Set.{u1} R) (Set.{u1} R) (instHMul.{u1} (Set.{u1} R) (Set.mul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_3)))) S T))
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : NonUnitalNonAssocSemiring.{u1} R] (S : Set.{u1} R) (T : Set.{u1} R), Eq.{succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (HMul.hMul.{u1, u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (instHMul.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.mul.{u1} R _inst_3)) (AddSubmonoid.closure.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))) S) (AddSubmonoid.closure.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))) T)) (AddSubmonoid.closure.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))) (HMul.hMul.{u1, u1, u1} (Set.{u1} R) (Set.{u1} R) (Set.{u1} R) (instHMul.{u1} (Set.{u1} R) (Set.mul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_3))) S T))
Case conversion may be inaccurate. Consider using '#align add_submonoid.closure_mul_closure AddSubmonoid.closure_mul_closureₓ'. -/
-- this proof is copied directly from `submodule.span_mul_span`
theorem closure_mul_closure (S T : Set R) : closure S * closure T = closure (S * T) :=
  by
  apply le_antisymm
  · rw [mul_le]
    intro a ha b hb
    apply closure_induction ha
    on_goal 1 =>
      intros ; apply closure_induction hb
      on_goal 1 => intros ; exact subset_closure ⟨_, _, ‹_›, ‹_›, rfl⟩
    all_goals intros ;
      simp only [mul_zero, zero_mul, zero_mem, left_distrib, right_distrib, mul_smul_comm,
          smul_mul_assoc] <;>
        solve_by_elim (config :=
          { max_depth := 4
            discharger := tactic.interactive.apply_instance }) [add_mem _ _, zero_mem _]
  · rw [closure_le]
    rintro _ ⟨a, b, ha, hb, rfl⟩
    exact mul_mem_mul (subset_closure ha) (subset_closure hb)
#align add_submonoid.closure_mul_closure AddSubmonoid.closure_mul_closure

/- warning: add_submonoid.mul_eq_closure_mul_set -> AddSubmonoid.mul_eq_closure_mul_set is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : NonUnitalNonAssocSemiring.{u1} R] (M : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (N : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))), Eq.{succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (HMul.hMul.{u1, u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (instHMul.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.hasMul.{u1} R _inst_3)) M N) (AddSubmonoid.closure.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))) (HMul.hMul.{u1, u1, u1} (Set.{u1} R) (Set.{u1} R) (Set.{u1} R) (instHMul.{u1} (Set.{u1} R) (Set.mul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_3)))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))))) M) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))))) N)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : NonUnitalNonAssocSemiring.{u1} R] (M : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (N : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))), Eq.{succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (HMul.hMul.{u1, u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (instHMul.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.mul.{u1} R _inst_3)) M N) (AddSubmonoid.closure.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))) (HMul.hMul.{u1, u1, u1} (Set.{u1} R) (Set.{u1} R) (Set.{u1} R) (instHMul.{u1} (Set.{u1} R) (Set.mul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_3))) (SetLike.coe.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.instSetLikeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) M) (SetLike.coe.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.instSetLikeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) N)))
Case conversion may be inaccurate. Consider using '#align add_submonoid.mul_eq_closure_mul_set AddSubmonoid.mul_eq_closure_mul_setₓ'. -/
theorem mul_eq_closure_mul_set (M N : AddSubmonoid R) : M * N = closure (M * N) := by
  rw [← closure_mul_closure, closure_eq, closure_eq]
#align add_submonoid.mul_eq_closure_mul_set AddSubmonoid.mul_eq_closure_mul_set

/- warning: add_submonoid.mul_bot -> AddSubmonoid.mul_bot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : NonUnitalNonAssocSemiring.{u1} R] (S : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))), Eq.{succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (HMul.hMul.{u1, u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (instHMul.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.hasMul.{u1} R _inst_3)) S (Bot.bot.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.hasBot.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))))) (Bot.bot.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.hasBot.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : NonUnitalNonAssocSemiring.{u1} R] (S : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))), Eq.{succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (HMul.hMul.{u1, u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (instHMul.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.mul.{u1} R _inst_3)) S (Bot.bot.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.instBotAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))))) (Bot.bot.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.instBotAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))))
Case conversion may be inaccurate. Consider using '#align add_submonoid.mul_bot AddSubmonoid.mul_botₓ'. -/
@[simp]
theorem mul_bot (S : AddSubmonoid R) : S * ⊥ = ⊥ :=
  eq_bot_iff.2 <|
    mul_le.2 fun m hm n hn => by rw [AddSubmonoid.mem_bot] at hn⊢ <;> rw [hn, mul_zero]
#align add_submonoid.mul_bot AddSubmonoid.mul_bot

/- warning: add_submonoid.bot_mul -> AddSubmonoid.bot_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : NonUnitalNonAssocSemiring.{u1} R] (S : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))), Eq.{succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (HMul.hMul.{u1, u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (instHMul.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.hasMul.{u1} R _inst_3)) (Bot.bot.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.hasBot.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))) S) (Bot.bot.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.hasBot.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : NonUnitalNonAssocSemiring.{u1} R] (S : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))), Eq.{succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (HMul.hMul.{u1, u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (instHMul.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.mul.{u1} R _inst_3)) (Bot.bot.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.instBotAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))) S) (Bot.bot.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.instBotAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))))
Case conversion may be inaccurate. Consider using '#align add_submonoid.bot_mul AddSubmonoid.bot_mulₓ'. -/
@[simp]
theorem bot_mul (S : AddSubmonoid R) : ⊥ * S = ⊥ :=
  eq_bot_iff.2 <|
    mul_le.2 fun m hm n hn => by rw [AddSubmonoid.mem_bot] at hm⊢ <;> rw [hm, zero_mul]
#align add_submonoid.bot_mul AddSubmonoid.bot_mul

/- warning: add_submonoid.mul_le_mul -> AddSubmonoid.mul_le_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : NonUnitalNonAssocSemiring.{u1} R] {M : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))} {N : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))} {P : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))} {Q : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))}, (LE.le.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (SetLike.partialOrder.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))))) M P) -> (LE.le.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (SetLike.partialOrder.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))))) N Q) -> (LE.le.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (SetLike.partialOrder.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))))) (HMul.hMul.{u1, u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (instHMul.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.hasMul.{u1} R _inst_3)) M N) (HMul.hMul.{u1, u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (instHMul.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.hasMul.{u1} R _inst_3)) P Q))
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : NonUnitalNonAssocSemiring.{u1} R] {M : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))} {N : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))} {P : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))} {Q : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))}, (LE.le.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))))))) M P) -> (LE.le.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))))))) N Q) -> (LE.le.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))))))) (HMul.hMul.{u1, u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (instHMul.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.mul.{u1} R _inst_3)) M N) (HMul.hMul.{u1, u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (instHMul.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.mul.{u1} R _inst_3)) P Q))
Case conversion may be inaccurate. Consider using '#align add_submonoid.mul_le_mul AddSubmonoid.mul_le_mulₓ'. -/
@[mono]
theorem mul_le_mul {M N P Q : AddSubmonoid R} (hmp : M ≤ P) (hnq : N ≤ Q) : M * N ≤ P * Q :=
  mul_le.2 fun m hm n hn => mul_mem_mul (hmp hm) (hnq hn)
#align add_submonoid.mul_le_mul AddSubmonoid.mul_le_mul

/- warning: add_submonoid.mul_le_mul_left -> AddSubmonoid.mul_le_mul_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : NonUnitalNonAssocSemiring.{u1} R] {M : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))} {N : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))} {P : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))}, (LE.le.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (SetLike.partialOrder.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))))) M N) -> (LE.le.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (SetLike.partialOrder.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))))) (HMul.hMul.{u1, u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (instHMul.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.hasMul.{u1} R _inst_3)) M P) (HMul.hMul.{u1, u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (instHMul.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.hasMul.{u1} R _inst_3)) N P))
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : NonUnitalNonAssocSemiring.{u1} R] {M : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))} {N : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))} {P : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))}, (LE.le.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))))))) M N) -> (LE.le.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))))))) (HMul.hMul.{u1, u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (instHMul.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.mul.{u1} R _inst_3)) M P) (HMul.hMul.{u1, u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (instHMul.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.mul.{u1} R _inst_3)) N P))
Case conversion may be inaccurate. Consider using '#align add_submonoid.mul_le_mul_left AddSubmonoid.mul_le_mul_leftₓ'. -/
theorem mul_le_mul_left {M N P : AddSubmonoid R} (h : M ≤ N) : M * P ≤ N * P :=
  mul_le_mul h (le_refl P)
#align add_submonoid.mul_le_mul_left AddSubmonoid.mul_le_mul_left

/- warning: add_submonoid.mul_le_mul_right -> AddSubmonoid.mul_le_mul_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : NonUnitalNonAssocSemiring.{u1} R] {M : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))} {N : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))} {P : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))}, (LE.le.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (SetLike.partialOrder.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))))) N P) -> (LE.le.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (SetLike.partialOrder.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))))) (HMul.hMul.{u1, u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (instHMul.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.hasMul.{u1} R _inst_3)) M N) (HMul.hMul.{u1, u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (instHMul.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.hasMul.{u1} R _inst_3)) M P))
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : NonUnitalNonAssocSemiring.{u1} R] {M : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))} {N : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))} {P : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))}, (LE.le.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))))))) N P) -> (LE.le.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Preorder.toLE.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))))))) (HMul.hMul.{u1, u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (instHMul.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.mul.{u1} R _inst_3)) M N) (HMul.hMul.{u1, u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (instHMul.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.mul.{u1} R _inst_3)) M P))
Case conversion may be inaccurate. Consider using '#align add_submonoid.mul_le_mul_right AddSubmonoid.mul_le_mul_rightₓ'. -/
theorem mul_le_mul_right {M N P : AddSubmonoid R} (h : N ≤ P) : M * N ≤ M * P :=
  mul_le_mul (le_refl M) h
#align add_submonoid.mul_le_mul_right AddSubmonoid.mul_le_mul_right

/- warning: add_submonoid.mul_subset_mul -> AddSubmonoid.mul_subset_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : NonUnitalNonAssocSemiring.{u1} R] {M : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))} {N : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))}, HasSubset.Subset.{u1} (Set.{u1} R) (Set.hasSubset.{u1} R) (HMul.hMul.{u1, u1, u1} (Set.{u1} R) (Set.{u1} R) (Set.{u1} R) (instHMul.{u1} (Set.{u1} R) (Set.mul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_3)))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))))) M) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))))) N)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3))))))) (HMul.hMul.{u1, u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (instHMul.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.hasMul.{u1} R _inst_3)) M N))
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : NonUnitalNonAssocSemiring.{u1} R] {M : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))} {N : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))}, HasSubset.Subset.{u1} (Set.{u1} R) (Set.instHasSubsetSet.{u1} R) (HMul.hMul.{u1, u1, u1} (Set.{u1} R) (Set.{u1} R) (Set.{u1} R) (instHMul.{u1} (Set.{u1} R) (Set.mul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_3))) (SetLike.coe.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.instSetLikeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) M) (SetLike.coe.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.instSetLikeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) N)) (SetLike.coe.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) R (AddSubmonoid.instSetLikeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (HMul.hMul.{u1, u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (instHMul.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_3)))) (AddSubmonoid.mul.{u1} R _inst_3)) M N))
Case conversion may be inaccurate. Consider using '#align add_submonoid.mul_subset_mul AddSubmonoid.mul_subset_mulₓ'. -/
theorem mul_subset_mul {M N : AddSubmonoid R} : (↑M : Set R) * (↑N : Set R) ⊆ (↑(M * N) : Set R) :=
  by
  rintro _ ⟨i, j, hi, hj, rfl⟩
  exact mul_mem_mul hi hj
#align add_submonoid.mul_subset_mul AddSubmonoid.mul_subset_mul

end NonUnitalNonAssocSemiring

section NonUnitalNonAssocRing

variable [NonUnitalNonAssocRing R]

/- warning: add_submonoid.has_distrib_neg -> AddSubmonoid.hasDistribNeg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : NonUnitalNonAssocRing.{u1} R], HasDistribNeg.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (SubNegMonoid.toAddMonoid.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R _inst_3)))))) (AddSubmonoid.hasMul.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_3))
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : NonUnitalNonAssocRing.{u1} R], HasDistribNeg.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (SubNegMonoid.toAddMonoid.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R _inst_3)))))) (AddSubmonoid.mul.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_3))
Case conversion may be inaccurate. Consider using '#align add_submonoid.has_distrib_neg AddSubmonoid.hasDistribNegₓ'. -/
/-- `add_submonoid.has_pointwise_neg` distributes over multiplication.

This is available as an instance in the `pointwise` locale. -/
protected def hasDistribNeg : HasDistribNeg (AddSubmonoid R) :=
  { AddSubmonoid.hasInvolutiveNeg with
    neg := Neg.neg
    neg_mul := fun x y =>
      by
      refine'
          le_antisymm (mul_le.2 fun m hm n hn => _)
            ((AddSubmonoid.neg_le _ _).2 <| mul_le.2 fun m hm n hn => _) <;>
        simp only [AddSubmonoid.mem_neg, ← neg_mul] at *
      · exact mul_mem_mul hm hn
      · exact mul_mem_mul (neg_mem_neg.2 hm) hn
    mul_neg := fun x y =>
      by
      refine'
          le_antisymm (mul_le.2 fun m hm n hn => _)
            ((AddSubmonoid.neg_le _ _).2 <| mul_le.2 fun m hm n hn => _) <;>
        simp only [AddSubmonoid.mem_neg, ← mul_neg] at *
      · exact mul_mem_mul hm hn
      · exact mul_mem_mul hm (neg_mem_neg.2 hn) }
#align add_submonoid.has_distrib_neg AddSubmonoid.hasDistribNeg

scoped[Pointwise] attribute [instance] AddSubmonoid.hasDistribNeg

end NonUnitalNonAssocRing

section NonAssocSemiring

variable [NonAssocSemiring R]

instance : MulOneClass (AddSubmonoid R) where
  one := 1
  mul := (· * ·)
  one_mul M := by rw [one_eq_closure_one_set, ← closure_eq M, closure_mul_closure, one_mul]
  mul_one M := by rw [one_eq_closure_one_set, ← closure_eq M, closure_mul_closure, mul_one]

end NonAssocSemiring

section NonUnitalSemiring

variable [NonUnitalSemiring R]

instance : Semigroup (AddSubmonoid R) where
  mul := (· * ·)
  mul_assoc M N P :=
    le_antisymm
      (mul_le.2 fun mn hmn p hp =>
        suffices M * N ≤ (M * (N * P)).comap (AddMonoidHom.mulRight p) from this hmn
        mul_le.2 fun m hm n hn =>
          show m * n * p ∈ M * (N * P) from
            (mul_assoc m n p).symm ▸ mul_mem_mul hm (mul_mem_mul hn hp))
      (mul_le.2 fun m hm np hnp =>
        suffices N * P ≤ (M * N * P).comap (AddMonoidHom.mulLeft m) from this hnp
        mul_le.2 fun n hn p hp =>
          show m * (n * p) ∈ M * N * P from mul_assoc m n p ▸ mul_mem_mul (mul_mem_mul hm hn) hp)

end NonUnitalSemiring

section Semiring

variable [Semiring R]

instance : Monoid (AddSubmonoid R) :=
  { AddSubmonoid.semigroup,
    AddSubmonoid.mulOneClass with
    one := 1
    mul := (· * ·) }

/- warning: add_submonoid.closure_pow -> AddSubmonoid.closure_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : Semiring.{u1} R] (s : Set.{u1} R) (n : Nat), Eq.{succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) (HPow.hPow.{u1, 0, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) Nat (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) (instHPow.{u1, 0} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) Nat (Monoid.Pow.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) (AddSubmonoid.monoid.{u1} R _inst_3))) (AddSubmonoid.closure.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3))))) s) n) (AddSubmonoid.closure.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3))))) (HPow.hPow.{u1, 0, u1} (Set.{u1} R) Nat (Set.{u1} R) (instHPow.{u1, 0} (Set.{u1} R) Nat (Set.NPow.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) s n))
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : Semiring.{u1} R] (s : Set.{u1} R) (n : Nat), Eq.{succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) (HPow.hPow.{u1, 0, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) Nat (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) (instHPow.{u1, 0} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) Nat (Monoid.Pow.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) (AddSubmonoid.monoid.{u1} R _inst_3))) (AddSubmonoid.closure.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3))))) s) n) (AddSubmonoid.closure.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3))))) (HPow.hPow.{u1, 0, u1} (Set.{u1} R) Nat (Set.{u1} R) (instHPow.{u1, 0} (Set.{u1} R) Nat (Set.NPow.{u1} R (Semiring.toOne.{u1} R _inst_3) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3))))) s n))
Case conversion may be inaccurate. Consider using '#align add_submonoid.closure_pow AddSubmonoid.closure_powₓ'. -/
theorem closure_pow (s : Set R) : ∀ n : ℕ, closure s ^ n = closure (s ^ n)
  | 0 => by rw [pow_zero, pow_zero, one_eq_closure_one_set]
  | n + 1 => by rw [pow_succ, pow_succ, closure_pow, closure_mul_closure]
#align add_submonoid.closure_pow AddSubmonoid.closure_pow

/- warning: add_submonoid.pow_eq_closure_pow_set -> AddSubmonoid.pow_eq_closure_pow_set is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : Semiring.{u1} R] (s : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) (n : Nat), Eq.{succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) (HPow.hPow.{u1, 0, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) Nat (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) (instHPow.{u1, 0} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) Nat (Monoid.Pow.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) (AddSubmonoid.monoid.{u1} R _inst_3))) s n) (AddSubmonoid.closure.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3))))) (HPow.hPow.{u1, 0, u1} (Set.{u1} R) Nat (Set.{u1} R) (instHPow.{u1, 0} (Set.{u1} R) Nat (Set.NPow.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3))))))))) s) n))
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : Semiring.{u1} R] (s : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) (n : Nat), Eq.{succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) (HPow.hPow.{u1, 0, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) Nat (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) (instHPow.{u1, 0} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) Nat (Monoid.Pow.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) (AddSubmonoid.monoid.{u1} R _inst_3))) s n) (AddSubmonoid.closure.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3))))) (HPow.hPow.{u1, 0, u1} (Set.{u1} R) Nat (Set.{u1} R) (instHPow.{u1, 0} (Set.{u1} R) Nat (Set.NPow.{u1} R (Semiring.toOne.{u1} R _inst_3) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3))))) (SetLike.coe.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) R (AddSubmonoid.instSetLikeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) s) n))
Case conversion may be inaccurate. Consider using '#align add_submonoid.pow_eq_closure_pow_set AddSubmonoid.pow_eq_closure_pow_setₓ'. -/
theorem pow_eq_closure_pow_set (s : AddSubmonoid R) (n : ℕ) : s ^ n = closure ((s : Set R) ^ n) :=
  by rw [← closure_pow, closure_eq]
#align add_submonoid.pow_eq_closure_pow_set AddSubmonoid.pow_eq_closure_pow_set

/- warning: add_submonoid.pow_subset_pow -> AddSubmonoid.pow_subset_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : Semiring.{u1} R] {s : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))} {n : Nat}, HasSubset.Subset.{u1} (Set.{u1} R) (Set.hasSubset.{u1} R) (HPow.hPow.{u1, 0, u1} (Set.{u1} R) Nat (Set.{u1} R) (instHPow.{u1, 0} (Set.{u1} R) Nat (Set.NPow.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3))))))))) s) n) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3))))))))) (HPow.hPow.{u1, 0, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) Nat (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) (instHPow.{u1, 0} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) Nat (Monoid.Pow.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) (AddSubmonoid.monoid.{u1} R _inst_3))) s n))
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : Semiring.{u1} R] {s : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))} {n : Nat}, HasSubset.Subset.{u1} (Set.{u1} R) (Set.instHasSubsetSet.{u1} R) (HPow.hPow.{u1, 0, u1} (Set.{u1} R) Nat (Set.{u1} R) (instHPow.{u1, 0} (Set.{u1} R) Nat (Set.NPow.{u1} R (Semiring.toOne.{u1} R _inst_3) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3))))) (SetLike.coe.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) R (AddSubmonoid.instSetLikeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) s) n) (SetLike.coe.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) R (AddSubmonoid.instSetLikeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) (HPow.hPow.{u1, 0, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) Nat (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) (instHPow.{u1, 0} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) Nat (Monoid.Pow.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)))))) (AddSubmonoid.monoid.{u1} R _inst_3))) s n))
Case conversion may be inaccurate. Consider using '#align add_submonoid.pow_subset_pow AddSubmonoid.pow_subset_powₓ'. -/
theorem pow_subset_pow {s : AddSubmonoid R} {n : ℕ} : (↑s : Set R) ^ n ⊆ ↑(s ^ n) :=
  (pow_eq_closure_pow_set s n).symm ▸ subset_closure
#align add_submonoid.pow_subset_pow AddSubmonoid.pow_subset_pow

end Semiring

end AddSubmonoid

namespace Set.IsPwo

variable [OrderedCancelCommMonoid α] {s : Set α}

/- warning: set.is_pwo.submonoid_closure -> Set.IsPwo.submonoid_closure is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_3 : OrderedCancelCommMonoid.{u1} α] {s : Set.{u1} α}, (forall (x : α), (Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCancelCommMonoid.toPartialOrder.{u1} α _inst_3))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (MulOneClass.toHasOne.{u1} α (Monoid.toMulOneClass.{u1} α (RightCancelMonoid.toMonoid.{u1} α (CancelMonoid.toRightCancelMonoid.{u1} α (CancelCommMonoid.toCancelMonoid.{u1} α (OrderedCancelCommMonoid.toCancelCommMonoid.{u1} α _inst_3))))))))) x)) -> (Set.IsPwo.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCancelCommMonoid.toPartialOrder.{u1} α _inst_3)) s) -> (Set.IsPwo.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCancelCommMonoid.toPartialOrder.{u1} α _inst_3)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Submonoid.{u1} α (Monoid.toMulOneClass.{u1} α (RightCancelMonoid.toMonoid.{u1} α (CancelMonoid.toRightCancelMonoid.{u1} α (CancelCommMonoid.toCancelMonoid.{u1} α (OrderedCancelCommMonoid.toCancelCommMonoid.{u1} α _inst_3)))))) (Set.{u1} α) (HasLiftT.mk.{succ u1, succ u1} (Submonoid.{u1} α (Monoid.toMulOneClass.{u1} α (RightCancelMonoid.toMonoid.{u1} α (CancelMonoid.toRightCancelMonoid.{u1} α (CancelCommMonoid.toCancelMonoid.{u1} α (OrderedCancelCommMonoid.toCancelCommMonoid.{u1} α _inst_3)))))) (Set.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} (Submonoid.{u1} α (Monoid.toMulOneClass.{u1} α (RightCancelMonoid.toMonoid.{u1} α (CancelMonoid.toRightCancelMonoid.{u1} α (CancelCommMonoid.toCancelMonoid.{u1} α (OrderedCancelCommMonoid.toCancelCommMonoid.{u1} α _inst_3)))))) (Set.{u1} α) (SetLike.Set.hasCoeT.{u1, u1} (Submonoid.{u1} α (Monoid.toMulOneClass.{u1} α (RightCancelMonoid.toMonoid.{u1} α (CancelMonoid.toRightCancelMonoid.{u1} α (CancelCommMonoid.toCancelMonoid.{u1} α (OrderedCancelCommMonoid.toCancelCommMonoid.{u1} α _inst_3)))))) α (Submonoid.setLike.{u1} α (Monoid.toMulOneClass.{u1} α (RightCancelMonoid.toMonoid.{u1} α (CancelMonoid.toRightCancelMonoid.{u1} α (CancelCommMonoid.toCancelMonoid.{u1} α (OrderedCancelCommMonoid.toCancelCommMonoid.{u1} α _inst_3))))))))) (Submonoid.closure.{u1} α (Monoid.toMulOneClass.{u1} α (RightCancelMonoid.toMonoid.{u1} α (CancelMonoid.toRightCancelMonoid.{u1} α (CancelCommMonoid.toCancelMonoid.{u1} α (OrderedCancelCommMonoid.toCancelCommMonoid.{u1} α _inst_3))))) s)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_3 : OrderedCancelCommMonoid.{u1} α] {s : Set.{u1} α}, (forall (x : α), (Membership.mem.{u1, u1} α (Set.{u1} α) (Set.instMembershipSet.{u1} α) x s) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCancelCommMonoid.toPartialOrder.{u1} α _inst_3))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (RightCancelMonoid.toOne.{u1} α (CancelMonoid.toRightCancelMonoid.{u1} α (CancelCommMonoid.toCancelMonoid.{u1} α (OrderedCancelCommMonoid.toCancelCommMonoid.{u1} α _inst_3)))))) x)) -> (Set.IsPwo.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCancelCommMonoid.toPartialOrder.{u1} α _inst_3)) s) -> (Set.IsPwo.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCancelCommMonoid.toPartialOrder.{u1} α _inst_3)) (SetLike.coe.{u1, u1} (Submonoid.{u1} α (Monoid.toMulOneClass.{u1} α (RightCancelMonoid.toMonoid.{u1} α (CancelMonoid.toRightCancelMonoid.{u1} α (CancelCommMonoid.toCancelMonoid.{u1} α (OrderedCancelCommMonoid.toCancelCommMonoid.{u1} α _inst_3)))))) α (Submonoid.instSetLikeSubmonoid.{u1} α (Monoid.toMulOneClass.{u1} α (RightCancelMonoid.toMonoid.{u1} α (CancelMonoid.toRightCancelMonoid.{u1} α (CancelCommMonoid.toCancelMonoid.{u1} α (OrderedCancelCommMonoid.toCancelCommMonoid.{u1} α _inst_3)))))) (Submonoid.closure.{u1} α (Monoid.toMulOneClass.{u1} α (RightCancelMonoid.toMonoid.{u1} α (CancelMonoid.toRightCancelMonoid.{u1} α (CancelCommMonoid.toCancelMonoid.{u1} α (OrderedCancelCommMonoid.toCancelCommMonoid.{u1} α _inst_3))))) s)))
Case conversion may be inaccurate. Consider using '#align set.is_pwo.submonoid_closure Set.IsPwo.submonoid_closureₓ'. -/
@[to_additive]
theorem submonoid_closure (hpos : ∀ x : α, x ∈ s → 1 ≤ x) (h : s.IsPwo) :
    IsPwo (Submonoid.closure s : Set α) :=
  by
  rw [Submonoid.closure_eq_image_prod]
  refine' (h.partially_well_ordered_on_sublist_forall₂ (· ≤ ·)).image_of_monotone_on _
  exact fun l1 hl1 l2 hl2 h12 => h12.prod_le_prod' fun x hx => hpos x <| hl2 x hx
#align set.is_pwo.submonoid_closure Set.IsPwo.submonoid_closure
#align set.is_pwo.add_submonoid_closure Set.IsPwo.addSubmonoid_closure

end Set.IsPwo

