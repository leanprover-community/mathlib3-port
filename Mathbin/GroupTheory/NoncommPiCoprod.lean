/-
Copyright (c) 2022 Joachim Breitner. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joachim Breitner

! This file was ported from Lean 3 source module group_theory.noncomm_pi_coprod
! leanprover-community/mathlib commit ef7acf407d265ad4081c8998687e994fa80ba70c
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.GroupTheory.OrderOfElement
import Mathbin.Data.Finset.NoncommProd
import Mathbin.Data.Fintype.BigOperators
import Mathbin.Data.Nat.Gcd.BigOperators
import Mathbin.Order.SupIndep

/-!
# Canonical homomorphism from a finite family of monoids

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines the construction of the canonical homomorphism from a family of monoids.

Given a family of morphisms `ϕ i : N i →* M` for each `i : ι` where elements in the
images of different morphisms commute, we obtain a canonical morphism
`monoid_hom.noncomm_pi_coprod : (Π i, N i) →* M` that coincides with `ϕ`

## Main definitions

* `monoid_hom.noncomm_pi_coprod : (Π i, N i) →* M` is the main homomorphism
* `subgroup.noncomm_pi_coprod : (Π i, H i) →* G` is the specialization to `H i : subgroup G`
   and the subgroup embedding.

## Main theorems

* `monoid_hom.noncomm_pi_coprod` coincides with `ϕ i` when restricted to `N i`
* `monoid_hom.noncomm_pi_coprod_mrange`: The range of `monoid_hom.noncomm_pi_coprod` is
  `⨆ (i : ι), (ϕ i).mrange`
* `monoid_hom.noncomm_pi_coprod_range`: The range of `monoid_hom.noncomm_pi_coprod` is
  `⨆ (i : ι), (ϕ i).range`
* `subgroup.noncomm_pi_coprod_range`: The range of `subgroup.noncomm_pi_coprod` is `⨆ (i : ι), H i`.
* `monoid_hom.injective_noncomm_pi_coprod_of_independent`: in the case of groups, `pi_hom.hom` is
   injective if the `ϕ` are injective and the ranges of the `ϕ` are independent.
* `monoid_hom.independent_range_of_coprime_order`: If the `N i` have coprime orders, then the ranges
   of the `ϕ` are independent.
* `subgroup.independent_of_coprime_order`: If commuting normal subgroups `H i` have coprime orders,
   they are independent.

-/


open BigOperators

namespace Subgroup

variable {G : Type _} [Group G]

/- warning: subgroup.eq_one_of_noncomm_prod_eq_one_of_independent -> Subgroup.eq_one_of_noncommProd_eq_one_of_independent is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Type.{u2}} (s : Finset.{u2} ι) (f : ι -> G) (comm : Set.Pairwise.{u2} ι ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s) (fun (a : ι) (b : ι) => Commute.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (f a) (f b))) (K : ι -> (Subgroup.{u1} G _inst_1)), (CompleteLattice.Independent.{succ u2, u1} ι (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1) K) -> (forall (x : ι), (Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) x s) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (f x) (K x))) -> (Eq.{succ u1} G (Finset.noncommProd.{u2, u1} ι G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) s f comm) (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))) -> (forall (i : ι), (Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) i s) -> (Eq.{succ u1} G (f i) (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Type.{u2}} (s : Finset.{u2} ι) (f : ι -> G) (comm : Set.Pairwise.{u2} ι (Finset.toSet.{u2} ι s) (fun (a : ι) (b : ι) => Commute.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (f a) (f b))) (K : ι -> (Subgroup.{u1} G _inst_1)), (CompleteLattice.Independent.{succ u2, u1} ι (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1) K) -> (forall (x : ι), (Membership.mem.{u2, u2} ι (Finset.{u2} ι) (Finset.instMembershipFinset.{u2} ι) x s) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (f x) (K x))) -> (Eq.{succ u1} G (Finset.noncommProd.{u2, u1} ι G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) s f comm) (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))))) -> (forall (i : ι), (Membership.mem.{u2, u2} ι (Finset.{u2} ι) (Finset.instMembershipFinset.{u2} ι) i s) -> (Eq.{succ u1} G (f i) (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align subgroup.eq_one_of_noncomm_prod_eq_one_of_independent Subgroup.eq_one_of_noncommProd_eq_one_of_independentₓ'. -/
/-- `finset.noncomm_prod` is “injective” in `f` if `f` maps into independent subgroups.  This
generalizes (one direction of) `subgroup.disjoint_iff_mul_eq_one`. -/
@[to_additive
      "`finset.noncomm_sum` is “injective” in `f` if `f` maps into independent subgroups.\nThis generalizes (one direction of) `add_subgroup.disjoint_iff_add_eq_zero`. "]
theorem eq_one_of_noncommProd_eq_one_of_independent {ι : Type _} (s : Finset ι) (f : ι → G) (comm)
    (K : ι → Subgroup G) (hind : CompleteLattice.Independent K) (hmem : ∀ x ∈ s, f x ∈ K x)
    (heq1 : s.noncommProd f comm = 1) : ∀ i ∈ s, f i = 1 := by
  classical
    revert heq1
    induction' s using Finset.induction_on with i s hnmem ih
    · simp
    · have hcomm := comm.mono (Finset.coe_subset.2 <| Finset.subset_insert _ _)
      simp only [Finset.forall_mem_insert] at hmem
      have hmem_bsupr : s.noncomm_prod f hcomm ∈ ⨆ i ∈ (s : Set ι), K i :=
        by
        refine' Subgroup.noncommProd_mem _ _ _
        intro x hx
        have : K x ≤ ⨆ i ∈ (s : Set ι), K i := le_iSup₂ x hx
        exact this (hmem.2 x hx)
      intro heq1
      rw [Finset.noncommProd_insert_of_not_mem _ _ _ _ hnmem] at heq1
      have hnmem' : i ∉ (s : Set ι) := by simpa
      obtain ⟨heq1i : f i = 1, heq1S : s.noncomm_prod f _ = 1⟩ :=
        subgroup.disjoint_iff_mul_eq_one.mp (hind.disjoint_bsupr hnmem') hmem.1 hmem_bsupr heq1
      intro i h
      simp only [Finset.mem_insert] at h
      rcases h with ⟨rfl | _⟩
      · exact heq1i
      · exact ih hcomm hmem.2 heq1S _ h
#align subgroup.eq_one_of_noncomm_prod_eq_one_of_independent Subgroup.eq_one_of_noncommProd_eq_one_of_independent
#align add_subgroup.eq_zero_of_noncomm_sum_eq_zero_of_independent AddSubgroup.eq_zero_of_noncommSum_eq_zero_of_independent

end Subgroup

section FamilyOfMonoids

variable {M : Type _} [Monoid M]

-- We have a family of monoids
-- The fintype assumption is not always used, but declared here, to keep things in order
variable {ι : Type _} [hdec : DecidableEq ι] [Fintype ι]

variable {N : ι → Type _} [∀ i, Monoid (N i)]

-- And morphisms ϕ into G
variable (ϕ : ∀ i : ι, N i →* M)

-- We assume that the elements of different morphism commute
variable (hcomm : Pairwise fun i j => ∀ x y, Commute (ϕ i x) (ϕ j y))

include hcomm

-- We use `f` and `g` to denote elements of `Π (i : ι), N i`
variable (f g : ∀ i : ι, N i)

namespace MonoidHom

/- warning: monoid_hom.noncomm_pi_coprod -> MonoidHom.noncommPiCoprod is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {ι : Type.{u2}} [_inst_2 : Fintype.{u2} ι] {N : ι -> Type.{u3}} [_inst_3 : forall (i : ι), Monoid.{u3} (N i)] (ϕ : forall (i : ι), MonoidHom.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)), (Pairwise.{u2} ι (fun (i : ι) (j : ι) => forall (x : N i) (y : N j), Commute.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (coeFn.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (MonoidHom.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)) (fun (_x : MonoidHom.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)) => (N i) -> M) (MonoidHom.hasCoeToFun.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)) (ϕ i) x) (coeFn.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (MonoidHom.{u3, u1} (N j) M (Monoid.toMulOneClass.{u3} (N j) (_inst_3 j)) (Monoid.toMulOneClass.{u1} M _inst_1)) (fun (_x : MonoidHom.{u3, u1} (N j) M (Monoid.toMulOneClass.{u3} (N j) (_inst_3 j)) (Monoid.toMulOneClass.{u1} M _inst_1)) => (N j) -> M) (MonoidHom.hasCoeToFun.{u3, u1} (N j) M (Monoid.toMulOneClass.{u3} (N j) (_inst_3 j)) (Monoid.toMulOneClass.{u1} M _inst_1)) (ϕ j) y))) -> (MonoidHom.{max u2 u3, u1} (forall (i : ι), N i) M (Pi.mulOneClass.{u2, u3} ι (fun (i : ι) => N i) (fun (i : ι) => Monoid.toMulOneClass.{u3} (N i) (_inst_3 i))) (Monoid.toMulOneClass.{u1} M _inst_1))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {ι : Type.{u2}} [_inst_2 : Fintype.{u2} ι] {N : ι -> Type.{u3}} [_inst_3 : forall (i : ι), Monoid.{u3} (N i)] (ϕ : forall (i : ι), MonoidHom.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)), (Pairwise.{u2} ι (fun (i : ι) (j : ι) => forall (x : N i) (y : N j), Commute.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N i) => M) x) (MulOneClass.toMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N i) => M) x) (Monoid.toMulOneClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N i) => M) x) _inst_1)) (FunLike.coe.{max (succ u1) (succ u3), succ u3, succ u1} (MonoidHom.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)) (N i) (fun (_x : N i) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N i) => M) _x) (MulHomClass.toFunLike.{max u1 u3, u3, u1} (MonoidHom.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)) (N i) M (MulOneClass.toMul.{u3} (N i) (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidHomClass.toMulHomClass.{max u1 u3, u3, u1} (MonoidHom.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)) (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1) (MonoidHom.monoidHomClass.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)))) (ϕ i) x) (FunLike.coe.{max (succ u1) (succ u3), succ u3, succ u1} (MonoidHom.{u3, u1} (N j) M (Monoid.toMulOneClass.{u3} (N j) (_inst_3 j)) (Monoid.toMulOneClass.{u1} M _inst_1)) (N j) (fun (_x : N j) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N j) => M) _x) (MulHomClass.toFunLike.{max u1 u3, u3, u1} (MonoidHom.{u3, u1} (N j) M (Monoid.toMulOneClass.{u3} (N j) (_inst_3 j)) (Monoid.toMulOneClass.{u1} M _inst_1)) (N j) M (MulOneClass.toMul.{u3} (N j) (Monoid.toMulOneClass.{u3} (N j) (_inst_3 j))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidHomClass.toMulHomClass.{max u1 u3, u3, u1} (MonoidHom.{u3, u1} (N j) M (Monoid.toMulOneClass.{u3} (N j) (_inst_3 j)) (Monoid.toMulOneClass.{u1} M _inst_1)) (N j) M (Monoid.toMulOneClass.{u3} (N j) (_inst_3 j)) (Monoid.toMulOneClass.{u1} M _inst_1) (MonoidHom.monoidHomClass.{u3, u1} (N j) M (Monoid.toMulOneClass.{u3} (N j) (_inst_3 j)) (Monoid.toMulOneClass.{u1} M _inst_1)))) (ϕ j) y))) -> (MonoidHom.{max u2 u3, u1} (forall (i : ι), N i) M (Pi.mulOneClass.{u2, u3} ι (fun (i : ι) => N i) (fun (i : ι) => Monoid.toMulOneClass.{u3} (N i) (_inst_3 i))) (Monoid.toMulOneClass.{u1} M _inst_1))
Case conversion may be inaccurate. Consider using '#align monoid_hom.noncomm_pi_coprod MonoidHom.noncommPiCoprodₓ'. -/
/-- The canonical homomorphism from a family of monoids. -/
@[to_additive
      "The canonical homomorphism from a family of additive monoids.\n\nSee also `linear_map.lsum` for a linear version without the commutativity assumption."]
def noncommPiCoprod : (∀ i : ι, N i) →* M
    where
  toFun f := Finset.univ.noncommProd (fun i => ϕ i (f i)) fun i _ j _ h => hcomm h _ _
  map_one' := by
    apply (Finset.noncommProd_eq_pow_card _ _ _ _ _).trans (one_pow _)
    simp
  map_mul' f g := by
    classical
      convert@Finset.noncommProd_mul_distrib _ _ _ _ (fun i => ϕ i (f i)) (fun i => ϕ i (g i)) _ _ _
      · ext i
        exact map_mul (ϕ i) (f i) (g i)
      · rintro i - j - h
        exact hcomm h _ _
#align monoid_hom.noncomm_pi_coprod MonoidHom.noncommPiCoprod
#align add_monoid_hom.noncomm_pi_coprod AddMonoidHom.noncommPiCoprod

variable {hcomm}

include hdec

/- warning: monoid_hom.noncomm_pi_coprod_mul_single -> MonoidHom.noncommPiCoprod_mulSingle is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {ι : Type.{u2}} [hdec : DecidableEq.{succ u2} ι] [_inst_2 : Fintype.{u2} ι] {N : ι -> Type.{u3}} [_inst_3 : forall (i : ι), Monoid.{u3} (N i)] (ϕ : forall (i : ι), MonoidHom.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)) {hcomm : Pairwise.{u2} ι (fun (i : ι) (j : ι) => forall (x : N i) (y : N j), Commute.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (coeFn.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (MonoidHom.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)) (fun (_x : MonoidHom.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)) => (N i) -> M) (MonoidHom.hasCoeToFun.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)) (ϕ i) x) (coeFn.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (MonoidHom.{u3, u1} (N j) M (Monoid.toMulOneClass.{u3} (N j) (_inst_3 j)) (Monoid.toMulOneClass.{u1} M _inst_1)) (fun (_x : MonoidHom.{u3, u1} (N j) M (Monoid.toMulOneClass.{u3} (N j) (_inst_3 j)) (Monoid.toMulOneClass.{u1} M _inst_1)) => (N j) -> M) (MonoidHom.hasCoeToFun.{u3, u1} (N j) M (Monoid.toMulOneClass.{u3} (N j) (_inst_3 j)) (Monoid.toMulOneClass.{u1} M _inst_1)) (ϕ j) y))} (i : ι) (y : N i), Eq.{succ u1} M (coeFn.{max (succ u1) (succ (max u2 u3)), max (succ (max u2 u3)) (succ u1)} (MonoidHom.{max u2 u3, u1} (forall (i : ι), (fun (i : ι) => N i) i) M (Pi.mulOneClass.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => N i) i) (fun (i : ι) => Monoid.toMulOneClass.{u3} ((fun (i : ι) => N i) i) ((fun (i : ι) => _inst_3 i) i))) (Monoid.toMulOneClass.{u1} M _inst_1)) (fun (_x : MonoidHom.{max u2 u3, u1} (forall (i : ι), (fun (i : ι) => N i) i) M (Pi.mulOneClass.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => N i) i) (fun (i : ι) => Monoid.toMulOneClass.{u3} ((fun (i : ι) => N i) i) ((fun (i : ι) => _inst_3 i) i))) (Monoid.toMulOneClass.{u1} M _inst_1)) => (forall (i : ι), (fun (i : ι) => N i) i) -> M) (MonoidHom.hasCoeToFun.{max u2 u3, u1} (forall (i : ι), (fun (i : ι) => N i) i) M (Pi.mulOneClass.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => N i) i) (fun (i : ι) => Monoid.toMulOneClass.{u3} ((fun (i : ι) => N i) i) ((fun (i : ι) => _inst_3 i) i))) (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidHom.noncommPiCoprod.{u1, u2, u3} M _inst_1 ι _inst_2 (fun (i : ι) => N i) (fun (i : ι) => _inst_3 i) ϕ hcomm) (Pi.mulSingle.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => N i) i) (fun (a : ι) (b : ι) => hdec a b) (fun (i : ι) => MulOneClass.toHasOne.{u3} ((fun (i : ι) => N i) i) (Monoid.toMulOneClass.{u3} ((fun (i : ι) => N i) i) (_inst_3 i))) i y)) (coeFn.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (MonoidHom.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)) (fun (_x : MonoidHom.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)) => (N i) -> M) (MonoidHom.hasCoeToFun.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)) (ϕ i) y)
but is expected to have type
  forall {M : Type.{u3}} [_inst_1 : Monoid.{u3} M] {ι : Type.{u2}} [hdec : DecidableEq.{succ u2} ι] [_inst_2 : Fintype.{u2} ι] {N : ι -> Type.{u1}} [_inst_3 : forall (i : ι), Monoid.{u1} (N i)] (ϕ : forall (i : ι), MonoidHom.{u1, u3} (N i) M (Monoid.toMulOneClass.{u1} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u3} M _inst_1)) {hcomm : Pairwise.{u2} ι (fun (i : ι) (j : ι) => forall (x : N i) (y : N j), Commute.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N i) => M) x) (MulOneClass.toMul.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N i) => M) x) (Monoid.toMulOneClass.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N i) => M) x) _inst_1)) (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (MonoidHom.{u1, u3} (N i) M (Monoid.toMulOneClass.{u1} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u3} M _inst_1)) (N i) (fun (_x : N i) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N i) => M) _x) (MulHomClass.toFunLike.{max u3 u1, u1, u3} (MonoidHom.{u1, u3} (N i) M (Monoid.toMulOneClass.{u1} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u3} M _inst_1)) (N i) M (MulOneClass.toMul.{u1} (N i) (Monoid.toMulOneClass.{u1} (N i) (_inst_3 i))) (MulOneClass.toMul.{u3} M (Monoid.toMulOneClass.{u3} M _inst_1)) (MonoidHomClass.toMulHomClass.{max u3 u1, u1, u3} (MonoidHom.{u1, u3} (N i) M (Monoid.toMulOneClass.{u1} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u3} M _inst_1)) (N i) M (Monoid.toMulOneClass.{u1} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u3} M _inst_1) (MonoidHom.monoidHomClass.{u1, u3} (N i) M (Monoid.toMulOneClass.{u1} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u3} M _inst_1)))) (ϕ i) x) (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (MonoidHom.{u1, u3} (N j) M (Monoid.toMulOneClass.{u1} (N j) (_inst_3 j)) (Monoid.toMulOneClass.{u3} M _inst_1)) (N j) (fun (_x : N j) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N j) => M) _x) (MulHomClass.toFunLike.{max u3 u1, u1, u3} (MonoidHom.{u1, u3} (N j) M (Monoid.toMulOneClass.{u1} (N j) (_inst_3 j)) (Monoid.toMulOneClass.{u3} M _inst_1)) (N j) M (MulOneClass.toMul.{u1} (N j) (Monoid.toMulOneClass.{u1} (N j) (_inst_3 j))) (MulOneClass.toMul.{u3} M (Monoid.toMulOneClass.{u3} M _inst_1)) (MonoidHomClass.toMulHomClass.{max u3 u1, u1, u3} (MonoidHom.{u1, u3} (N j) M (Monoid.toMulOneClass.{u1} (N j) (_inst_3 j)) (Monoid.toMulOneClass.{u3} M _inst_1)) (N j) M (Monoid.toMulOneClass.{u1} (N j) (_inst_3 j)) (Monoid.toMulOneClass.{u3} M _inst_1) (MonoidHom.monoidHomClass.{u1, u3} (N j) M (Monoid.toMulOneClass.{u1} (N j) (_inst_3 j)) (Monoid.toMulOneClass.{u3} M _inst_1)))) (ϕ j) y))} (i : ι) (y : N i), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : forall (i : ι), N i) => M) (Pi.mulSingle.{u2, u1} ι (fun (i : ι) => N i) (fun (a : ι) (b : ι) => hdec a b) (fun (i : ι) => Monoid.toOne.{u1} (N i) (_inst_3 i)) i y)) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u2) (succ u1), succ u3} (MonoidHom.{max u2 u1, u3} (forall (i : ι), N i) M (Pi.mulOneClass.{u2, u1} ι (fun (i : ι) => N i) (fun (i : ι) => Monoid.toMulOneClass.{u1} (N i) (_inst_3 i))) (Monoid.toMulOneClass.{u3} M _inst_1)) (forall (i : ι), N i) (fun (_x : forall (i : ι), N i) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : forall (i : ι), N i) => M) _x) (MulHomClass.toFunLike.{max (max u3 u2) u1, max u2 u1, u3} (MonoidHom.{max u2 u1, u3} (forall (i : ι), N i) M (Pi.mulOneClass.{u2, u1} ι (fun (i : ι) => N i) (fun (i : ι) => Monoid.toMulOneClass.{u1} (N i) (_inst_3 i))) (Monoid.toMulOneClass.{u3} M _inst_1)) (forall (i : ι), N i) M (MulOneClass.toMul.{max u2 u1} (forall (i : ι), N i) (Pi.mulOneClass.{u2, u1} ι (fun (i : ι) => N i) (fun (i : ι) => Monoid.toMulOneClass.{u1} (N i) (_inst_3 i)))) (MulOneClass.toMul.{u3} M (Monoid.toMulOneClass.{u3} M _inst_1)) (MonoidHomClass.toMulHomClass.{max (max u3 u2) u1, max u2 u1, u3} (MonoidHom.{max u2 u1, u3} (forall (i : ι), N i) M (Pi.mulOneClass.{u2, u1} ι (fun (i : ι) => N i) (fun (i : ι) => Monoid.toMulOneClass.{u1} (N i) (_inst_3 i))) (Monoid.toMulOneClass.{u3} M _inst_1)) (forall (i : ι), N i) M (Pi.mulOneClass.{u2, u1} ι (fun (i : ι) => N i) (fun (i : ι) => Monoid.toMulOneClass.{u1} (N i) (_inst_3 i))) (Monoid.toMulOneClass.{u3} M _inst_1) (MonoidHom.monoidHomClass.{max u2 u1, u3} (forall (i : ι), N i) M (Pi.mulOneClass.{u2, u1} ι (fun (i : ι) => N i) (fun (i : ι) => Monoid.toMulOneClass.{u1} (N i) (_inst_3 i))) (Monoid.toMulOneClass.{u3} M _inst_1)))) (MonoidHom.noncommPiCoprod.{u3, u2, u1} M _inst_1 ι _inst_2 (fun (i : ι) => N i) (fun (i : ι) => _inst_3 i) ϕ hcomm) (Pi.mulSingle.{u2, u1} ι (fun (i : ι) => N i) (fun (a : ι) (b : ι) => hdec a b) (fun (i : ι) => Monoid.toOne.{u1} (N i) (_inst_3 i)) i y)) (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (MonoidHom.{u1, u3} (N i) M (Monoid.toMulOneClass.{u1} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u3} M _inst_1)) (N i) (fun (_x : N i) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N i) => M) _x) (MulHomClass.toFunLike.{max u3 u1, u1, u3} (MonoidHom.{u1, u3} (N i) M (Monoid.toMulOneClass.{u1} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u3} M _inst_1)) (N i) M (MulOneClass.toMul.{u1} (N i) (Monoid.toMulOneClass.{u1} (N i) (_inst_3 i))) (MulOneClass.toMul.{u3} M (Monoid.toMulOneClass.{u3} M _inst_1)) (MonoidHomClass.toMulHomClass.{max u3 u1, u1, u3} (MonoidHom.{u1, u3} (N i) M (Monoid.toMulOneClass.{u1} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u3} M _inst_1)) (N i) M (Monoid.toMulOneClass.{u1} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u3} M _inst_1) (MonoidHom.monoidHomClass.{u1, u3} (N i) M (Monoid.toMulOneClass.{u1} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u3} M _inst_1)))) (ϕ i) y)
Case conversion may be inaccurate. Consider using '#align monoid_hom.noncomm_pi_coprod_mul_single MonoidHom.noncommPiCoprod_mulSingleₓ'. -/
@[simp, to_additive]
theorem noncommPiCoprod_mulSingle (i : ι) (y : N i) :
    noncommPiCoprod ϕ hcomm (Pi.mulSingle i y) = ϕ i y :=
  by
  change finset.univ.noncomm_prod (fun j => ϕ j (Pi.mulSingle i y j)) _ = ϕ i y
  simp (config := { singlePass := true }) only [← Finset.insert_erase (Finset.mem_univ i)]
  rw [Finset.noncommProd_insert_of_not_mem _ _ _ _ (Finset.not_mem_erase i _)]
  rw [Pi.mulSingle_eq_same]
  rw [Finset.noncommProd_eq_pow_card]
  · rw [one_pow]
    exact mul_one _
  · intro j hj
    simp only [Finset.mem_erase] at hj
    simp [hj]
#align monoid_hom.noncomm_pi_coprod_mul_single MonoidHom.noncommPiCoprod_mulSingle
#align add_monoid_hom.noncomm_pi_coprod_single AddMonoidHom.noncommPiCoprod_single

omit hcomm

/- warning: monoid_hom.noncomm_pi_coprod_equiv -> MonoidHom.noncommPiCoprodEquiv is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {ι : Type.{u2}} [hdec : DecidableEq.{succ u2} ι] [_inst_2 : Fintype.{u2} ι] {N : ι -> Type.{u3}} [_inst_3 : forall (i : ι), Monoid.{u3} (N i)], Equiv.{max 1 (succ u2) (succ u1) (succ u3), max (succ u1) (succ (max u2 u3))} (Subtype.{max (succ u2) (succ u1) (succ u3)} (forall (i : ι), MonoidHom.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)) (fun (ϕ : forall (i : ι), MonoidHom.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)) => Pairwise.{u2} ι (fun (i : ι) (j : ι) => forall (x : N i) (y : N j), Commute.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (coeFn.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (MonoidHom.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)) (fun (_x : MonoidHom.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)) => (N i) -> M) (MonoidHom.hasCoeToFun.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)) (ϕ i) x) (coeFn.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (MonoidHom.{u3, u1} (N j) M (Monoid.toMulOneClass.{u3} (N j) (_inst_3 j)) (Monoid.toMulOneClass.{u1} M _inst_1)) (fun (_x : MonoidHom.{u3, u1} (N j) M (Monoid.toMulOneClass.{u3} (N j) (_inst_3 j)) (Monoid.toMulOneClass.{u1} M _inst_1)) => (N j) -> M) (MonoidHom.hasCoeToFun.{u3, u1} (N j) M (Monoid.toMulOneClass.{u3} (N j) (_inst_3 j)) (Monoid.toMulOneClass.{u1} M _inst_1)) (ϕ j) y)))) (MonoidHom.{max u2 u3, u1} (forall (i : ι), N i) M (Pi.mulOneClass.{u2, u3} ι (fun (i : ι) => N i) (fun (i : ι) => Monoid.toMulOneClass.{u3} (N i) (_inst_3 i))) (Monoid.toMulOneClass.{u1} M _inst_1))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {ι : Type.{u2}} [hdec : DecidableEq.{succ u2} ι] [_inst_2 : Fintype.{u2} ι] {N : ι -> Type.{u3}} [_inst_3 : forall (i : ι), Monoid.{u3} (N i)], Equiv.{max 1 (max (succ u1) (succ u2)) (succ u3), max (succ u1) (succ (max u2 u3))} (Subtype.{max (max (succ u1) (succ u2)) (succ u3)} (forall (i : ι), MonoidHom.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)) (fun (ϕ : forall (i : ι), MonoidHom.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)) => Pairwise.{u2} ι (fun (i : ι) (j : ι) => forall (x : N i) (y : N j), Commute.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N i) => M) x) (MulOneClass.toMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N i) => M) x) (Monoid.toMulOneClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N i) => M) x) _inst_1)) (FunLike.coe.{max (succ u1) (succ u3), succ u3, succ u1} (MonoidHom.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)) (N i) (fun (_x : N i) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N i) => M) _x) (MulHomClass.toFunLike.{max u1 u3, u3, u1} (MonoidHom.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)) (N i) M (MulOneClass.toMul.{u3} (N i) (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidHomClass.toMulHomClass.{max u1 u3, u3, u1} (MonoidHom.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)) (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1) (MonoidHom.monoidHomClass.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)))) (ϕ i) x) (FunLike.coe.{max (succ u1) (succ u3), succ u3, succ u1} (MonoidHom.{u3, u1} (N j) M (Monoid.toMulOneClass.{u3} (N j) (_inst_3 j)) (Monoid.toMulOneClass.{u1} M _inst_1)) (N j) (fun (_x : N j) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N j) => M) _x) (MulHomClass.toFunLike.{max u1 u3, u3, u1} (MonoidHom.{u3, u1} (N j) M (Monoid.toMulOneClass.{u3} (N j) (_inst_3 j)) (Monoid.toMulOneClass.{u1} M _inst_1)) (N j) M (MulOneClass.toMul.{u3} (N j) (Monoid.toMulOneClass.{u3} (N j) (_inst_3 j))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidHomClass.toMulHomClass.{max u1 u3, u3, u1} (MonoidHom.{u3, u1} (N j) M (Monoid.toMulOneClass.{u3} (N j) (_inst_3 j)) (Monoid.toMulOneClass.{u1} M _inst_1)) (N j) M (Monoid.toMulOneClass.{u3} (N j) (_inst_3 j)) (Monoid.toMulOneClass.{u1} M _inst_1) (MonoidHom.monoidHomClass.{u3, u1} (N j) M (Monoid.toMulOneClass.{u3} (N j) (_inst_3 j)) (Monoid.toMulOneClass.{u1} M _inst_1)))) (ϕ j) y)))) (MonoidHom.{max u2 u3, u1} (forall (i : ι), N i) M (Pi.mulOneClass.{u2, u3} ι (fun (i : ι) => N i) (fun (i : ι) => Monoid.toMulOneClass.{u3} (N i) (_inst_3 i))) (Monoid.toMulOneClass.{u1} M _inst_1))
Case conversion may be inaccurate. Consider using '#align monoid_hom.noncomm_pi_coprod_equiv MonoidHom.noncommPiCoprodEquivₓ'. -/
/-- The universal property of `noncomm_pi_coprod` -/
@[to_additive "The universal property of `noncomm_pi_coprod`"]
def noncommPiCoprodEquiv :
    { ϕ : ∀ i, N i →* M // Pairwise fun i j => ∀ x y, Commute (ϕ i x) (ϕ j y) } ≃ ((∀ i, N i) →* M)
    where
  toFun ϕ := noncommPiCoprod ϕ.1 ϕ.2
  invFun f :=
    ⟨fun i => f.comp (MonoidHom.single N i), fun i j hij x y =>
      Commute.map (Pi.mulSingle_commute hij x y) f⟩
  left_inv ϕ := by
    ext
    simp
  right_inv f := pi_ext fun i x => by simp
#align monoid_hom.noncomm_pi_coprod_equiv MonoidHom.noncommPiCoprodEquiv
#align add_monoid_hom.noncomm_pi_coprod_equiv AddMonoidHom.noncommPiCoprodEquiv

omit hdec

include hcomm

/- warning: monoid_hom.noncomm_pi_coprod_mrange -> MonoidHom.noncommPiCoprod_mrange is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {ι : Type.{u2}} [_inst_2 : Fintype.{u2} ι] {N : ι -> Type.{u3}} [_inst_3 : forall (i : ι), Monoid.{u3} (N i)] (ϕ : forall (i : ι), MonoidHom.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)) {hcomm : Pairwise.{u2} ι (fun (i : ι) (j : ι) => forall (x : N i) (y : N j), Commute.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (coeFn.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (MonoidHom.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)) (fun (_x : MonoidHom.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)) => (N i) -> M) (MonoidHom.hasCoeToFun.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)) (ϕ i) x) (coeFn.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (MonoidHom.{u3, u1} (N j) M (Monoid.toMulOneClass.{u3} (N j) (_inst_3 j)) (Monoid.toMulOneClass.{u1} M _inst_1)) (fun (_x : MonoidHom.{u3, u1} (N j) M (Monoid.toMulOneClass.{u3} (N j) (_inst_3 j)) (Monoid.toMulOneClass.{u1} M _inst_1)) => (N j) -> M) (MonoidHom.hasCoeToFun.{u3, u1} (N j) M (Monoid.toMulOneClass.{u3} (N j) (_inst_3 j)) (Monoid.toMulOneClass.{u1} M _inst_1)) (ϕ j) y))}, Eq.{succ u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidHom.mrange.{max u2 u3, u1, max u1 u2 u3} (forall (i : ι), N i) M (Pi.mulOneClass.{u2, u3} ι (fun (i : ι) => N i) (fun (i : ι) => Monoid.toMulOneClass.{u3} (N i) (_inst_3 i))) (Monoid.toMulOneClass.{u1} M _inst_1) (MonoidHom.{max u2 u3, u1} (forall (i : ι), N i) M (Pi.mulOneClass.{u2, u3} ι (fun (i : ι) => N i) (fun (i : ι) => Monoid.toMulOneClass.{u3} (N i) (_inst_3 i))) (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidHom.monoidHomClass.{max u2 u3, u1} (forall (i : ι), N i) M (Pi.mulOneClass.{u2, u3} ι (fun (i : ι) => N i) (fun (i : ι) => Monoid.toMulOneClass.{u3} (N i) (_inst_3 i))) (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidHom.noncommPiCoprod.{u1, u2, u3} M _inst_1 ι _inst_2 (fun (i : ι) => N i) (fun (i : ι) => _inst_3 i) ϕ hcomm)) (iSup.{u1, succ u2} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (ConditionallyCompleteLattice.toHasSup.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Submonoid.completeLattice.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)))) ι (fun (i : ι) => MonoidHom.mrange.{u3, u1, max u1 u3} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1) (MonoidHom.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidHom.monoidHomClass.{u3, u1} (N i) M (Monoid.toMulOneClass.{u3} (N i) (_inst_3 i)) (Monoid.toMulOneClass.{u1} M _inst_1)) (ϕ i)))
but is expected to have type
  forall {M : Type.{u3}} [_inst_1 : Monoid.{u3} M] {ι : Type.{u2}} [_inst_2 : DecidableEq.{succ u2} ι] [N : Fintype.{u2} ι] {_inst_3 : ι -> Type.{u1}} [ϕ : forall (i : ι), Monoid.{u1} (_inst_3 i)] (hcomm : forall (i : ι), MonoidHom.{u1, u3} (_inst_3 i) M (Monoid.toMulOneClass.{u1} (_inst_3 i) (ϕ i)) (Monoid.toMulOneClass.{u3} M _inst_1)) {hcomm_1 : Pairwise.{u2} ι (fun (i : ι) (j : ι) => forall (x : _inst_3 i) (y : _inst_3 j), Commute.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : _inst_3 i) => M) x) (MulOneClass.toMul.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : _inst_3 i) => M) x) (Monoid.toMulOneClass.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : _inst_3 i) => M) x) _inst_1)) (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (MonoidHom.{u1, u3} (_inst_3 i) M (Monoid.toMulOneClass.{u1} (_inst_3 i) (ϕ i)) (Monoid.toMulOneClass.{u3} M _inst_1)) (_inst_3 i) (fun (a : _inst_3 i) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : _inst_3 i) => M) a) (MulHomClass.toFunLike.{max u3 u1, u1, u3} (MonoidHom.{u1, u3} (_inst_3 i) M (Monoid.toMulOneClass.{u1} (_inst_3 i) (ϕ i)) (Monoid.toMulOneClass.{u3} M _inst_1)) (_inst_3 i) M (MulOneClass.toMul.{u1} (_inst_3 i) (Monoid.toMulOneClass.{u1} (_inst_3 i) (ϕ i))) (MulOneClass.toMul.{u3} M (Monoid.toMulOneClass.{u3} M _inst_1)) (MonoidHomClass.toMulHomClass.{max u3 u1, u1, u3} (MonoidHom.{u1, u3} (_inst_3 i) M (Monoid.toMulOneClass.{u1} (_inst_3 i) (ϕ i)) (Monoid.toMulOneClass.{u3} M _inst_1)) (_inst_3 i) M (Monoid.toMulOneClass.{u1} (_inst_3 i) (ϕ i)) (Monoid.toMulOneClass.{u3} M _inst_1) (MonoidHom.monoidHomClass.{u1, u3} (_inst_3 i) M (Monoid.toMulOneClass.{u1} (_inst_3 i) (ϕ i)) (Monoid.toMulOneClass.{u3} M _inst_1)))) (hcomm i) x) (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (MonoidHom.{u1, u3} (_inst_3 j) M (Monoid.toMulOneClass.{u1} (_inst_3 j) (ϕ j)) (Monoid.toMulOneClass.{u3} M _inst_1)) (_inst_3 j) (fun (a : _inst_3 j) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : _inst_3 j) => M) a) (MulHomClass.toFunLike.{max u3 u1, u1, u3} (MonoidHom.{u1, u3} (_inst_3 j) M (Monoid.toMulOneClass.{u1} (_inst_3 j) (ϕ j)) (Monoid.toMulOneClass.{u3} M _inst_1)) (_inst_3 j) M (MulOneClass.toMul.{u1} (_inst_3 j) (Monoid.toMulOneClass.{u1} (_inst_3 j) (ϕ j))) (MulOneClass.toMul.{u3} M (Monoid.toMulOneClass.{u3} M _inst_1)) (MonoidHomClass.toMulHomClass.{max u3 u1, u1, u3} (MonoidHom.{u1, u3} (_inst_3 j) M (Monoid.toMulOneClass.{u1} (_inst_3 j) (ϕ j)) (Monoid.toMulOneClass.{u3} M _inst_1)) (_inst_3 j) M (Monoid.toMulOneClass.{u1} (_inst_3 j) (ϕ j)) (Monoid.toMulOneClass.{u3} M _inst_1) (MonoidHom.monoidHomClass.{u1, u3} (_inst_3 j) M (Monoid.toMulOneClass.{u1} (_inst_3 j) (ϕ j)) (Monoid.toMulOneClass.{u3} M _inst_1)))) (hcomm j) y))}, Eq.{succ u3} (Submonoid.{u3} M (Monoid.toMulOneClass.{u3} M _inst_1)) (MonoidHom.mrange.{max u2 u1, u3, max (max u1 u2) u3} (forall (i : ι), _inst_3 i) M (Pi.mulOneClass.{u2, u1} ι (fun (i : ι) => _inst_3 i) (fun (i : ι) => Monoid.toMulOneClass.{u1} (_inst_3 i) (ϕ i))) (Monoid.toMulOneClass.{u3} M _inst_1) (MonoidHom.{max u2 u1, u3} (forall (i : ι), _inst_3 i) M (Pi.mulOneClass.{u2, u1} ι (fun (i : ι) => _inst_3 i) (fun (i : ι) => Monoid.toMulOneClass.{u1} (_inst_3 i) (ϕ i))) (Monoid.toMulOneClass.{u3} M _inst_1)) (MonoidHom.monoidHomClass.{max u2 u1, u3} (forall (i : ι), _inst_3 i) M (Pi.mulOneClass.{u2, u1} ι (fun (i : ι) => _inst_3 i) (fun (i : ι) => Monoid.toMulOneClass.{u1} (_inst_3 i) (ϕ i))) (Monoid.toMulOneClass.{u3} M _inst_1)) (MonoidHom.noncommPiCoprod.{u3, u2, u1} M _inst_1 ι N (fun (i : ι) => _inst_3 i) (fun (i : ι) => ϕ i) hcomm hcomm_1)) (iSup.{u3, succ u2} (Submonoid.{u3} M (Monoid.toMulOneClass.{u3} M _inst_1)) (ConditionallyCompleteLattice.toSupSet.{u3} (Submonoid.{u3} M (Monoid.toMulOneClass.{u3} M _inst_1)) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Submonoid.{u3} M (Monoid.toMulOneClass.{u3} M _inst_1)) (Submonoid.instCompleteLatticeSubmonoid.{u3} M (Monoid.toMulOneClass.{u3} M _inst_1)))) ι (fun (i : ι) => MonoidHom.mrange.{u1, u3, max u3 u1} (_inst_3 i) M (Monoid.toMulOneClass.{u1} (_inst_3 i) (ϕ i)) (Monoid.toMulOneClass.{u3} M _inst_1) (MonoidHom.{u1, u3} (_inst_3 i) M (Monoid.toMulOneClass.{u1} (_inst_3 i) (ϕ i)) (Monoid.toMulOneClass.{u3} M _inst_1)) (MonoidHom.monoidHomClass.{u1, u3} (_inst_3 i) M (Monoid.toMulOneClass.{u1} (_inst_3 i) (ϕ i)) (Monoid.toMulOneClass.{u3} M _inst_1)) (hcomm i)))
Case conversion may be inaccurate. Consider using '#align monoid_hom.noncomm_pi_coprod_mrange MonoidHom.noncommPiCoprod_mrangeₓ'. -/
@[to_additive]
theorem noncommPiCoprod_mrange : (noncommPiCoprod ϕ hcomm).mrange = ⨆ i : ι, (ϕ i).mrange := by
  classical
    apply le_antisymm
    · rintro x ⟨f, rfl⟩
      refine' Submonoid.noncommProd_mem _ _ _ _ _
      intro i hi
      apply Submonoid.mem_sSup_of_mem
      · use i
      simp
    · refine' iSup_le _
      rintro i x ⟨y, rfl⟩
      refine' ⟨Pi.mulSingle i y, noncomm_pi_coprod_mul_single _ _ _⟩
#align monoid_hom.noncomm_pi_coprod_mrange MonoidHom.noncommPiCoprod_mrange
#align add_monoid_hom.noncomm_pi_coprod_mrange AddMonoidHom.noncommPiCoprod_mrange

end MonoidHom

end FamilyOfMonoids

section FamilyOfGroups

variable {G : Type _} [Group G]

variable {ι : Type _} [hdec : DecidableEq ι] [hfin : Fintype ι]

variable {H : ι → Type _} [∀ i, Group (H i)]

variable (ϕ : ∀ i : ι, H i →* G)

variable {hcomm : ∀ i j : ι, i ≠ j → ∀ (x : H i) (y : H j), Commute (ϕ i x) (ϕ j y)}

include hcomm

-- We use `f` and `g` to denote elements of `Π (i : ι), H i`
variable (f g : ∀ i : ι, H i)

include hfin

namespace MonoidHom

/- warning: monoid_hom.noncomm_pi_coprod_range -> MonoidHom.noncommPiCoprod_range is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Type.{u2}} [hfin : Fintype.{u2} ι] {H : ι -> Type.{u3}} [_inst_2 : forall (i : ι), Group.{u3} (H i)] (ϕ : forall (i : ι), MonoidHom.{u3, u1} (H i) G (Monoid.toMulOneClass.{u3} (H i) (DivInvMonoid.toMonoid.{u3} (H i) (Group.toDivInvMonoid.{u3} (H i) (_inst_2 i)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) {hcomm : forall (i : ι) (j : ι), (Ne.{succ u2} ι i j) -> (forall (x : H i) (y : H j), Commute.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (coeFn.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (MonoidHom.{u3, u1} (H i) G (Monoid.toMulOneClass.{u3} (H i) (DivInvMonoid.toMonoid.{u3} (H i) (Group.toDivInvMonoid.{u3} (H i) (_inst_2 i)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{u3, u1} (H i) G (Monoid.toMulOneClass.{u3} (H i) (DivInvMonoid.toMonoid.{u3} (H i) (Group.toDivInvMonoid.{u3} (H i) (_inst_2 i)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => (H i) -> G) (MonoidHom.hasCoeToFun.{u3, u1} (H i) G (Monoid.toMulOneClass.{u3} (H i) (DivInvMonoid.toMonoid.{u3} (H i) (Group.toDivInvMonoid.{u3} (H i) (_inst_2 i)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (ϕ i) x) (coeFn.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (MonoidHom.{u3, u1} (H j) G (Monoid.toMulOneClass.{u3} (H j) (DivInvMonoid.toMonoid.{u3} (H j) (Group.toDivInvMonoid.{u3} (H j) (_inst_2 j)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{u3, u1} (H j) G (Monoid.toMulOneClass.{u3} (H j) (DivInvMonoid.toMonoid.{u3} (H j) (Group.toDivInvMonoid.{u3} (H j) (_inst_2 j)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => (H j) -> G) (MonoidHom.hasCoeToFun.{u3, u1} (H j) G (Monoid.toMulOneClass.{u3} (H j) (DivInvMonoid.toMonoid.{u3} (H j) (Group.toDivInvMonoid.{u3} (H j) (_inst_2 j)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (ϕ j) y))}, Eq.{succ u1} (Subgroup.{u1} G _inst_1) (MonoidHom.range.{max u2 u3, u1} (forall (i : ι), H i) (Pi.group.{u2, u3} ι (fun (i : ι) => H i) (fun (i : ι) => _inst_2 i)) G _inst_1 (MonoidHom.noncommPiCoprod.{u1, u2, u3} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) ι hfin (fun (i : ι) => H i) (fun (i : ι) => DivInvMonoid.toMonoid.{u3} (H i) (Group.toDivInvMonoid.{u3} (H i) (_inst_2 i))) ϕ hcomm)) (iSup.{u1, succ u2} (Subgroup.{u1} G _inst_1) (ConditionallyCompleteLattice.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))) ι (fun (i : ι) => MonoidHom.range.{u3, u1} (H i) (_inst_2 i) G _inst_1 (ϕ i)))
but is expected to have type
  forall {G : Type.{u3}} [_inst_1 : Group.{u3} G] {ι : Type.{u2}} [hfin : DecidableEq.{succ u2} ι] [H : Fintype.{u2} ι] {_inst_2 : ι -> Type.{u1}} [ϕ : forall (i : ι), Group.{u1} (_inst_2 i)] (hcomm : forall (i : ι), MonoidHom.{u1, u3} (_inst_2 i) G (Monoid.toMulOneClass.{u1} (_inst_2 i) (DivInvMonoid.toMonoid.{u1} (_inst_2 i) (Group.toDivInvMonoid.{u1} (_inst_2 i) (ϕ i)))) (Monoid.toMulOneClass.{u3} G (DivInvMonoid.toMonoid.{u3} G (Group.toDivInvMonoid.{u3} G _inst_1)))) {hcomm_1 : forall (i : ι) (j : ι), (Ne.{succ u2} ι i j) -> (forall (x : _inst_2 i) (y : _inst_2 j), Commute.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : _inst_2 i) => G) x) (MulOneClass.toMul.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : _inst_2 i) => G) x) (Monoid.toMulOneClass.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : _inst_2 i) => G) x) (DivInvMonoid.toMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : _inst_2 i) => G) x) (Group.toDivInvMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : _inst_2 i) => G) x) _inst_1)))) (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (MonoidHom.{u1, u3} (_inst_2 i) G (Monoid.toMulOneClass.{u1} (_inst_2 i) (DivInvMonoid.toMonoid.{u1} (_inst_2 i) (Group.toDivInvMonoid.{u1} (_inst_2 i) (ϕ i)))) (Monoid.toMulOneClass.{u3} G (DivInvMonoid.toMonoid.{u3} G (Group.toDivInvMonoid.{u3} G _inst_1)))) (_inst_2 i) (fun (a : _inst_2 i) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : _inst_2 i) => G) a) (MulHomClass.toFunLike.{max u3 u1, u1, u3} (MonoidHom.{u1, u3} (_inst_2 i) G (Monoid.toMulOneClass.{u1} (_inst_2 i) (DivInvMonoid.toMonoid.{u1} (_inst_2 i) (Group.toDivInvMonoid.{u1} (_inst_2 i) (ϕ i)))) (Monoid.toMulOneClass.{u3} G (DivInvMonoid.toMonoid.{u3} G (Group.toDivInvMonoid.{u3} G _inst_1)))) (_inst_2 i) G (MulOneClass.toMul.{u1} (_inst_2 i) (Monoid.toMulOneClass.{u1} (_inst_2 i) (DivInvMonoid.toMonoid.{u1} (_inst_2 i) (Group.toDivInvMonoid.{u1} (_inst_2 i) (ϕ i))))) (MulOneClass.toMul.{u3} G (Monoid.toMulOneClass.{u3} G (DivInvMonoid.toMonoid.{u3} G (Group.toDivInvMonoid.{u3} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u3 u1, u1, u3} (MonoidHom.{u1, u3} (_inst_2 i) G (Monoid.toMulOneClass.{u1} (_inst_2 i) (DivInvMonoid.toMonoid.{u1} (_inst_2 i) (Group.toDivInvMonoid.{u1} (_inst_2 i) (ϕ i)))) (Monoid.toMulOneClass.{u3} G (DivInvMonoid.toMonoid.{u3} G (Group.toDivInvMonoid.{u3} G _inst_1)))) (_inst_2 i) G (Monoid.toMulOneClass.{u1} (_inst_2 i) (DivInvMonoid.toMonoid.{u1} (_inst_2 i) (Group.toDivInvMonoid.{u1} (_inst_2 i) (ϕ i)))) (Monoid.toMulOneClass.{u3} G (DivInvMonoid.toMonoid.{u3} G (Group.toDivInvMonoid.{u3} G _inst_1))) (MonoidHom.monoidHomClass.{u1, u3} (_inst_2 i) G (Monoid.toMulOneClass.{u1} (_inst_2 i) (DivInvMonoid.toMonoid.{u1} (_inst_2 i) (Group.toDivInvMonoid.{u1} (_inst_2 i) (ϕ i)))) (Monoid.toMulOneClass.{u3} G (DivInvMonoid.toMonoid.{u3} G (Group.toDivInvMonoid.{u3} G _inst_1)))))) (hcomm i) x) (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (MonoidHom.{u1, u3} (_inst_2 j) G (Monoid.toMulOneClass.{u1} (_inst_2 j) (DivInvMonoid.toMonoid.{u1} (_inst_2 j) (Group.toDivInvMonoid.{u1} (_inst_2 j) (ϕ j)))) (Monoid.toMulOneClass.{u3} G (DivInvMonoid.toMonoid.{u3} G (Group.toDivInvMonoid.{u3} G _inst_1)))) (_inst_2 j) (fun (a : _inst_2 j) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : _inst_2 j) => G) a) (MulHomClass.toFunLike.{max u3 u1, u1, u3} (MonoidHom.{u1, u3} (_inst_2 j) G (Monoid.toMulOneClass.{u1} (_inst_2 j) (DivInvMonoid.toMonoid.{u1} (_inst_2 j) (Group.toDivInvMonoid.{u1} (_inst_2 j) (ϕ j)))) (Monoid.toMulOneClass.{u3} G (DivInvMonoid.toMonoid.{u3} G (Group.toDivInvMonoid.{u3} G _inst_1)))) (_inst_2 j) G (MulOneClass.toMul.{u1} (_inst_2 j) (Monoid.toMulOneClass.{u1} (_inst_2 j) (DivInvMonoid.toMonoid.{u1} (_inst_2 j) (Group.toDivInvMonoid.{u1} (_inst_2 j) (ϕ j))))) (MulOneClass.toMul.{u3} G (Monoid.toMulOneClass.{u3} G (DivInvMonoid.toMonoid.{u3} G (Group.toDivInvMonoid.{u3} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u3 u1, u1, u3} (MonoidHom.{u1, u3} (_inst_2 j) G (Monoid.toMulOneClass.{u1} (_inst_2 j) (DivInvMonoid.toMonoid.{u1} (_inst_2 j) (Group.toDivInvMonoid.{u1} (_inst_2 j) (ϕ j)))) (Monoid.toMulOneClass.{u3} G (DivInvMonoid.toMonoid.{u3} G (Group.toDivInvMonoid.{u3} G _inst_1)))) (_inst_2 j) G (Monoid.toMulOneClass.{u1} (_inst_2 j) (DivInvMonoid.toMonoid.{u1} (_inst_2 j) (Group.toDivInvMonoid.{u1} (_inst_2 j) (ϕ j)))) (Monoid.toMulOneClass.{u3} G (DivInvMonoid.toMonoid.{u3} G (Group.toDivInvMonoid.{u3} G _inst_1))) (MonoidHom.monoidHomClass.{u1, u3} (_inst_2 j) G (Monoid.toMulOneClass.{u1} (_inst_2 j) (DivInvMonoid.toMonoid.{u1} (_inst_2 j) (Group.toDivInvMonoid.{u1} (_inst_2 j) (ϕ j)))) (Monoid.toMulOneClass.{u3} G (DivInvMonoid.toMonoid.{u3} G (Group.toDivInvMonoid.{u3} G _inst_1)))))) (hcomm j) y))}, Eq.{succ u3} (Subgroup.{u3} G _inst_1) (MonoidHom.range.{max u2 u1, u3} (forall (i : ι), _inst_2 i) (Pi.group.{u2, u1} ι (fun (i : ι) => _inst_2 i) (fun (i : ι) => ϕ i)) G _inst_1 (MonoidHom.noncommPiCoprod.{u3, u2, u1} G (DivInvMonoid.toMonoid.{u3} G (Group.toDivInvMonoid.{u3} G _inst_1)) ι H (fun (i : ι) => _inst_2 i) (fun (i : ι) => DivInvMonoid.toMonoid.{u1} (_inst_2 i) (Group.toDivInvMonoid.{u1} (_inst_2 i) (ϕ i))) hcomm hcomm_1)) (iSup.{u3, succ u2} (Subgroup.{u3} G _inst_1) (ConditionallyCompleteLattice.toSupSet.{u3} (Subgroup.{u3} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Subgroup.{u3} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u3} G _inst_1))) ι (fun (i : ι) => MonoidHom.range.{u1, u3} (_inst_2 i) (ϕ i) G _inst_1 (hcomm i)))
Case conversion may be inaccurate. Consider using '#align monoid_hom.noncomm_pi_coprod_range MonoidHom.noncommPiCoprod_rangeₓ'. -/
-- The subgroup version of `noncomm_pi_coprod_mrange`
@[to_additive]
theorem noncommPiCoprod_range : (noncommPiCoprod ϕ hcomm).range = ⨆ i : ι, (ϕ i).range := by
  classical
    apply le_antisymm
    · rintro x ⟨f, rfl⟩
      refine' Subgroup.noncommProd_mem _ _ _
      intro i hi
      apply Subgroup.mem_sSup_of_mem
      · use i
      simp
    · refine' iSup_le _
      rintro i x ⟨y, rfl⟩
      refine' ⟨Pi.mulSingle i y, noncomm_pi_coprod_mul_single _ _ _⟩
#align monoid_hom.noncomm_pi_coprod_range MonoidHom.noncommPiCoprod_range
#align add_monoid_hom.noncomm_pi_coprod_range AddMonoidHom.noncommPiCoprod_range

/- warning: monoid_hom.injective_noncomm_pi_coprod_of_independent -> MonoidHom.injective_noncommPiCoprod_of_independent is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Type.{u2}} [hfin : Fintype.{u2} ι] {H : ι -> Type.{u3}} [_inst_2 : forall (i : ι), Group.{u3} (H i)] (ϕ : forall (i : ι), MonoidHom.{u3, u1} (H i) G (Monoid.toMulOneClass.{u3} (H i) (DivInvMonoid.toMonoid.{u3} (H i) (Group.toDivInvMonoid.{u3} (H i) (_inst_2 i)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) {hcomm : forall (i : ι) (j : ι), (Ne.{succ u2} ι i j) -> (forall (x : H i) (y : H j), Commute.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (coeFn.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (MonoidHom.{u3, u1} (H i) G (Monoid.toMulOneClass.{u3} (H i) (DivInvMonoid.toMonoid.{u3} (H i) (Group.toDivInvMonoid.{u3} (H i) (_inst_2 i)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{u3, u1} (H i) G (Monoid.toMulOneClass.{u3} (H i) (DivInvMonoid.toMonoid.{u3} (H i) (Group.toDivInvMonoid.{u3} (H i) (_inst_2 i)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => (H i) -> G) (MonoidHom.hasCoeToFun.{u3, u1} (H i) G (Monoid.toMulOneClass.{u3} (H i) (DivInvMonoid.toMonoid.{u3} (H i) (Group.toDivInvMonoid.{u3} (H i) (_inst_2 i)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (ϕ i) x) (coeFn.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (MonoidHom.{u3, u1} (H j) G (Monoid.toMulOneClass.{u3} (H j) (DivInvMonoid.toMonoid.{u3} (H j) (Group.toDivInvMonoid.{u3} (H j) (_inst_2 j)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{u3, u1} (H j) G (Monoid.toMulOneClass.{u3} (H j) (DivInvMonoid.toMonoid.{u3} (H j) (Group.toDivInvMonoid.{u3} (H j) (_inst_2 j)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => (H j) -> G) (MonoidHom.hasCoeToFun.{u3, u1} (H j) G (Monoid.toMulOneClass.{u3} (H j) (DivInvMonoid.toMonoid.{u3} (H j) (Group.toDivInvMonoid.{u3} (H j) (_inst_2 j)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (ϕ j) y))}, (CompleteLattice.Independent.{succ u2, u1} ι (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1) (fun (i : ι) => MonoidHom.range.{u3, u1} (H i) (_inst_2 i) G _inst_1 (ϕ i))) -> (forall (i : ι), Function.Injective.{succ u3, succ u1} (H i) G (coeFn.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (MonoidHom.{u3, u1} (H i) G (Monoid.toMulOneClass.{u3} (H i) (DivInvMonoid.toMonoid.{u3} (H i) (Group.toDivInvMonoid.{u3} (H i) (_inst_2 i)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{u3, u1} (H i) G (Monoid.toMulOneClass.{u3} (H i) (DivInvMonoid.toMonoid.{u3} (H i) (Group.toDivInvMonoid.{u3} (H i) (_inst_2 i)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => (H i) -> G) (MonoidHom.hasCoeToFun.{u3, u1} (H i) G (Monoid.toMulOneClass.{u3} (H i) (DivInvMonoid.toMonoid.{u3} (H i) (Group.toDivInvMonoid.{u3} (H i) (_inst_2 i)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (ϕ i))) -> (Function.Injective.{max (succ u2) (succ u3), succ u1} (forall (i : ι), (fun (i : ι) => H i) i) G (coeFn.{max (succ u1) (succ (max u2 u3)), max (succ (max u2 u3)) (succ u1)} (MonoidHom.{max u2 u3, u1} (forall (i : ι), (fun (i : ι) => H i) i) G (Pi.mulOneClass.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => H i) i) (fun (i : ι) => Monoid.toMulOneClass.{u3} ((fun (i : ι) => H i) i) ((fun (i : ι) => DivInvMonoid.toMonoid.{u3} (H i) (Group.toDivInvMonoid.{u3} (H i) (_inst_2 i))) i))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{max u2 u3, u1} (forall (i : ι), (fun (i : ι) => H i) i) G (Pi.mulOneClass.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => H i) i) (fun (i : ι) => Monoid.toMulOneClass.{u3} ((fun (i : ι) => H i) i) ((fun (i : ι) => DivInvMonoid.toMonoid.{u3} (H i) (Group.toDivInvMonoid.{u3} (H i) (_inst_2 i))) i))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => (forall (i : ι), (fun (i : ι) => H i) i) -> G) (MonoidHom.hasCoeToFun.{max u2 u3, u1} (forall (i : ι), (fun (i : ι) => H i) i) G (Pi.mulOneClass.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => H i) i) (fun (i : ι) => Monoid.toMulOneClass.{u3} ((fun (i : ι) => H i) i) ((fun (i : ι) => DivInvMonoid.toMonoid.{u3} (H i) (Group.toDivInvMonoid.{u3} (H i) (_inst_2 i))) i))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MonoidHom.noncommPiCoprod.{u1, u2, u3} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) ι hfin (fun (i : ι) => H i) (fun (i : ι) => DivInvMonoid.toMonoid.{u3} (H i) (Group.toDivInvMonoid.{u3} (H i) (_inst_2 i))) ϕ hcomm)))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {ι : Type.{u3}} [hfin : Fintype.{u3} ι] {H : ι -> Type.{u1}} [_inst_2 : forall (i : ι), Group.{u1} (H i)] (ϕ : forall (i : ι), MonoidHom.{u1, u2} (H i) G (Monoid.toMulOneClass.{u1} (H i) (DivInvMonoid.toMonoid.{u1} (H i) (Group.toDivInvMonoid.{u1} (H i) (_inst_2 i)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) {hcomm : forall (i : ι) (j : ι), (Ne.{succ u3} ι i j) -> (forall (x : H i) (y : H j), Commute.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : H i) => G) x) (MulOneClass.toMul.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : H i) => G) x) (Monoid.toMulOneClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : H i) => G) x) (DivInvMonoid.toMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : H i) => G) x) (Group.toDivInvMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : H i) => G) x) _inst_1)))) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (MonoidHom.{u1, u2} (H i) G (Monoid.toMulOneClass.{u1} (H i) (DivInvMonoid.toMonoid.{u1} (H i) (Group.toDivInvMonoid.{u1} (H i) (_inst_2 i)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (H i) (fun (_x : H i) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : H i) => G) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (MonoidHom.{u1, u2} (H i) G (Monoid.toMulOneClass.{u1} (H i) (DivInvMonoid.toMonoid.{u1} (H i) (Group.toDivInvMonoid.{u1} (H i) (_inst_2 i)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (H i) G (MulOneClass.toMul.{u1} (H i) (Monoid.toMulOneClass.{u1} (H i) (DivInvMonoid.toMonoid.{u1} (H i) (Group.toDivInvMonoid.{u1} (H i) (_inst_2 i))))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u1, u2} (MonoidHom.{u1, u2} (H i) G (Monoid.toMulOneClass.{u1} (H i) (DivInvMonoid.toMonoid.{u1} (H i) (Group.toDivInvMonoid.{u1} (H i) (_inst_2 i)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (H i) G (Monoid.toMulOneClass.{u1} (H i) (DivInvMonoid.toMonoid.{u1} (H i) (Group.toDivInvMonoid.{u1} (H i) (_inst_2 i)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (MonoidHom.monoidHomClass.{u1, u2} (H i) G (Monoid.toMulOneClass.{u1} (H i) (DivInvMonoid.toMonoid.{u1} (H i) (Group.toDivInvMonoid.{u1} (H i) (_inst_2 i)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))) (ϕ i) x) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (MonoidHom.{u1, u2} (H j) G (Monoid.toMulOneClass.{u1} (H j) (DivInvMonoid.toMonoid.{u1} (H j) (Group.toDivInvMonoid.{u1} (H j) (_inst_2 j)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (H j) (fun (_x : H j) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : H j) => G) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (MonoidHom.{u1, u2} (H j) G (Monoid.toMulOneClass.{u1} (H j) (DivInvMonoid.toMonoid.{u1} (H j) (Group.toDivInvMonoid.{u1} (H j) (_inst_2 j)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (H j) G (MulOneClass.toMul.{u1} (H j) (Monoid.toMulOneClass.{u1} (H j) (DivInvMonoid.toMonoid.{u1} (H j) (Group.toDivInvMonoid.{u1} (H j) (_inst_2 j))))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u1, u2} (MonoidHom.{u1, u2} (H j) G (Monoid.toMulOneClass.{u1} (H j) (DivInvMonoid.toMonoid.{u1} (H j) (Group.toDivInvMonoid.{u1} (H j) (_inst_2 j)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (H j) G (Monoid.toMulOneClass.{u1} (H j) (DivInvMonoid.toMonoid.{u1} (H j) (Group.toDivInvMonoid.{u1} (H j) (_inst_2 j)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (MonoidHom.monoidHomClass.{u1, u2} (H j) G (Monoid.toMulOneClass.{u1} (H j) (DivInvMonoid.toMonoid.{u1} (H j) (Group.toDivInvMonoid.{u1} (H j) (_inst_2 j)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))) (ϕ j) y))}, (CompleteLattice.Independent.{succ u3, u2} ι (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1) (fun (i : ι) => MonoidHom.range.{u1, u2} (H i) (_inst_2 i) G _inst_1 (ϕ i))) -> (forall (i : ι), Function.Injective.{succ u1, succ u2} (H i) G (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (MonoidHom.{u1, u2} (H i) G (Monoid.toMulOneClass.{u1} (H i) (DivInvMonoid.toMonoid.{u1} (H i) (Group.toDivInvMonoid.{u1} (H i) (_inst_2 i)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (H i) (fun (_x : H i) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : H i) => G) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (MonoidHom.{u1, u2} (H i) G (Monoid.toMulOneClass.{u1} (H i) (DivInvMonoid.toMonoid.{u1} (H i) (Group.toDivInvMonoid.{u1} (H i) (_inst_2 i)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (H i) G (MulOneClass.toMul.{u1} (H i) (Monoid.toMulOneClass.{u1} (H i) (DivInvMonoid.toMonoid.{u1} (H i) (Group.toDivInvMonoid.{u1} (H i) (_inst_2 i))))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u1, u2} (MonoidHom.{u1, u2} (H i) G (Monoid.toMulOneClass.{u1} (H i) (DivInvMonoid.toMonoid.{u1} (H i) (Group.toDivInvMonoid.{u1} (H i) (_inst_2 i)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (H i) G (Monoid.toMulOneClass.{u1} (H i) (DivInvMonoid.toMonoid.{u1} (H i) (Group.toDivInvMonoid.{u1} (H i) (_inst_2 i)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (MonoidHom.monoidHomClass.{u1, u2} (H i) G (Monoid.toMulOneClass.{u1} (H i) (DivInvMonoid.toMonoid.{u1} (H i) (Group.toDivInvMonoid.{u1} (H i) (_inst_2 i)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))) (ϕ i))) -> (Function.Injective.{max (succ u3) (succ u1), succ u2} (forall (i : ι), H i) G (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u1), max (succ u3) (succ u1), succ u2} (MonoidHom.{max u3 u1, u2} (forall (i : ι), H i) G (Pi.mulOneClass.{u3, u1} ι (fun (i : ι) => H i) (fun (i : ι) => Monoid.toMulOneClass.{u1} (H i) (DivInvMonoid.toMonoid.{u1} (H i) (Group.toDivInvMonoid.{u1} (H i) (_inst_2 i))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (forall (i : ι), H i) (fun (_x : forall (i : ι), H i) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : forall (i : ι), H i) => G) _x) (MulHomClass.toFunLike.{max (max u2 u3) u1, max u3 u1, u2} (MonoidHom.{max u3 u1, u2} (forall (i : ι), H i) G (Pi.mulOneClass.{u3, u1} ι (fun (i : ι) => H i) (fun (i : ι) => Monoid.toMulOneClass.{u1} (H i) (DivInvMonoid.toMonoid.{u1} (H i) (Group.toDivInvMonoid.{u1} (H i) (_inst_2 i))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (forall (i : ι), H i) G (MulOneClass.toMul.{max u3 u1} (forall (i : ι), H i) (Pi.mulOneClass.{u3, u1} ι (fun (i : ι) => H i) (fun (i : ι) => Monoid.toMulOneClass.{u1} (H i) (DivInvMonoid.toMonoid.{u1} (H i) (Group.toDivInvMonoid.{u1} (H i) (_inst_2 i)))))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max (max u2 u3) u1, max u3 u1, u2} (MonoidHom.{max u3 u1, u2} (forall (i : ι), H i) G (Pi.mulOneClass.{u3, u1} ι (fun (i : ι) => H i) (fun (i : ι) => Monoid.toMulOneClass.{u1} (H i) (DivInvMonoid.toMonoid.{u1} (H i) (Group.toDivInvMonoid.{u1} (H i) (_inst_2 i))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (forall (i : ι), H i) G (Pi.mulOneClass.{u3, u1} ι (fun (i : ι) => H i) (fun (i : ι) => Monoid.toMulOneClass.{u1} (H i) (DivInvMonoid.toMonoid.{u1} (H i) (Group.toDivInvMonoid.{u1} (H i) (_inst_2 i))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (MonoidHom.monoidHomClass.{max u3 u1, u2} (forall (i : ι), H i) G (Pi.mulOneClass.{u3, u1} ι (fun (i : ι) => H i) (fun (i : ι) => Monoid.toMulOneClass.{u1} (H i) (DivInvMonoid.toMonoid.{u1} (H i) (Group.toDivInvMonoid.{u1} (H i) (_inst_2 i))))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))) (MonoidHom.noncommPiCoprod.{u2, u3, u1} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)) ι hfin (fun (i : ι) => H i) (fun (i : ι) => DivInvMonoid.toMonoid.{u1} (H i) (Group.toDivInvMonoid.{u1} (H i) (_inst_2 i))) ϕ hcomm)))
Case conversion may be inaccurate. Consider using '#align monoid_hom.injective_noncomm_pi_coprod_of_independent MonoidHom.injective_noncommPiCoprod_of_independentₓ'. -/
@[to_additive]
theorem injective_noncommPiCoprod_of_independent
    (hind : CompleteLattice.Independent fun i => (ϕ i).range)
    (hinj : ∀ i, Function.Injective (ϕ i)) : Function.Injective (noncommPiCoprod ϕ hcomm) := by
  classical
    apply (MonoidHom.ker_eq_bot_iff _).mp
    apply eq_bot_iff.mpr
    intro f heq1
    change finset.univ.noncomm_prod (fun i => ϕ i (f i)) _ = 1 at heq1
    change f = 1
    have : ∀ i, i ∈ Finset.univ → ϕ i (f i) = 1 :=
      Subgroup.eq_one_of_noncommProd_eq_one_of_independent _ _ _ _ hind (by simp) heq1
    ext i
    apply hinj
    simp [this i (Finset.mem_univ i)]
#align monoid_hom.injective_noncomm_pi_coprod_of_independent MonoidHom.injective_noncommPiCoprod_of_independent
#align add_monoid_hom.injective_noncomm_pi_coprod_of_independent AddMonoidHom.injective_noncommPiCoprod_of_independent

variable (hcomm)

omit hfin

/- warning: monoid_hom.independent_range_of_coprime_order -> MonoidHom.independent_range_of_coprime_order is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Type.{u2}} {H : ι -> Type.{u3}} [_inst_2 : forall (i : ι), Group.{u3} (H i)] (ϕ : forall (i : ι), MonoidHom.{u3, u1} (H i) G (Monoid.toMulOneClass.{u3} (H i) (DivInvMonoid.toMonoid.{u3} (H i) (Group.toDivInvMonoid.{u3} (H i) (_inst_2 i)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))), (forall (i : ι) (j : ι), (Ne.{succ u2} ι i j) -> (forall (x : H i) (y : H j), Commute.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (coeFn.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (MonoidHom.{u3, u1} (H i) G (Monoid.toMulOneClass.{u3} (H i) (DivInvMonoid.toMonoid.{u3} (H i) (Group.toDivInvMonoid.{u3} (H i) (_inst_2 i)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{u3, u1} (H i) G (Monoid.toMulOneClass.{u3} (H i) (DivInvMonoid.toMonoid.{u3} (H i) (Group.toDivInvMonoid.{u3} (H i) (_inst_2 i)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => (H i) -> G) (MonoidHom.hasCoeToFun.{u3, u1} (H i) G (Monoid.toMulOneClass.{u3} (H i) (DivInvMonoid.toMonoid.{u3} (H i) (Group.toDivInvMonoid.{u3} (H i) (_inst_2 i)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (ϕ i) x) (coeFn.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (MonoidHom.{u3, u1} (H j) G (Monoid.toMulOneClass.{u3} (H j) (DivInvMonoid.toMonoid.{u3} (H j) (Group.toDivInvMonoid.{u3} (H j) (_inst_2 j)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{u3, u1} (H j) G (Monoid.toMulOneClass.{u3} (H j) (DivInvMonoid.toMonoid.{u3} (H j) (Group.toDivInvMonoid.{u3} (H j) (_inst_2 j)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => (H j) -> G) (MonoidHom.hasCoeToFun.{u3, u1} (H j) G (Monoid.toMulOneClass.{u3} (H j) (DivInvMonoid.toMonoid.{u3} (H j) (Group.toDivInvMonoid.{u3} (H j) (_inst_2 j)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (ϕ j) y))) -> (forall [_inst_3 : Finite.{succ u2} ι] [_inst_4 : forall (i : ι), Fintype.{u3} (H i)], (forall (i : ι) (j : ι), (Ne.{succ u2} ι i j) -> (Nat.coprime (Fintype.card.{u3} (H i) (_inst_4 i)) (Fintype.card.{u3} (H j) (_inst_4 j)))) -> (CompleteLattice.Independent.{succ u2, u1} ι (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1) (fun (i : ι) => MonoidHom.range.{u3, u1} (H i) (_inst_2 i) G _inst_1 (ϕ i))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Type.{u3}} [H : DecidableEq.{succ u3} ι] {_inst_2 : ι -> Type.{u2}} [ϕ : forall (i : ι), Group.{u2} (_inst_2 i)] (hcomm : forall (i : ι), MonoidHom.{u2, u1} (_inst_2 i) G (Monoid.toMulOneClass.{u2} (_inst_2 i) (DivInvMonoid.toMonoid.{u2} (_inst_2 i) (Group.toDivInvMonoid.{u2} (_inst_2 i) (ϕ i)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))), (forall (i : ι) (j : ι), (Ne.{succ u3} ι i j) -> (forall (x : _inst_2 i) (y : _inst_2 j), Commute.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : _inst_2 i) => G) x) (MulOneClass.toMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : _inst_2 i) => G) x) (Monoid.toMulOneClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : _inst_2 i) => G) x) (DivInvMonoid.toMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : _inst_2 i) => G) x) (Group.toDivInvMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : _inst_2 i) => G) x) _inst_1)))) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (MonoidHom.{u2, u1} (_inst_2 i) G (Monoid.toMulOneClass.{u2} (_inst_2 i) (DivInvMonoid.toMonoid.{u2} (_inst_2 i) (Group.toDivInvMonoid.{u2} (_inst_2 i) (ϕ i)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (_inst_2 i) (fun (a : _inst_2 i) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : _inst_2 i) => G) a) (MulHomClass.toFunLike.{max u1 u2, u2, u1} (MonoidHom.{u2, u1} (_inst_2 i) G (Monoid.toMulOneClass.{u2} (_inst_2 i) (DivInvMonoid.toMonoid.{u2} (_inst_2 i) (Group.toDivInvMonoid.{u2} (_inst_2 i) (ϕ i)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (_inst_2 i) G (MulOneClass.toMul.{u2} (_inst_2 i) (Monoid.toMulOneClass.{u2} (_inst_2 i) (DivInvMonoid.toMonoid.{u2} (_inst_2 i) (Group.toDivInvMonoid.{u2} (_inst_2 i) (ϕ i))))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u2, u1} (MonoidHom.{u2, u1} (_inst_2 i) G (Monoid.toMulOneClass.{u2} (_inst_2 i) (DivInvMonoid.toMonoid.{u2} (_inst_2 i) (Group.toDivInvMonoid.{u2} (_inst_2 i) (ϕ i)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (_inst_2 i) G (Monoid.toMulOneClass.{u2} (_inst_2 i) (DivInvMonoid.toMonoid.{u2} (_inst_2 i) (Group.toDivInvMonoid.{u2} (_inst_2 i) (ϕ i)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (MonoidHom.monoidHomClass.{u2, u1} (_inst_2 i) G (Monoid.toMulOneClass.{u2} (_inst_2 i) (DivInvMonoid.toMonoid.{u2} (_inst_2 i) (Group.toDivInvMonoid.{u2} (_inst_2 i) (ϕ i)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (hcomm i) x) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (MonoidHom.{u2, u1} (_inst_2 j) G (Monoid.toMulOneClass.{u2} (_inst_2 j) (DivInvMonoid.toMonoid.{u2} (_inst_2 j) (Group.toDivInvMonoid.{u2} (_inst_2 j) (ϕ j)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (_inst_2 j) (fun (a : _inst_2 j) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : _inst_2 j) => G) a) (MulHomClass.toFunLike.{max u1 u2, u2, u1} (MonoidHom.{u2, u1} (_inst_2 j) G (Monoid.toMulOneClass.{u2} (_inst_2 j) (DivInvMonoid.toMonoid.{u2} (_inst_2 j) (Group.toDivInvMonoid.{u2} (_inst_2 j) (ϕ j)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (_inst_2 j) G (MulOneClass.toMul.{u2} (_inst_2 j) (Monoid.toMulOneClass.{u2} (_inst_2 j) (DivInvMonoid.toMonoid.{u2} (_inst_2 j) (Group.toDivInvMonoid.{u2} (_inst_2 j) (ϕ j))))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u2, u1} (MonoidHom.{u2, u1} (_inst_2 j) G (Monoid.toMulOneClass.{u2} (_inst_2 j) (DivInvMonoid.toMonoid.{u2} (_inst_2 j) (Group.toDivInvMonoid.{u2} (_inst_2 j) (ϕ j)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (_inst_2 j) G (Monoid.toMulOneClass.{u2} (_inst_2 j) (DivInvMonoid.toMonoid.{u2} (_inst_2 j) (Group.toDivInvMonoid.{u2} (_inst_2 j) (ϕ j)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (MonoidHom.monoidHomClass.{u2, u1} (_inst_2 j) G (Monoid.toMulOneClass.{u2} (_inst_2 j) (DivInvMonoid.toMonoid.{u2} (_inst_2 j) (Group.toDivInvMonoid.{u2} (_inst_2 j) (ϕ j)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (hcomm j) y))) -> (forall [_inst_4 : Finite.{succ u3} ι] [hcoprime : forall (i : ι), Fintype.{u2} (_inst_2 i)], (forall (i : ι) (j : ι), (Ne.{succ u3} ι i j) -> (Nat.coprime (Fintype.card.{u2} (_inst_2 i) (hcoprime i)) (Fintype.card.{u2} (_inst_2 j) (hcoprime j)))) -> (CompleteLattice.Independent.{succ u3, u1} ι (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1) (fun (i : ι) => MonoidHom.range.{u2, u1} (_inst_2 i) (ϕ i) G _inst_1 (hcomm i))))
Case conversion may be inaccurate. Consider using '#align monoid_hom.independent_range_of_coprime_order MonoidHom.independent_range_of_coprime_orderₓ'. -/
@[to_additive]
theorem independent_range_of_coprime_order [Finite ι] [∀ i, Fintype (H i)]
    (hcoprime : ∀ i j, i ≠ j → Nat.coprime (Fintype.card (H i)) (Fintype.card (H j))) :
    CompleteLattice.Independent fun i => (ϕ i).range :=
  by
  cases nonempty_fintype ι
  classical
    rintro i
    rw [disjoint_iff_inf_le]
    rintro f ⟨hxi, hxp⟩
    dsimp at hxi hxp
    rw [iSup_subtype', ← noncomm_pi_coprod_range] at hxp
    rotate_left
    · intro _ _ hj
      apply hcomm
      exact hj ∘ Subtype.ext
    cases' hxp with g hgf
    cases' hxi with g' hg'f
    have hxi : orderOf f ∣ Fintype.card (H i) :=
      by
      rw [← hg'f]
      exact (orderOf_map_dvd _ _).trans orderOf_dvd_card_univ
    have hxp : orderOf f ∣ ∏ j : { j // j ≠ i }, Fintype.card (H j) :=
      by
      rw [← hgf, ← Fintype.card_pi]
      exact (orderOf_map_dvd _ _).trans orderOf_dvd_card_univ
    change f = 1
    rw [← pow_one f, ← orderOf_dvd_iff_pow_eq_one]
    convert← Nat.dvd_gcd hxp hxi
    rw [← Nat.coprime_iff_gcd_eq_one]
    apply Nat.coprime_prod_left
    intro j _
    apply hcoprime
    exact j.2
#align monoid_hom.independent_range_of_coprime_order MonoidHom.independent_range_of_coprime_order
#align add_monoid_hom.independent_range_of_coprime_order AddMonoidHom.independent_range_of_coprime_order

end MonoidHom

end FamilyOfGroups

namespace Subgroup

-- We have an family of subgroups
variable {G : Type _} [Group G]

variable {ι : Type _} [hdec : DecidableEq ι] [hfin : Fintype ι] {H : ι → Subgroup G}

-- Elements of `Π (i : ι), H i` are called `f` and `g` here
variable (f g : ∀ i : ι, H i)

section CommutingSubgroups

-- We assume that the elements of different subgroups commute
variable (hcomm : ∀ i j : ι, i ≠ j → ∀ x y : G, x ∈ H i → y ∈ H j → Commute x y)

include hcomm

/- warning: subgroup.commute_subtype_of_commute -> Subgroup.commute_subtype_of_commute is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Type.{u2}} {H : ι -> (Subgroup.{u1} G _inst_1)}, (forall (i : ι) (j : ι), (Ne.{succ u2} ι i j) -> (forall (x : G) (y : G), (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (H i)) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) y (H j)) -> (Commute.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) x y))) -> (forall (i : ι) (j : ι), (Ne.{succ u2} ι i j) -> (forall (x : coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H i)) (y : coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H j)), Commute.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H i)) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H i)) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H i)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H i)) (Subgroup.toGroup.{u1} G _inst_1 (H i))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H i)) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H i)) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H i)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H i)) (Subgroup.toGroup.{u1} G _inst_1 (H i))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H i)) -> G) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H i)) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H i)) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H i)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H i)) (Subgroup.toGroup.{u1} G _inst_1 (H i))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.subtype.{u1} G _inst_1 (H i)) x) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H j)) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H j)) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H j)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H j)) (Subgroup.toGroup.{u1} G _inst_1 (H j))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H j)) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H j)) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H j)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H j)) (Subgroup.toGroup.{u1} G _inst_1 (H j))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H j)) -> G) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H j)) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H j)) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H j)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H j)) (Subgroup.toGroup.{u1} G _inst_1 (H j))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.subtype.{u1} G _inst_1 (H j)) y)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Type.{u2}} {H : ι -> (Subgroup.{u1} G _inst_1)}, (forall (i : ι) (j : ι), (Ne.{succ u2} ι i j) -> (forall (x : G) (y : G), (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i)) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) y (H j)) -> (Commute.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) x y))) -> (forall (i : ι) (j : ι), (Ne.{succ u2} ι i j) -> (forall (x : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) (y : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H j))), Commute.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) => G) x) (MulOneClass.toMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) => G) x) (Monoid.toMulOneClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) => G) x) (DivInvMonoid.toMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) => G) x) (Group.toDivInvMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) => G) x) _inst_1)))) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (H i))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) (fun (_x : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) => G) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (H i))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) G (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (H i)))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (H i))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (H i))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (MonoidHom.monoidHomClass.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (H i))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (Subgroup.subtype.{u1} G _inst_1 (H i)) x) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H j))) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (H j))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H j))) (fun (_x : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H j))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H j))) => G) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H j))) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (H j))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H j))) G (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H j))) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (H j)))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H j))) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (H j))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H j))) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (H j))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (MonoidHom.monoidHomClass.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H j))) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (H j))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (Subgroup.subtype.{u1} G _inst_1 (H j)) y)))
Case conversion may be inaccurate. Consider using '#align subgroup.commute_subtype_of_commute Subgroup.commute_subtype_of_commuteₓ'. -/
@[to_additive]
theorem commute_subtype_of_commute (i j : ι) (hne : i ≠ j) :
    ∀ (x : H i) (y : H j), Commute ((H i).Subtype x) ((H j).Subtype y) :=
  by
  rintro ⟨x, hx⟩ ⟨y, hy⟩
  exact hcomm i j hne x y hx hy
#align subgroup.commute_subtype_of_commute Subgroup.commute_subtype_of_commute
#align add_subgroup.commute_subtype_of_commute AddSubgroup.commute_subtype_of_commute

include hfin

/- warning: subgroup.noncomm_pi_coprod -> Subgroup.noncommPiCoprod is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Type.{u2}} [hfin : Fintype.{u2} ι] {H : ι -> (Subgroup.{u1} G _inst_1)}, (forall (i : ι) (j : ι), (Ne.{succ u2} ι i j) -> (forall (x : G) (y : G), (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (H i)) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) y (H j)) -> (Commute.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) x y))) -> (MonoidHom.{max u2 u1, u1} (forall (i : ι), coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H i)) G (Pi.mulOneClass.{u2, u1} ι (fun (i : ι) => coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H i)) (fun (i : ι) => Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H i)) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H i)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H i)) (Subgroup.toGroup.{u1} G _inst_1 (H i)))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Type.{u2}} [hfin : Fintype.{u2} ι] {H : ι -> (Subgroup.{u1} G _inst_1)}, (forall (i : ι) (j : ι), (Ne.{succ u2} ι i j) -> (forall (x : G) (y : G), (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i)) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) y (H j)) -> (Commute.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) x y))) -> (MonoidHom.{max u1 u2, u1} (forall (i : ι), Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) G (Pi.mulOneClass.{u2, u1} ι (fun (i : ι) => Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) (fun (i : ι) => Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (H i)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))
Case conversion may be inaccurate. Consider using '#align subgroup.noncomm_pi_coprod Subgroup.noncommPiCoprodₓ'. -/
/-- The canonical homomorphism from a family of subgroups where elements from different subgroups
commute -/
@[to_additive
      "The canonical homomorphism from a family of additive subgroups where elements from\ndifferent subgroups commute"]
def noncommPiCoprod : (∀ i : ι, H i) →* G :=
  MonoidHom.noncommPiCoprod (fun i => (H i).Subtype) (commute_subtype_of_commute hcomm)
#align subgroup.noncomm_pi_coprod Subgroup.noncommPiCoprod
#align add_subgroup.noncomm_pi_coprod AddSubgroup.noncommPiCoprod

variable {hcomm}

include hdec

/- warning: subgroup.noncomm_pi_coprod_mul_single -> Subgroup.noncommPiCoprod_mulSingle is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Type.{u2}} [hdec : DecidableEq.{succ u2} ι] [hfin : Fintype.{u2} ι] {H : ι -> (Subgroup.{u1} G _inst_1)} {hcomm : forall (i : ι) (j : ι), (Ne.{succ u2} ι i j) -> (forall (x : G) (y : G), (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (H i)) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) y (H j)) -> (Commute.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) x y))} (i : ι) (y : coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H i)), Eq.{succ u1} G (coeFn.{max (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (MonoidHom.{max u2 u1, u1} (forall (i : ι), coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) G (Pi.mulOneClass.{u2, u1} ι (fun (i : ι) => coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) (fun (i : ι) => Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) (Subgroup.toGroup.{u1} G _inst_1 ((fun (i : ι) => H i) i)))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{max u2 u1, u1} (forall (i : ι), coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) G (Pi.mulOneClass.{u2, u1} ι (fun (i : ι) => coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) (fun (i : ι) => Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) (Subgroup.toGroup.{u1} G _inst_1 ((fun (i : ι) => H i) i)))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => (forall (i : ι), coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) -> G) (MonoidHom.hasCoeToFun.{max u2 u1, u1} (forall (i : ι), coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) G (Pi.mulOneClass.{u2, u1} ι (fun (i : ι) => coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) (fun (i : ι) => Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) (Subgroup.toGroup.{u1} G _inst_1 ((fun (i : ι) => H i) i)))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.noncommPiCoprod.{u1, u2} G _inst_1 ι hfin (fun (i : ι) => H i) hcomm) (Pi.mulSingle.{u2, u1} ι (fun (i : ι) => coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) (fun (a : ι) (b : ι) => hdec a b) (fun (i : ι) => Subgroup.one.{u1} G _inst_1 ((fun (i : ι) => H i) i)) i y)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H i)) G (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H i)) G (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H i)) G (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H i)) G (coeSubtype.{succ u1} G (fun (x : G) => Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (H i)))))) y)
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {ι : Type.{u1}} [hdec : DecidableEq.{succ u1} ι] [hfin : Fintype.{u1} ι] {H : ι -> (Subgroup.{u2} G _inst_1)} {hcomm : forall (i : ι) (j : ι), (Ne.{succ u1} ι i j) -> (forall (x : G) (y : G), (Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x (H i)) -> (Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) y (H j)) -> (Commute.{u2} G (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) x y))} (i : ι) (y : Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x (H i))), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : forall (i : ι), Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x (H i))) => G) (Pi.mulSingle.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x (H i))) (fun (a : ι) (b : ι) => hdec a b) (fun (i : ι) => Subgroup.one.{u2} G _inst_1 (H i)) i y)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), succ u2} (MonoidHom.{max u2 u1, u2} (forall (i : ι), Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x (H i))) G (Pi.mulOneClass.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x (H i))) (fun (i : ι) => Submonoid.toMulOneClass.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Subgroup.toSubmonoid.{u2} G _inst_1 (H i)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (forall (i : ι), Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x (H i))) (fun (_x : forall (i : ι), Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x (H i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : forall (i : ι), Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x (H i))) => G) _x) (MulHomClass.toFunLike.{max u2 u1, max u2 u1, u2} (MonoidHom.{max u2 u1, u2} (forall (i : ι), Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x (H i))) G (Pi.mulOneClass.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x (H i))) (fun (i : ι) => Submonoid.toMulOneClass.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Subgroup.toSubmonoid.{u2} G _inst_1 (H i)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (forall (i : ι), Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x (H i))) G (MulOneClass.toMul.{max u2 u1} (forall (i : ι), Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x (H i))) (Pi.mulOneClass.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x (H i))) (fun (i : ι) => Submonoid.toMulOneClass.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Subgroup.toSubmonoid.{u2} G _inst_1 (H i))))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u2 u1, max u2 u1, u2} (MonoidHom.{max u2 u1, u2} (forall (i : ι), Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x (H i))) G (Pi.mulOneClass.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x (H i))) (fun (i : ι) => Submonoid.toMulOneClass.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Subgroup.toSubmonoid.{u2} G _inst_1 (H i)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (forall (i : ι), Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x (H i))) G (Pi.mulOneClass.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x (H i))) (fun (i : ι) => Submonoid.toMulOneClass.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Subgroup.toSubmonoid.{u2} G _inst_1 (H i)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (MonoidHom.monoidHomClass.{max u2 u1, u2} (forall (i : ι), Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x (H i))) G (Pi.mulOneClass.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x (H i))) (fun (i : ι) => Submonoid.toMulOneClass.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Subgroup.toSubmonoid.{u2} G _inst_1 (H i)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))) (Subgroup.noncommPiCoprod.{u2, u1} G _inst_1 ι hfin (fun (i : ι) => H i) hcomm) (Pi.mulSingle.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x (H i))) (fun (a : ι) (b : ι) => hdec a b) (fun (i : ι) => Subgroup.one.{u2} G _inst_1 (H i)) i y)) (Subtype.val.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Set.{u2} G) (Set.instMembershipSet.{u2} G) x (SetLike.coe.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1) (H i))) y)
Case conversion may be inaccurate. Consider using '#align subgroup.noncomm_pi_coprod_mul_single Subgroup.noncommPiCoprod_mulSingleₓ'. -/
@[simp, to_additive]
theorem noncommPiCoprod_mulSingle (i : ι) (y : H i) :
    noncommPiCoprod hcomm (Pi.mulSingle i y) = y := by apply MonoidHom.noncommPiCoprod_mulSingle
#align subgroup.noncomm_pi_coprod_mul_single Subgroup.noncommPiCoprod_mulSingle
#align add_subgroup.noncomm_pi_coprod_single AddSubgroup.noncommPiCoprod_single

omit hdec

/- warning: subgroup.noncomm_pi_coprod_range -> Subgroup.noncommPiCoprod_range is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Type.{u2}} [hfin : Fintype.{u2} ι] {H : ι -> (Subgroup.{u1} G _inst_1)} {hcomm : forall (i : ι) (j : ι), (Ne.{succ u2} ι i j) -> (forall (x : G) (y : G), (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (H i)) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) y (H j)) -> (Commute.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) x y))}, Eq.{succ u1} (Subgroup.{u1} G _inst_1) (MonoidHom.range.{max u2 u1, u1} (forall (i : ι), coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H i)) (Pi.group.{u2, u1} ι (fun (i : ι) => coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H i)) (fun (i : ι) => Subgroup.toGroup.{u1} G _inst_1 (H i))) G _inst_1 (Subgroup.noncommPiCoprod.{u1, u2} G _inst_1 ι hfin (fun (i : ι) => H i) hcomm)) (iSup.{u1, succ u2} (Subgroup.{u1} G _inst_1) (ConditionallyCompleteLattice.toHasSup.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1))) ι (fun (i : ι) => H i))
but is expected to have type
  forall {G : Type.{u2}} [_inst_1 : Group.{u2} G] {ι : Type.{u1}} [hfin : DecidableEq.{succ u1} ι] [H : Fintype.{u1} ι] {hcomm : ι -> (Subgroup.{u2} G _inst_1)} {hcomm_1 : forall (i : ι) (j : ι), (Ne.{succ u1} ι i j) -> (forall (x : G) (y : G), (Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x (hcomm i)) -> (Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) y (hcomm j)) -> (Commute.{u2} G (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) x y))}, Eq.{succ u2} (Subgroup.{u2} G _inst_1) (MonoidHom.range.{max u2 u1, u2} (forall (i : ι), Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x (hcomm i))) (Pi.group.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} G (fun (x : G) => Membership.mem.{u2, u2} G (Subgroup.{u2} G _inst_1) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u2} G _inst_1)) x (hcomm i))) (fun (i : ι) => Subgroup.toGroup.{u2} G _inst_1 (hcomm i))) G _inst_1 (Subgroup.noncommPiCoprod.{u2, u1} G _inst_1 ι H (fun (i : ι) => hcomm i) hcomm_1)) (iSup.{u2, succ u1} (Subgroup.{u2} G _inst_1) (ConditionallyCompleteLattice.toSupSet.{u2} (Subgroup.{u2} G _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Subgroup.{u2} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u2} G _inst_1))) ι (fun (i : ι) => hcomm i))
Case conversion may be inaccurate. Consider using '#align subgroup.noncomm_pi_coprod_range Subgroup.noncommPiCoprod_rangeₓ'. -/
@[to_additive]
theorem noncommPiCoprod_range : (noncommPiCoprod hcomm).range = ⨆ i : ι, H i := by
  simp [noncomm_pi_coprod, MonoidHom.noncommPiCoprod_range]
#align subgroup.noncomm_pi_coprod_range Subgroup.noncommPiCoprod_range
#align add_subgroup.noncomm_pi_coprod_range AddSubgroup.noncommPiCoprod_range

/- warning: subgroup.injective_noncomm_pi_coprod_of_independent -> Subgroup.injective_noncommPiCoprod_of_independent is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Type.{u2}} [hfin : Fintype.{u2} ι] {H : ι -> (Subgroup.{u1} G _inst_1)} {hcomm : forall (i : ι) (j : ι), (Ne.{succ u2} ι i j) -> (forall (x : G) (y : G), (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (H i)) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) y (H j)) -> (Commute.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) x y))}, (CompleteLattice.Independent.{succ u2, u1} ι (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1) H) -> (Function.Injective.{max (succ u2) (succ u1), succ u1} (forall (i : ι), coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) G (coeFn.{max (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (MonoidHom.{max u2 u1, u1} (forall (i : ι), coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) G (Pi.mulOneClass.{u2, u1} ι (fun (i : ι) => coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) (fun (i : ι) => Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) (Subgroup.toGroup.{u1} G _inst_1 ((fun (i : ι) => H i) i)))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{max u2 u1, u1} (forall (i : ι), coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) G (Pi.mulOneClass.{u2, u1} ι (fun (i : ι) => coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) (fun (i : ι) => Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) (Subgroup.toGroup.{u1} G _inst_1 ((fun (i : ι) => H i) i)))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => (forall (i : ι), coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) -> G) (MonoidHom.hasCoeToFun.{max u2 u1, u1} (forall (i : ι), coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) G (Pi.mulOneClass.{u2, u1} ι (fun (i : ι) => coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) (fun (i : ι) => Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) ((fun (i : ι) => H i) i)) (Subgroup.toGroup.{u1} G _inst_1 ((fun (i : ι) => H i) i)))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.noncommPiCoprod.{u1, u2} G _inst_1 ι hfin (fun (i : ι) => H i) hcomm)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Type.{u2}} [hfin : Fintype.{u2} ι] {H : ι -> (Subgroup.{u1} G _inst_1)} {hcomm : forall (i : ι) (j : ι), (Ne.{succ u2} ι i j) -> (forall (x : G) (y : G), (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i)) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) y (H j)) -> (Commute.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) x y))}, (CompleteLattice.Independent.{succ u2, u1} ι (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1) H) -> (Function.Injective.{max (succ u1) (succ u2), succ u1} (forall (i : ι), Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) G (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), succ u1} (MonoidHom.{max u1 u2, u1} (forall (i : ι), Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) G (Pi.mulOneClass.{u2, u1} ι (fun (i : ι) => Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) (fun (i : ι) => Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (H i)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (forall (i : ι), Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) (fun (_x : forall (i : ι), Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : forall (i : ι), Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) => G) _x) (MulHomClass.toFunLike.{max u1 u2, max u1 u2, u1} (MonoidHom.{max u1 u2, u1} (forall (i : ι), Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) G (Pi.mulOneClass.{u2, u1} ι (fun (i : ι) => Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) (fun (i : ι) => Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (H i)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (forall (i : ι), Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) G (MulOneClass.toMul.{max u1 u2} (forall (i : ι), Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) (Pi.mulOneClass.{u2, u1} ι (fun (i : ι) => Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) (fun (i : ι) => Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (H i))))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u1 u2, max u1 u2, u1} (MonoidHom.{max u1 u2, u1} (forall (i : ι), Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) G (Pi.mulOneClass.{u2, u1} ι (fun (i : ι) => Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) (fun (i : ι) => Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (H i)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (forall (i : ι), Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) G (Pi.mulOneClass.{u2, u1} ι (fun (i : ι) => Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) (fun (i : ι) => Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (H i)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (MonoidHom.monoidHomClass.{max u1 u2, u1} (forall (i : ι), Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) G (Pi.mulOneClass.{u2, u1} ι (fun (i : ι) => Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (H i))) (fun (i : ι) => Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (H i)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (Subgroup.noncommPiCoprod.{u1, u2} G _inst_1 ι hfin (fun (i : ι) => H i) hcomm)))
Case conversion may be inaccurate. Consider using '#align subgroup.injective_noncomm_pi_coprod_of_independent Subgroup.injective_noncommPiCoprod_of_independentₓ'. -/
@[to_additive]
theorem injective_noncommPiCoprod_of_independent (hind : CompleteLattice.Independent H) :
    Function.Injective (noncommPiCoprod hcomm) :=
  by
  apply MonoidHom.injective_noncommPiCoprod_of_independent
  · simpa using hind
  · intro i
    exact Subtype.coe_injective
#align subgroup.injective_noncomm_pi_coprod_of_independent Subgroup.injective_noncommPiCoprod_of_independent
#align add_subgroup.injective_noncomm_pi_coprod_of_independent AddSubgroup.injective_noncommPiCoprod_of_independent

variable (hcomm)

omit hfin

/- warning: subgroup.independent_of_coprime_order -> Subgroup.independent_of_coprime_order is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Type.{u2}} {H : ι -> (Subgroup.{u1} G _inst_1)}, (forall (i : ι) (j : ι), (Ne.{succ u2} ι i j) -> (forall (x : G) (y : G), (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) x (H i)) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) y (H j)) -> (Commute.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) x y))) -> (forall [_inst_2 : Finite.{succ u2} ι] [_inst_3 : forall (i : ι), Fintype.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H i))], (forall (i : ι) (j : ι), (Ne.{succ u2} ι i j) -> (Nat.coprime (Fintype.card.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H i)) (_inst_3 i)) (Fintype.card.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (H j)) (_inst_3 j)))) -> (CompleteLattice.Independent.{succ u2, u1} ι (Subgroup.{u1} G _inst_1) (Subgroup.completeLattice.{u1} G _inst_1) H))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {ι : Type.{u2}} [H : DecidableEq.{succ u2} ι] {hcomm : ι -> (Subgroup.{u1} G _inst_1)}, (forall (i : ι) (j : ι), (Ne.{succ u2} ι i j) -> (forall (x : G) (y : G), (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (hcomm i)) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) y (hcomm j)) -> (Commute.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) x y))) -> (forall [_inst_3 : Finite.{succ u2} ι] [hcoprime : forall (i : ι), Fintype.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (hcomm i)))], (forall (i : ι) (j : ι), (Ne.{succ u2} ι i j) -> (Nat.coprime (Fintype.card.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (hcomm i))) (hcoprime i)) (Fintype.card.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (hcomm j))) (hcoprime j)))) -> (CompleteLattice.Independent.{succ u2, u1} ι (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1) hcomm))
Case conversion may be inaccurate. Consider using '#align subgroup.independent_of_coprime_order Subgroup.independent_of_coprime_orderₓ'. -/
@[to_additive]
theorem independent_of_coprime_order [Finite ι] [∀ i, Fintype (H i)]
    (hcoprime : ∀ i j, i ≠ j → Nat.coprime (Fintype.card (H i)) (Fintype.card (H j))) :
    CompleteLattice.Independent H := by
  simpa using
    MonoidHom.independent_range_of_coprime_order (fun i => (H i).Subtype)
      (commute_subtype_of_commute hcomm) hcoprime
#align subgroup.independent_of_coprime_order Subgroup.independent_of_coprime_order
#align add_subgroup.independent_of_coprime_order AddSubgroup.independent_of_coprime_order

end CommutingSubgroups

end Subgroup

