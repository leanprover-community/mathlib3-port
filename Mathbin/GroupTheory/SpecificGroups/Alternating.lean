/-
Copyright (c) 2021 Aaron Anderson. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Aaron Anderson

! This file was ported from Lean 3 source module group_theory.specific_groups.alternating
! leanprover-community/mathlib commit 9a48a083b390d9b84a71efbdc4e8dfa26a687104
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Group.ConjFinite
import Mathbin.GroupTheory.Perm.Fin
import Mathbin.GroupTheory.Subgroup.Simple
import Mathbin.Tactic.IntervalCases

/-!
# Alternating Groups

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

The alternating group on a finite type `α` is the subgroup of the permutation group `perm α`
consisting of the even permutations.

## Main definitions

* `alternating_group α` is the alternating group on `α`, defined as a `subgroup (perm α)`.

## Main results
* `two_mul_card_alternating_group` shows that the alternating group is half as large as
  the permutation group it is a subgroup of.

* `closure_three_cycles_eq_alternating` shows that the alternating group is
  generated by 3-cycles.

* `alternating_group.is_simple_group_five` shows that the alternating group on `fin 5` is simple.
  The proof shows that the normal closure of any non-identity element of this group contains a
  3-cycle.

## Tags
alternating group permutation


## TODO
* Show that `alternating_group α` is simple if and only if `fintype.card α ≠ 4`.

-/


open Equiv Equiv.Perm Subgroup Fintype

variable (α : Type _) [Fintype α] [DecidableEq α]

#print alternatingGroup /-
/-- The alternating group on a finite type, realized as a subgroup of `equiv.perm`.
  For $A_n$, use `alternating_group (fin n)`. -/
def alternatingGroup : Subgroup (Perm α) :=
  sign.ker deriving Fintype
#align alternating_group alternatingGroup
-/

instance [Subsingleton α] : Unique (alternatingGroup α) :=
  ⟨⟨1⟩, fun ⟨p, hp⟩ => Subtype.eq (Subsingleton.elim p _)⟩

variable {α}

/- warning: alternating_group_eq_sign_ker -> alternatingGroup_eq_sign_ker is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : Fintype.{u1} α] [_inst_2 : DecidableEq.{succ u1} α], Eq.{succ u1} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b)) (MonoidHom.ker.{u1, 0} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α) (Units.{0} Int Int.monoid) (Units.mulOneClass.{0} Int Int.monoid) (Equiv.Perm.sign.{u1} α (fun (a : α) (b : α) => _inst_2 a b) _inst_1))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : Fintype.{u1} α] [_inst_2 : DecidableEq.{succ u1} α], Eq.{succ u1} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b)) (MonoidHom.ker.{u1, 0} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α) (Units.{0} Int Int.instMonoidInt) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt) (Equiv.Perm.sign.{u1} α (fun (a : α) (b : α) => _inst_2 a b) _inst_1))
Case conversion may be inaccurate. Consider using '#align alternating_group_eq_sign_ker alternatingGroup_eq_sign_kerₓ'. -/
theorem alternatingGroup_eq_sign_ker : alternatingGroup α = sign.ker :=
  rfl
#align alternating_group_eq_sign_ker alternatingGroup_eq_sign_ker

namespace Equiv.Perm

/- warning: equiv.perm.mem_alternating_group -> Equiv.Perm.mem_alternatingGroup is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : Fintype.{u1} α] [_inst_2 : DecidableEq.{succ u1} α] {f : Equiv.Perm.{succ u1} α}, Iff (Membership.Mem.{u1, u1} (Equiv.Perm.{succ u1} α) (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (Equiv.Perm.{succ u1} α) (Subgroup.setLike.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))) f (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b))) (Eq.{1} (Units.{0} Int Int.monoid) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, 0} (Equiv.Perm.{succ u1} α) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} α) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} α) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)))) (Units.mulOneClass.{0} Int Int.monoid)) (fun (_x : MonoidHom.{u1, 0} (Equiv.Perm.{succ u1} α) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} α) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} α) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)))) (Units.mulOneClass.{0} Int Int.monoid)) => (Equiv.Perm.{succ u1} α) -> (Units.{0} Int Int.monoid)) (MonoidHom.hasCoeToFun.{u1, 0} (Equiv.Perm.{succ u1} α) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} α) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} α) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)))) (Units.mulOneClass.{0} Int Int.monoid)) (Equiv.Perm.sign.{u1} α (fun (a : α) (b : α) => _inst_2 a b) _inst_1) f) (OfNat.ofNat.{0} (Units.{0} Int Int.monoid) 1 (OfNat.mk.{0} (Units.{0} Int Int.monoid) 1 (One.one.{0} (Units.{0} Int Int.monoid) (MulOneClass.toHasOne.{0} (Units.{0} Int Int.monoid) (Units.mulOneClass.{0} Int Int.monoid))))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : Fintype.{u1} α] [_inst_2 : DecidableEq.{succ u1} α] {f : Equiv.Perm.{succ u1} α}, Iff (Membership.mem.{u1, u1} (Equiv.Perm.{succ u1} α) (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (Equiv.Perm.{succ u1} α) (Subgroup.instSetLikeSubgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))) f (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b))) (Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Equiv.Perm.{succ u1} α) => Units.{0} Int Int.instMonoidInt) f) (FunLike.coe.{succ u1, succ u1, 1} (MonoidHom.{u1, 0} (Equiv.Perm.{succ u1} α) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} α) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} α) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{succ u1} α) (fun (_x : Equiv.Perm.{succ u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Equiv.Perm.{succ u1} α) => Units.{0} Int Int.instMonoidInt) _x) (MulHomClass.toFunLike.{u1, u1, 0} (MonoidHom.{u1, 0} (Equiv.Perm.{succ u1} α) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} α) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} α) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{succ u1} α) (Units.{0} Int Int.instMonoidInt) (MulOneClass.toMul.{u1} (Equiv.Perm.{succ u1} α) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} α) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} α) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))))) (MulOneClass.toMul.{0} (Units.{0} Int Int.instMonoidInt) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (MonoidHomClass.toMulHomClass.{u1, u1, 0} (MonoidHom.{u1, 0} (Equiv.Perm.{succ u1} α) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} α) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} α) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{succ u1} α) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} α) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} α) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt) (MonoidHom.monoidHomClass.{u1, 0} (Equiv.Perm.{succ u1} α) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} α) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} α) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)))) (Equiv.Perm.sign.{u1} α (fun (a : α) (b : α) => _inst_2 a b) _inst_1) f) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Equiv.Perm.{succ u1} α) => Units.{0} Int Int.instMonoidInt) f) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Equiv.Perm.{succ u1} α) => Units.{0} Int Int.instMonoidInt) f) (InvOneClass.toOne.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Equiv.Perm.{succ u1} α) => Units.{0} Int Int.instMonoidInt) f) (DivInvOneMonoid.toInvOneClass.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Equiv.Perm.{succ u1} α) => Units.{0} Int Int.instMonoidInt) f) (DivisionMonoid.toDivInvOneMonoid.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Equiv.Perm.{succ u1} α) => Units.{0} Int Int.instMonoidInt) f) (DivisionCommMonoid.toDivisionMonoid.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Equiv.Perm.{succ u1} α) => Units.{0} Int Int.instMonoidInt) f) (CommGroup.toDivisionCommMonoid.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Equiv.Perm.{succ u1} α) => Units.{0} Int Int.instMonoidInt) f) (Units.instCommGroupUnitsToMonoid.{0} Int Int.instCommMonoidInt)))))))))
Case conversion may be inaccurate. Consider using '#align equiv.perm.mem_alternating_group Equiv.Perm.mem_alternatingGroupₓ'. -/
@[simp]
theorem mem_alternatingGroup {f : Perm α} : f ∈ alternatingGroup α ↔ sign f = 1 :=
  sign.mem_ker
#align equiv.perm.mem_alternating_group Equiv.Perm.mem_alternatingGroup

/- warning: equiv.perm.prod_list_swap_mem_alternating_group_iff_even_length -> Equiv.Perm.prod_list_swap_mem_alternatingGroup_iff_even_length is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : Fintype.{u1} α] [_inst_2 : DecidableEq.{succ u1} α] {l : List.{u1} (Equiv.Perm.{succ u1} α)}, (forall (g : Equiv.Perm.{succ u1} α), (Membership.Mem.{u1, u1} (Equiv.Perm.{succ u1} α) (List.{u1} (Equiv.Perm.{succ u1} α)) (List.hasMem.{u1} (Equiv.Perm.{succ u1} α)) g l) -> (Equiv.Perm.IsSwap.{u1} α (fun (a : α) (b : α) => _inst_2 a b) g)) -> (Iff (Membership.Mem.{u1, u1} (Equiv.Perm.{succ u1} α) (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (Equiv.Perm.{succ u1} α) (Subgroup.setLike.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))) (List.prod.{u1} (Equiv.Perm.{succ u1} α) (MulOneClass.toHasMul.{u1} (Equiv.Perm.{succ u1} α) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} α) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} α) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))))) (MulOneClass.toHasOne.{u1} (Equiv.Perm.{succ u1} α) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} α) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} α) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))))) l) (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b))) (Even.{0} Nat Nat.hasAdd (List.length.{u1} (Equiv.Perm.{succ u1} α) l)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : Fintype.{u1} α] [_inst_2 : DecidableEq.{succ u1} α] {l : List.{u1} (Equiv.Perm.{succ u1} α)}, (forall (g : Equiv.Perm.{succ u1} α), (Membership.mem.{u1, u1} (Equiv.Perm.{succ u1} α) (List.{u1} (Equiv.Perm.{succ u1} α)) (List.instMembershipList.{u1} (Equiv.Perm.{succ u1} α)) g l) -> (Equiv.Perm.IsSwap.{u1} α (fun (a : α) (b : α) => _inst_2 a b) g)) -> (Iff (Membership.mem.{u1, u1} (Equiv.Perm.{succ u1} α) (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (Equiv.Perm.{succ u1} α) (Subgroup.instSetLikeSubgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))) (List.prod.{u1} (Equiv.Perm.{succ u1} α) (MulOneClass.toMul.{u1} (Equiv.Perm.{succ u1} α) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} α) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} α) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))))) (InvOneClass.toOne.{u1} (Equiv.Perm.{succ u1} α) (DivInvOneMonoid.toInvOneClass.{u1} (Equiv.Perm.{succ u1} α) (DivisionMonoid.toDivInvOneMonoid.{u1} (Equiv.Perm.{succ u1} α) (Group.toDivisionMonoid.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))))) l) (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b))) (Even.{0} Nat instAddNat (List.length.{u1} (Equiv.Perm.{succ u1} α) l)))
Case conversion may be inaccurate. Consider using '#align equiv.perm.prod_list_swap_mem_alternating_group_iff_even_length Equiv.Perm.prod_list_swap_mem_alternatingGroup_iff_even_lengthₓ'. -/
theorem prod_list_swap_mem_alternatingGroup_iff_even_length {l : List (Perm α)}
    (hl : ∀ g ∈ l, IsSwap g) : l.Prod ∈ alternatingGroup α ↔ Even l.length :=
  by
  rw [mem_alternating_group, sign_prod_list_swap hl, ← Units.val_eq_one, Units.val_pow_eq_pow_val,
    Units.coe_neg_one, neg_one_pow_eq_one_iff_even]
  decide
#align equiv.perm.prod_list_swap_mem_alternating_group_iff_even_length Equiv.Perm.prod_list_swap_mem_alternatingGroup_iff_even_length

/- warning: equiv.perm.is_three_cycle.mem_alternating_group -> Equiv.Perm.IsThreeCycle.mem_alternatingGroup is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : Fintype.{u1} α] [_inst_2 : DecidableEq.{succ u1} α] {f : Equiv.Perm.{succ u1} α}, (Equiv.Perm.IsThreeCycle.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b) f) -> (Membership.Mem.{u1, u1} (Equiv.Perm.{succ u1} α) (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (Equiv.Perm.{succ u1} α) (Subgroup.setLike.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))) f (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : Fintype.{u1} α] [_inst_2 : DecidableEq.{succ u1} α] {f : Equiv.Perm.{succ u1} α}, (Equiv.Perm.IsThreeCycle.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b) f) -> (Membership.mem.{u1, u1} (Equiv.Perm.{succ u1} α) (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (Equiv.Perm.{succ u1} α) (Subgroup.instSetLikeSubgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))) f (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b)))
Case conversion may be inaccurate. Consider using '#align equiv.perm.is_three_cycle.mem_alternating_group Equiv.Perm.IsThreeCycle.mem_alternatingGroupₓ'. -/
theorem IsThreeCycle.mem_alternatingGroup {f : Perm α} (h : IsThreeCycle f) :
    f ∈ alternatingGroup α :=
  mem_alternatingGroup.2 h.sign
#align equiv.perm.is_three_cycle.mem_alternating_group Equiv.Perm.IsThreeCycle.mem_alternatingGroup

/- warning: equiv.perm.fin_rotate_bit1_mem_alternating_group -> Equiv.Perm.finRotate_bit1_mem_alternatingGroup is a dubious translation:
lean 3 declaration is
  forall {n : Nat}, Membership.Mem.{0, 0} (Equiv.Perm.{1} (Fin (bit1.{0} Nat Nat.hasOne Nat.hasAdd n))) (Subgroup.{0} (Equiv.Perm.{1} (Fin (bit1.{0} Nat Nat.hasOne Nat.hasAdd n))) (Equiv.Perm.permGroup.{0} (Fin (bit1.{0} Nat Nat.hasOne Nat.hasAdd n)))) (SetLike.hasMem.{0, 0} (Subgroup.{0} (Equiv.Perm.{1} (Fin (bit1.{0} Nat Nat.hasOne Nat.hasAdd n))) (Equiv.Perm.permGroup.{0} (Fin (bit1.{0} Nat Nat.hasOne Nat.hasAdd n)))) (Equiv.Perm.{1} (Fin (bit1.{0} Nat Nat.hasOne Nat.hasAdd n))) (Subgroup.setLike.{0} (Equiv.Perm.{1} (Fin (bit1.{0} Nat Nat.hasOne Nat.hasAdd n))) (Equiv.Perm.permGroup.{0} (Fin (bit1.{0} Nat Nat.hasOne Nat.hasAdd n))))) (finRotate (bit1.{0} Nat Nat.hasOne Nat.hasAdd n)) (alternatingGroup.{0} (Fin (bit1.{0} Nat Nat.hasOne Nat.hasAdd n)) (Fin.fintype (bit1.{0} Nat Nat.hasOne Nat.hasAdd n)) (fun (a : Fin (bit1.{0} Nat Nat.hasOne Nat.hasAdd n)) (b : Fin (bit1.{0} Nat Nat.hasOne Nat.hasAdd n)) => Fin.decidableEq (bit1.{0} Nat Nat.hasOne Nat.hasAdd n) a b))
but is expected to have type
  forall {n : Nat}, Membership.mem.{0, 0} (Equiv.Perm.{1} (Fin (bit1.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring) instAddNat n))) (Subgroup.{0} (Equiv.Perm.{1} (Fin (bit1.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring) instAddNat n))) (Equiv.Perm.permGroup.{0} (Fin (bit1.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring) instAddNat n)))) (SetLike.instMembership.{0, 0} (Subgroup.{0} (Equiv.Perm.{1} (Fin (bit1.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring) instAddNat n))) (Equiv.Perm.permGroup.{0} (Fin (bit1.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring) instAddNat n)))) (Equiv.Perm.{1} (Fin (bit1.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring) instAddNat n))) (Subgroup.instSetLikeSubgroup.{0} (Equiv.Perm.{1} (Fin (bit1.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring) instAddNat n))) (Equiv.Perm.permGroup.{0} (Fin (bit1.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring) instAddNat n))))) (finRotate (bit1.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring) instAddNat n)) (alternatingGroup.{0} (Fin (bit1.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring) instAddNat n)) (Fin.fintype (bit1.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring) instAddNat n)) (fun (a : Fin (bit1.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring) instAddNat n)) (b : Fin (bit1.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring) instAddNat n)) => instDecidableEqFin (bit1.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring) instAddNat n) a b))
Case conversion may be inaccurate. Consider using '#align equiv.perm.fin_rotate_bit1_mem_alternating_group Equiv.Perm.finRotate_bit1_mem_alternatingGroupₓ'. -/
theorem finRotate_bit1_mem_alternatingGroup {n : ℕ} :
    finRotate (bit1 n) ∈ alternatingGroup (Fin (bit1 n)) := by
  rw [mem_alternating_group, bit1, sign_finRotate, pow_bit0', Int.units_mul_self, one_pow]
#align equiv.perm.fin_rotate_bit1_mem_alternating_group Equiv.Perm.finRotate_bit1_mem_alternatingGroup

end Equiv.Perm

/- warning: two_mul_card_alternating_group -> two_mul_card_alternatingGroup is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : Fintype.{u1} α] [_inst_2 : DecidableEq.{succ u1} α] [_inst_3 : Nontrivial.{u1} α], Eq.{1} Nat (HMul.hMul.{0, 0, 0} Nat Nat Nat (instHMul.{0} Nat Nat.hasMul) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (Fintype.card.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (Equiv.Perm.{succ u1} α) (Subgroup.setLike.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))) (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b))) (alternatingGroup.fintype.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b)))) (Fintype.card.{u1} (Equiv.Perm.{succ u1} α) (Equiv.fintype.{u1, u1} α α (fun (a : α) (b : α) => _inst_2 a b) (fun (a : α) (b : α) => _inst_2 a b) _inst_1 _inst_1))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : Fintype.{u1} α] [_inst_2 : DecidableEq.{succ u1} α] [_inst_3 : Nontrivial.{u1} α], Eq.{1} Nat (HMul.hMul.{0, 0, 0} Nat Nat Nat (instHMul.{0} Nat instMulNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (Fintype.card.{u1} (Subtype.{succ u1} (Equiv.Perm.{succ u1} α) (fun (x : Equiv.Perm.{succ u1} α) => Membership.mem.{u1, u1} (Equiv.Perm.{succ u1} α) (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (Equiv.Perm.{succ u1} α) (Subgroup.instSetLikeSubgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))) x (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b)))) (fta.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b)))) (Fintype.card.{u1} (Equiv.Perm.{succ u1} α) (equivFintype.{u1, u1} α α (fun (a : α) (b : α) => _inst_2 a b) (fun (a : α) (b : α) => _inst_2 a b) _inst_1 _inst_1))
Case conversion may be inaccurate. Consider using '#align two_mul_card_alternating_group two_mul_card_alternatingGroupₓ'. -/
theorem two_mul_card_alternatingGroup [Nontrivial α] :
    2 * card (alternatingGroup α) = card (Perm α) :=
  by
  let this := (QuotientGroup.quotientKerEquivOfSurjective _ (sign_surjective α)).toEquiv
  rw [← Fintype.card_units_int, ← Fintype.card_congr this]
  exact (Subgroup.card_eq_card_quotient_mul_card_subgroup _).symm
#align two_mul_card_alternating_group two_mul_card_alternatingGroup

namespace alternatingGroup

open Equiv.Perm

#print alternatingGroup.normal /-
instance normal : (alternatingGroup α).Normal :=
  sign.normal_ker
#align alternating_group.normal alternatingGroup.normal
-/

/- warning: alternating_group.is_conj_of -> alternatingGroup.isConj_of is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align alternating_group.is_conj_of alternatingGroup.isConj_ofₓ'. -/
theorem isConj_of {σ τ : alternatingGroup α} (hc : IsConj (σ : Perm α) (τ : Perm α))
    (hσ : (σ : Perm α).support.card + 2 ≤ Fintype.card α) : IsConj σ τ :=
  by
  obtain ⟨σ, hσ⟩ := σ
  obtain ⟨τ, hτ⟩ := τ
  obtain ⟨π, hπ⟩ := isConj_iff.1 hc
  rw [Subtype.coe_mk, Subtype.coe_mk] at hπ
  cases' Int.units_eq_one_or (SignType.sign π) with h h
  · rw [isConj_iff]
    refine' ⟨⟨π, mem_alternating_group.mp h⟩, Subtype.val_injective _⟩
    simpa only [Subtype.val_eq_coe, Subgroup.coe_mul, coe_inv, coe_mk] using hπ
  · have h2 : 2 ≤ σ.supportᶜ.card :=
      by
      rw [Finset.card_compl, le_tsub_iff_left σ.support.card_le_univ]
      exact hσ
    obtain ⟨a, ha, b, hb, ab⟩ := Finset.one_lt_card.1 h2
    refine' isConj_iff.2 ⟨⟨π * swap a b, _⟩, Subtype.val_injective _⟩
    · rw [mem_alternating_group, MonoidHom.map_mul, h, sign_swap ab, Int.units_mul_self]
    · simp only [← hπ, coe_mk, Subgroup.coe_mul, Subtype.val_eq_coe]
      have hd : Disjoint (swap a b) σ :=
        by
        rw [disjoint_iff_disjoint_support, support_swap ab, Finset.disjoint_insert_left,
          Finset.disjoint_singleton_left]
        exact ⟨Finset.mem_compl.1 ha, Finset.mem_compl.1 hb⟩
      rw [mul_assoc π _ σ, hd.commute.eq, coe_inv, coe_mk]
      simp [mul_assoc]
#align alternating_group.is_conj_of alternatingGroup.isConj_of

/- warning: alternating_group.is_three_cycle_is_conj -> alternatingGroup.isThreeCycle_isConj is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align alternating_group.is_three_cycle_is_conj alternatingGroup.isThreeCycle_isConjₓ'. -/
theorem isThreeCycle_isConj (h5 : 5 ≤ Fintype.card α) {σ τ : alternatingGroup α}
    (hσ : IsThreeCycle (σ : Perm α)) (hτ : IsThreeCycle (τ : Perm α)) : IsConj σ τ :=
  alternatingGroup.isConj_of (isConj_iff_cycleType_eq.2 (hσ.trans hτ.symm))
    (by rwa [hσ.card_support])
#align alternating_group.is_three_cycle_is_conj alternatingGroup.isThreeCycle_isConj

end alternatingGroup

namespace Equiv.Perm

open alternatingGroup

#print Equiv.Perm.closure_three_cycles_eq_alternating /-
@[simp]
theorem closure_three_cycles_eq_alternating :
    closure { σ : Perm α | IsThreeCycle σ } = alternatingGroup α :=
  closure_eq_of_le _ (fun σ hσ => mem_alternatingGroup.2 hσ.sign) fun σ hσ =>
    by
    suffices hind :
      ∀ (n : ℕ) (l : List (perm α)) (hl : ∀ g, g ∈ l → is_swap g) (hn : l.length = 2 * n),
        l.Prod ∈ closure { σ : perm α | is_three_cycle σ }
    · obtain ⟨l, rfl, hl⟩ := trunc_swap_factors σ
      obtain ⟨n, hn⟩ := (prod_list_swap_mem_alternating_group_iff_even_length hl).1 hσ
      rw [← two_mul] at hn
      exact hind n l hl hn
    intro n
    induction' n with n ih <;> intro l hl hn
    · simp [List.length_eq_zero.1 hn, one_mem]
    rw [Nat.mul_succ] at hn
    obtain ⟨a, l, rfl⟩ := l.exists_of_length_succ hn
    rw [List.length_cons, Nat.succ_inj'] at hn
    obtain ⟨b, l, rfl⟩ := l.exists_of_length_succ hn
    rw [List.prod_cons, List.prod_cons, ← mul_assoc]
    rw [List.length_cons, Nat.succ_inj'] at hn
    exact
      mul_mem
        (is_swap.mul_mem_closure_three_cycles (hl a (List.mem_cons_self a _))
          (hl b (List.mem_cons_of_mem a (l.mem_cons_self b))))
        (ih _ (fun g hg => hl g (List.mem_cons_of_mem _ (List.mem_cons_of_mem _ hg))) hn)
#align equiv.perm.closure_three_cycles_eq_alternating Equiv.Perm.closure_three_cycles_eq_alternating
-/

/- warning: equiv.perm.is_three_cycle.alternating_normal_closure -> Equiv.Perm.IsThreeCycle.alternating_normalClosure is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : Fintype.{u1} α] [_inst_2 : DecidableEq.{succ u1} α], (LE.le.{0} Nat Nat.hasLe (OfNat.ofNat.{0} Nat 5 (OfNat.mk.{0} Nat 5 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (Fintype.card.{u1} α _inst_1)) -> (forall {f : Equiv.Perm.{succ u1} α} (hf : Equiv.Perm.IsThreeCycle.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b) f), Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (Equiv.Perm.{succ u1} α) (Subgroup.setLike.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))) (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b))) (Subgroup.toGroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α) (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b)))) (Subgroup.normalClosure.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (Equiv.Perm.{succ u1} α) (Subgroup.setLike.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))) (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b))) (Subgroup.toGroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α) (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b))) (Singleton.singleton.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (Equiv.Perm.{succ u1} α) (Subgroup.setLike.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))) (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b))) (Set.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (Equiv.Perm.{succ u1} α) (Subgroup.setLike.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))) (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b)))) (Set.hasSingleton.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (Equiv.Perm.{succ u1} α) (Subgroup.setLike.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))) (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b)))) (Subtype.mk.{succ u1} (Equiv.Perm.{succ u1} α) (fun (x : Equiv.Perm.{succ u1} α) => Membership.Mem.{u1, u1} (Equiv.Perm.{succ u1} α) (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (Equiv.Perm.{succ u1} α) (Subgroup.setLike.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))) x (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b))) f (Equiv.Perm.IsThreeCycle.mem_alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b) f hf)))) (Top.top.{u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (Equiv.Perm.{succ u1} α) (Subgroup.setLike.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))) (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b))) (Subgroup.toGroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α) (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b)))) (Subgroup.hasTop.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (Equiv.Perm.{succ u1} α) (Subgroup.setLike.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))) (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b))) (Subgroup.toGroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α) (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b))))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : Fintype.{u1} α] [_inst_2 : DecidableEq.{succ u1} α], (LE.le.{0} Nat instLENat (OfNat.ofNat.{0} Nat 5 (instOfNatNat 5)) (Fintype.card.{u1} α _inst_1)) -> (forall {f : Equiv.Perm.{succ u1} α} (hf : Equiv.Perm.IsThreeCycle.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b) f), Eq.{succ u1} (Subgroup.{u1} (Subtype.{succ u1} (Equiv.Perm.{succ u1} α) (fun (x : Equiv.Perm.{succ u1} α) => Membership.mem.{u1, u1} (Equiv.Perm.{succ u1} α) (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (Equiv.Perm.{succ u1} α) (Subgroup.instSetLikeSubgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))) x (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b)))) (Subgroup.toGroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α) (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b)))) (Subgroup.normalClosure.{u1} (Subtype.{succ u1} (Equiv.Perm.{succ u1} α) (fun (x : Equiv.Perm.{succ u1} α) => Membership.mem.{u1, u1} (Equiv.Perm.{succ u1} α) (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (Equiv.Perm.{succ u1} α) (Subgroup.instSetLikeSubgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))) x (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b)))) (Subgroup.toGroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α) (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b))) (Singleton.singleton.{u1, u1} (Subtype.{succ u1} (Equiv.Perm.{succ u1} α) (fun (x : Equiv.Perm.{succ u1} α) => Membership.mem.{u1, u1} (Equiv.Perm.{succ u1} α) (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (Equiv.Perm.{succ u1} α) (Subgroup.instSetLikeSubgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))) x (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b)))) (Set.{u1} (Subtype.{succ u1} (Equiv.Perm.{succ u1} α) (fun (x : Equiv.Perm.{succ u1} α) => Membership.mem.{u1, u1} (Equiv.Perm.{succ u1} α) (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (Equiv.Perm.{succ u1} α) (Subgroup.instSetLikeSubgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))) x (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b))))) (Set.instSingletonSet.{u1} (Subtype.{succ u1} (Equiv.Perm.{succ u1} α) (fun (x : Equiv.Perm.{succ u1} α) => Membership.mem.{u1, u1} (Equiv.Perm.{succ u1} α) (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (Equiv.Perm.{succ u1} α) (Subgroup.instSetLikeSubgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))) x (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b))))) (Subtype.mk.{succ u1} (Equiv.Perm.{succ u1} α) (fun (x : Equiv.Perm.{succ u1} α) => Membership.mem.{u1, u1} (Equiv.Perm.{succ u1} α) (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (Equiv.Perm.{succ u1} α) (Subgroup.instSetLikeSubgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))) x (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b))) f (Equiv.Perm.IsThreeCycle.mem_alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b) f hf)))) (Top.top.{u1} (Subgroup.{u1} (Subtype.{succ u1} (Equiv.Perm.{succ u1} α) (fun (x : Equiv.Perm.{succ u1} α) => Membership.mem.{u1, u1} (Equiv.Perm.{succ u1} α) (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (Equiv.Perm.{succ u1} α) (Subgroup.instSetLikeSubgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))) x (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b)))) (Subgroup.toGroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α) (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b)))) (Subgroup.instTopSubgroup.{u1} (Subtype.{succ u1} (Equiv.Perm.{succ u1} α) (fun (x : Equiv.Perm.{succ u1} α) => Membership.mem.{u1, u1} (Equiv.Perm.{succ u1} α) (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (Equiv.Perm.{succ u1} α) (Subgroup.instSetLikeSubgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))) x (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b)))) (Subgroup.toGroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α) (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b))))))
Case conversion may be inaccurate. Consider using '#align equiv.perm.is_three_cycle.alternating_normal_closure Equiv.Perm.IsThreeCycle.alternating_normalClosureₓ'. -/
/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on
  at least 5 elements is the entire alternating group if it contains a 3-cycle. -/
theorem IsThreeCycle.alternating_normalClosure (h5 : 5 ≤ Fintype.card α) {f : Perm α}
    (hf : IsThreeCycle f) :
    normalClosure ({⟨f, hf.mem_alternatingGroup⟩} : Set (alternatingGroup α)) = ⊤ :=
  eq_top_iff.2
    (by
      have hi : Function.Injective (alternatingGroup α).Subtype := Subtype.coe_injective
      refine' eq_top_iff.1 (map_injective hi (le_antisymm (map_mono le_top) _))
      rw [← MonoidHom.range_eq_map, subtype_range, normal_closure, MonoidHom.map_closure]
      refine' (le_of_eq closure_three_cycles_eq_alternating.symm).trans (closure_mono _)
      intro g h
      obtain ⟨c, rfl⟩ := isConj_iff.1 (is_conj_iff_cycle_type_eq.2 (hf.trans h.symm))
      refine' ⟨⟨c * f * c⁻¹, h.mem_alternating_group⟩, _, rfl⟩
      rw [Group.mem_conjugatesOfSet_iff]
      exact ⟨⟨f, hf.mem_alternating_group⟩, Set.mem_singleton _, is_three_cycle_is_conj h5 hf h⟩)
#align equiv.perm.is_three_cycle.alternating_normal_closure Equiv.Perm.IsThreeCycle.alternating_normalClosure

#print Equiv.Perm.isThreeCycle_sq_of_three_mem_cycleType_five /-
/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in
  its cycle decomposition is a 3-cycle, so the normal closure of the original element must be
  $A_5$. -/
theorem isThreeCycle_sq_of_three_mem_cycleType_five {g : Perm (Fin 5)} (h : 3 ∈ cycleType g) :
    IsThreeCycle (g * g) :=
  by
  obtain ⟨c, g', rfl, hd, hc, h3⟩ := mem_cycle_type_iff.1 h
  simp only [mul_assoc]
  rw [hd.commute.eq, ← mul_assoc g']
  suffices hg' : orderOf g' ∣ 2
  · rw [← pow_two, orderOf_dvd_iff_pow_eq_one.1 hg', one_mul]
    exact (card_support_eq_three_iff.1 h3).isThreeCycle_sq
  rw [← lcm_cycle_type, Multiset.lcm_dvd]
  intro n hn
  rw [le_antisymm (two_le_of_mem_cycle_type hn) (le_trans (le_card_support_of_mem_cycle_type hn) _)]
  apply le_of_add_le_add_left
  rw [← hd.card_support_mul, h3]
  exact (c * g').support.card_le_univ
#align equiv.perm.is_three_cycle_sq_of_three_mem_cycle_type_five Equiv.Perm.isThreeCycle_sq_of_three_mem_cycleType_five
-/

end Equiv.Perm

namespace alternatingGroup

open Equiv.Perm

/- warning: alternating_group.nontrivial_of_three_le_card -> alternatingGroup.nontrivial_of_three_le_card is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : Fintype.{u1} α] [_inst_2 : DecidableEq.{succ u1} α], (LE.le.{0} Nat Nat.hasLe (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (Fintype.card.{u1} α _inst_1)) -> (Nontrivial.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (Equiv.Perm.{succ u1} α) (Subgroup.setLike.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))) (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : Fintype.{u1} α] [_inst_2 : DecidableEq.{succ u1} α], (LE.le.{0} Nat instLENat (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3)) (Fintype.card.{u1} α _inst_1)) -> (Nontrivial.{u1} (Subtype.{succ u1} (Equiv.Perm.{succ u1} α) (fun (x : Equiv.Perm.{succ u1} α) => Membership.mem.{u1, u1} (Equiv.Perm.{succ u1} α) (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)) (Equiv.Perm.{succ u1} α) (Subgroup.instSetLikeSubgroup.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))) x (alternatingGroup.{u1} α _inst_1 (fun (a : α) (b : α) => _inst_2 a b)))))
Case conversion may be inaccurate. Consider using '#align alternating_group.nontrivial_of_three_le_card alternatingGroup.nontrivial_of_three_le_cardₓ'. -/
theorem nontrivial_of_three_le_card (h3 : 3 ≤ card α) : Nontrivial (alternatingGroup α) :=
  by
  haveI := Fintype.one_lt_card_iff_nontrivial.1 (lt_trans (by decide) h3)
  rw [← Fintype.one_lt_card_iff_nontrivial]
  refine' lt_of_mul_lt_mul_left _ (le_of_lt nat.prime_two.pos)
  rw [two_mul_card_alternatingGroup, card_perm, ← Nat.succ_le_iff]
  exact le_trans h3 (card α).self_le_factorial
#align alternating_group.nontrivial_of_three_le_card alternatingGroup.nontrivial_of_three_le_card

instance {n : ℕ} : Nontrivial (alternatingGroup (Fin (n + 3))) :=
  nontrivial_of_three_le_card
    (by
      rw [card_fin]
      exact le_add_left (le_refl 3))

/- warning: alternating_group.normal_closure_fin_rotate_five -> alternatingGroup.normalClosure_finRotate_five is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align alternating_group.normal_closure_fin_rotate_five alternatingGroup.normalClosure_finRotate_fiveₓ'. -/
/-- The normal closure of the 5-cycle `fin_rotate 5` within $A_5$ is the whole group. This will be
  used to show that the normal closure of any 5-cycle within $A_5$ is the whole group. -/
theorem normalClosure_finRotate_five :
    normalClosure
        ({⟨finRotate 5, finRotate_bit1_mem_alternatingGroup⟩} : Set (alternatingGroup (Fin 5))) =
      ⊤ :=
  eq_top_iff.2
    (by
      have h3 :
        is_three_cycle (Fin.cycleRange 2 * finRotate 5 * (Fin.cycleRange 2)⁻¹ * (finRotate 5)⁻¹) :=
        card_support_eq_three_iff.1 (by decide)
      rw [← h3.alternating_normal_closure (by rw [card_fin])]
      refine' normal_closure_le_normal _
      rw [Set.singleton_subset_iff, SetLike.mem_coe]
      have h :
        (⟨finRotate 5, fin_rotate_bit1_mem_alternating_group⟩ : alternatingGroup (Fin 5)) ∈
          normal_closure _ :=
        SetLike.mem_coe.1 (subset_normal_closure (Set.mem_singleton _))
      exact
        mul_mem
          (subgroup.normal_closure_normal.conj_mem _ h
            ⟨Fin.cycleRange 2, fin.is_three_cycle_cycle_range_two.mem_alternating_group⟩)
          (inv_mem h))
#align alternating_group.normal_closure_fin_rotate_five alternatingGroup.normalClosure_finRotate_five

/- warning: alternating_group.normal_closure_swap_mul_swap_five -> alternatingGroup.normalClosure_swap_mul_swap_five is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align alternating_group.normal_closure_swap_mul_swap_five alternatingGroup.normalClosure_swap_mul_swap_fiveₓ'. -/
/-- The normal closure of $(04)(13)$ within $A_5$ is the whole group. This will be
  used to show that the normal closure of any permutation of cycle type $(2,2)$ is the whole group.
  -/
theorem normalClosure_swap_mul_swap_five :
    normalClosure
        ({⟨swap 0 4 * swap 1 3, mem_alternatingGroup.2 (by decide)⟩} :
          Set (alternatingGroup (Fin 5))) =
      ⊤ :=
  by
  let g1 := (⟨swap 0 2 * swap 0 1, mem_alternating_group.2 (by decide)⟩ : alternatingGroup (Fin 5))
  let g2 := (⟨swap 0 4 * swap 1 3, mem_alternating_group.2 (by decide)⟩ : alternatingGroup (Fin 5))
  have h5 : g1 * g2 * g1⁻¹ * g2⁻¹ = ⟨finRotate 5, fin_rotate_bit1_mem_alternating_group⟩ :=
    by
    rw [Subtype.ext_iff]
    simp only [Fin.val_mk, Subgroup.coe_mul, Subgroup.coe_inv, Fin.val_mk]
    decide
  rw [eq_top_iff, ← normal_closure_fin_rotate_five]
  refine' normal_closure_le_normal _
  rw [Set.singleton_subset_iff, SetLike.mem_coe, ← h5]
  have h : g2 ∈ normal_closure {g2} :=
    SetLike.mem_coe.1 (subset_normal_closure (Set.mem_singleton _))
  exact mul_mem (subgroup.normal_closure_normal.conj_mem _ h g1) (inv_mem h)
#align alternating_group.normal_closure_swap_mul_swap_five alternatingGroup.normalClosure_swap_mul_swap_five

/- warning: alternating_group.is_conj_swap_mul_swap_of_cycle_type_two -> alternatingGroup.isConj_swap_mul_swap_of_cycleType_two is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align alternating_group.is_conj_swap_mul_swap_of_cycle_type_two alternatingGroup.isConj_swap_mul_swap_of_cycleType_twoₓ'. -/
/-- Shows that any non-identity element of $A_5$ whose cycle decomposition consists only of swaps
  is conjugate to $(04)(13)$. This is used to show that the normal closure of such a permutation
  in $A_5$ is $A_5$. -/
theorem isConj_swap_mul_swap_of_cycleType_two {g : Perm (Fin 5)} (ha : g ∈ alternatingGroup (Fin 5))
    (h1 : g ≠ 1) (h2 : ∀ n, n ∈ cycleType (g : Perm (Fin 5)) → n = 2) :
    IsConj (swap 0 4 * swap 1 3) g :=
  by
  have h := g.support.card_le_univ
  rw [← Multiset.eq_replicate_card] at h2
  rw [← sum_cycle_type, h2, Multiset.sum_replicate, smul_eq_mul] at h
  have h : g.cycle_type.card ≤ 3 := le_of_mul_le_mul_right (le_trans h (by decide)) (by decide)
  rw [mem_alternating_group, sign_of_cycle_type, h2] at ha
  norm_num at ha
  rw [pow_add, pow_mul, Int.units_pow_two, one_mul, Units.ext_iff, Units.val_one,
    Units.val_pow_eq_pow_val, Units.coe_neg_one, neg_one_pow_eq_one_iff_even _] at ha
  swap; · decide
  rw [is_conj_iff_cycle_type_eq, h2]
  interval_cases
  · exact (h1 (card_cycle_type_eq_zero.1 h_1)).elim
  · contrapose! ha
    simp [h_1]
  · have h04 : (0 : Fin 5) ≠ 4 := by decide
    have h13 : (1 : Fin 5) ≠ 3 := by decide
    rw [h_1, disjoint.cycle_type, (is_cycle_swap h04).cycleType, (is_cycle_swap h13).cycleType,
      card_support_swap h04, card_support_swap h13]
    · rfl
    · rw [disjoint_iff_disjoint_support, support_swap h04, support_swap h13]
      decide
  · contrapose! ha
    simp [h_1]
#align alternating_group.is_conj_swap_mul_swap_of_cycle_type_two alternatingGroup.isConj_swap_mul_swap_of_cycleType_two

/- warning: alternating_group.is_simple_group_five -> alternatingGroup.isSimpleGroup_five is a dubious translation:
lean 3 declaration is
  IsSimpleGroup.{0} (coeSort.{1, 2} (Subgroup.{0} (Equiv.Perm.{1} (Fin (OfNat.ofNat.{0} Nat 5 (OfNat.mk.{0} Nat 5 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (Equiv.Perm.permGroup.{0} (Fin (OfNat.ofNat.{0} Nat 5 (OfNat.mk.{0} Nat 5 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Type (SetLike.hasCoeToSort.{0, 0} (Subgroup.{0} (Equiv.Perm.{1} (Fin (OfNat.ofNat.{0} Nat 5 (OfNat.mk.{0} Nat 5 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (Equiv.Perm.permGroup.{0} (Fin (OfNat.ofNat.{0} Nat 5 (OfNat.mk.{0} Nat 5 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) (Equiv.Perm.{1} (Fin (OfNat.ofNat.{0} Nat 5 (OfNat.mk.{0} Nat 5 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (Subgroup.setLike.{0} (Equiv.Perm.{1} (Fin (OfNat.ofNat.{0} Nat 5 (OfNat.mk.{0} Nat 5 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (Equiv.Perm.permGroup.{0} (Fin (OfNat.ofNat.{0} Nat 5 (OfNat.mk.{0} Nat 5 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))) (alternatingGroup.{0} (Fin (OfNat.ofNat.{0} Nat 5 (OfNat.mk.{0} Nat 5 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Fin.fintype (OfNat.ofNat.{0} Nat 5 (OfNat.mk.{0} Nat 5 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (fun (a : Fin (OfNat.ofNat.{0} Nat 5 (OfNat.mk.{0} Nat 5 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (b : Fin (OfNat.ofNat.{0} Nat 5 (OfNat.mk.{0} Nat 5 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) => Fin.decidableEq (OfNat.ofNat.{0} Nat 5 (OfNat.mk.{0} Nat 5 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) a b))) (Subgroup.toGroup.{0} (Equiv.Perm.{1} (Fin (OfNat.ofNat.{0} Nat 5 (OfNat.mk.{0} Nat 5 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (Equiv.Perm.permGroup.{0} (Fin (OfNat.ofNat.{0} Nat 5 (OfNat.mk.{0} Nat 5 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (alternatingGroup.{0} (Fin (OfNat.ofNat.{0} Nat 5 (OfNat.mk.{0} Nat 5 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Fin.fintype (OfNat.ofNat.{0} Nat 5 (OfNat.mk.{0} Nat 5 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (fun (a : Fin (OfNat.ofNat.{0} Nat 5 (OfNat.mk.{0} Nat 5 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (b : Fin (OfNat.ofNat.{0} Nat 5 (OfNat.mk.{0} Nat 5 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) => Fin.decidableEq (OfNat.ofNat.{0} Nat 5 (OfNat.mk.{0} Nat 5 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) a b)))
but is expected to have type
  IsSimpleGroup.{0} (Subtype.{1} (Equiv.Perm.{1} (Fin (OfNat.ofNat.{0} Nat 5 (instOfNatNat 5)))) (fun (x : Equiv.Perm.{1} (Fin (OfNat.ofNat.{0} Nat 5 (instOfNatNat 5)))) => Membership.mem.{0, 0} (Equiv.Perm.{1} (Fin (OfNat.ofNat.{0} Nat 5 (instOfNatNat 5)))) (Subgroup.{0} (Equiv.Perm.{1} (Fin (OfNat.ofNat.{0} Nat 5 (instOfNatNat 5)))) (Equiv.Perm.permGroup.{0} (Fin (OfNat.ofNat.{0} Nat 5 (instOfNatNat 5))))) (SetLike.instMembership.{0, 0} (Subgroup.{0} (Equiv.Perm.{1} (Fin (OfNat.ofNat.{0} Nat 5 (instOfNatNat 5)))) (Equiv.Perm.permGroup.{0} (Fin (OfNat.ofNat.{0} Nat 5 (instOfNatNat 5))))) (Equiv.Perm.{1} (Fin (OfNat.ofNat.{0} Nat 5 (instOfNatNat 5)))) (Subgroup.instSetLikeSubgroup.{0} (Equiv.Perm.{1} (Fin (OfNat.ofNat.{0} Nat 5 (instOfNatNat 5)))) (Equiv.Perm.permGroup.{0} (Fin (OfNat.ofNat.{0} Nat 5 (instOfNatNat 5)))))) x (alternatingGroup.{0} (Fin (OfNat.ofNat.{0} Nat 5 (instOfNatNat 5))) (Fin.fintype (OfNat.ofNat.{0} Nat 5 (instOfNatNat 5))) (fun (a : Fin (OfNat.ofNat.{0} Nat 5 (instOfNatNat 5))) (b : Fin (OfNat.ofNat.{0} Nat 5 (instOfNatNat 5))) => instDecidableEqFin (OfNat.ofNat.{0} Nat 5 (instOfNatNat 5)) a b)))) (Subgroup.toGroup.{0} (Equiv.Perm.{1} (Fin (OfNat.ofNat.{0} Nat 5 (instOfNatNat 5)))) (Equiv.Perm.permGroup.{0} (Fin (OfNat.ofNat.{0} Nat 5 (instOfNatNat 5)))) (alternatingGroup.{0} (Fin (OfNat.ofNat.{0} Nat 5 (instOfNatNat 5))) (Fin.fintype (OfNat.ofNat.{0} Nat 5 (instOfNatNat 5))) (fun (a : Fin (OfNat.ofNat.{0} Nat 5 (instOfNatNat 5))) (b : Fin (OfNat.ofNat.{0} Nat 5 (instOfNatNat 5))) => instDecidableEqFin (OfNat.ofNat.{0} Nat 5 (instOfNatNat 5)) a b)))
Case conversion may be inaccurate. Consider using '#align alternating_group.is_simple_group_five alternatingGroup.isSimpleGroup_fiveₓ'. -/
/-- Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework
  on its cycle type that its normal closure is all of $A_5$.   -/
instance isSimpleGroup_five : IsSimpleGroup (alternatingGroup (Fin 5)) :=
  ⟨exists_pair_ne _, fun H => by
    intro Hn
    refine' or_not.imp id fun Hb => _
    rw [eq_bot_iff_forall] at Hb
    push_neg  at Hb
    obtain ⟨⟨g, gA⟩, gH, g1⟩ : ∃ x : ↥(alternatingGroup (Fin 5)), x ∈ H ∧ x ≠ 1 := Hb
    -- `g` is a non-identity alternating permutation in a normal subgroup `H` of $A_5$.
    rw [← SetLike.mem_coe, ← Set.singleton_subset_iff] at gH
    refine' eq_top_iff.2 (le_trans (ge_of_eq _) (normal_closure_le_normal gH))
    -- It suffices to show that the normal closure of `g` in $A_5$ is $A_5$.
    by_cases h2 : ∀ n ∈ g.cycle_type, n = 2
    · -- If the cycle decomposition of `g` consists entirely of swaps, then the cycle type is $(2,2)$.
      -- This means that it is conjugate to $(04)(13)$, whose normal closure is $A_5$.
      rw [Ne.def, Subtype.ext_iff] at g1
      exact
        (is_conj_swap_mul_swap_of_cycle_type_two gA g1 h2).normalClosure_eq_top_of
          normal_closure_swap_mul_swap_five
    push_neg  at h2
    obtain ⟨n, ng, n2⟩ : ∃ n : ℕ, n ∈ g.cycle_type ∧ n ≠ 2 := h2
    -- `n` is the size of a non-swap cycle in the decomposition of `g`.
    have n2' : 2 < n := lt_of_le_of_ne (two_le_of_mem_cycle_type ng) n2.symm
    have n5 : n ≤ 5 := le_trans _ g.support.card_le_univ
    -- We check that `2 < n ≤ 5`, so that `interval_cases` has a precise range to check.
    swap;
    · obtain ⟨m, hm⟩ := Multiset.exists_cons_of_mem ng
      rw [← sum_cycle_type, hm, Multiset.sum_cons]
      exact le_add_right le_rfl
    interval_cases
    -- This breaks into cases `n = 3`, `n = 4`, `n = 5`.
    · -- If `n = 3`, then `g` has a 3-cycle in its decomposition, so `g^2` is a 3-cycle.
      -- `g^2` is in the normal closure of `g`, so that normal closure must be $A_5$.
      rw [eq_top_iff, ←
        (is_three_cycle_sq_of_three_mem_cycle_type_five ng).alternating_normalClosure
          (by rw [card_fin])]
      refine' normal_closure_le_normal _
      rw [Set.singleton_subset_iff, SetLike.mem_coe]
      have h := SetLike.mem_coe.1 (subset_normal_closure (Set.mem_singleton _))
      exact mul_mem h h
    · -- The case `n = 4` leads to contradiction, as no element of $A_5$ includes a 4-cycle.
      have con := mem_alternating_group.1 gA
      contrapose! con
      rw [sign_of_cycle_type, cycle_type_of_card_le_mem_cycle_type_add_two (by decide) ng]
      decide
    · -- If `n = 5`, then `g` is itself a 5-cycle, conjugate to `fin_rotate 5`.
      refine' (is_conj_iff_cycle_type_eq.2 _).normalClosure_eq_top_of normal_closure_fin_rotate_five
      rw [cycle_type_of_card_le_mem_cycle_type_add_two (by decide) ng, cycleType_finRotate]⟩
#align alternating_group.is_simple_group_five alternatingGroup.isSimpleGroup_five

end alternatingGroup

