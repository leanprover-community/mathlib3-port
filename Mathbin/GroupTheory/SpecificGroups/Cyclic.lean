import Mathbin.Algebra.BigOperators.Order 
import Mathbin.Data.Nat.Totient 
import Mathbin.GroupTheory.OrderOfElement 
import Mathbin.Tactic.Group

/-!
# Cyclic groups

A group `G` is called cyclic if there exists an element `g : G` such that every element of `G` is of
the form `g ^ n` for some `n : ℕ`. This file only deals with the predicate on a group to be cyclic.
For the concrete cyclic group of order `n`, see `data.zmod.basic`.

## Main definitions

* `is_cyclic` is a predicate on a group stating that the group is cyclic.

## Main statements

* `is_cyclic_of_prime_card` proves that a finite group of prime order is cyclic.
* `is_simple_group_of_prime_card`, `is_simple_group.is_cyclic`,
  and `is_simple_group.prime_card` classify finite simple abelian groups.

## Implementation details

This file is currently only available for multiplicatively written groups.

## Tags

cyclic group

## TODO

* Add the attribute `@[to_additive]` to the declarations about `is_cyclic`, so that they work for
  additive groups.
-/


universe u

variable{α : Type u}{a : α}

section Cyclic

open_locale BigOperators

attribute [local instance] setFintype

open Subgroup

/-- A group is called *cyclic* if it is generated by a single element. -/
class IsCyclic(α : Type u)[Groupₓ α] : Prop where 
  exists_generator{} : ∃ g : α, ∀ x, x ∈ zpowers g

instance (priority := 100)is_cyclic_of_subsingleton [Groupₓ α] [Subsingleton α] : IsCyclic α :=
  ⟨⟨1,
      fun x =>
        by 
          rw [Subsingleton.elimₓ x 1]
          exact mem_zpowers 1⟩⟩

/-- A cyclic group is always commutative. This is not an `instance` because often we have a better
proof of `comm_group`. -/
def IsCyclic.commGroup [hg : Groupₓ α] [IsCyclic α] : CommGroupₓ α :=
  { hg with
    mul_comm :=
      fun x y =>
        show (x*y) = y*x from
          let ⟨g, hg⟩ := IsCyclic.exists_generator α 
          let ⟨n, hn⟩ := hg x 
          let ⟨m, hm⟩ := hg y 
          hm ▸ hn ▸ zpow_mul_comm _ _ _ }

variable[Groupₓ α]

theorem MonoidHom.map_cyclic {G : Type _} [Groupₓ G] [h : IsCyclic G] (σ : G →* G) : ∃ m : ℤ, ∀ (g : G), σ g = g ^ m :=
  by 
    obtain ⟨h, hG⟩ := IsCyclic.exists_generator G 
    obtain ⟨m, hm⟩ := hG (σ h)
    use m 
    intro g 
    obtain ⟨n, rfl⟩ := hG g 
    rw [MonoidHom.map_zpow, ←hm, ←zpow_mul, ←zpow_mul']

theorem is_cyclic_of_order_of_eq_card [Fintype α] (x : α) (hx : orderOf x = Fintype.card α) : IsCyclic α :=
  by 
    classical 
    use x 
    simpRw [←SetLike.mem_coe]
    rw [←Set.eq_univ_iff_forall]
    apply Set.eq_of_subset_of_card_le (Set.subset_univ _)
    rw [Fintype.card_congr (Equiv.Set.univ α), ←hx, order_eq_card_zpowers]

-- error in GroupTheory.SpecificGroups.Cyclic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- A finite group of prime order is cyclic. -/
theorem is_cyclic_of_prime_card
{α : Type u}
[group α]
[fintype α]
{p : exprℕ()}
[hp : fact p.prime]
(h : «expr = »(fintype.card α, p)) : is_cyclic α :=
⟨begin
   obtain ["⟨", ident g, ",", ident hg, "⟩", ":", expr «expr∃ , »((g : α), «expr ≠ »(g, 1))],
   from [expr fintype.exists_ne_of_one_lt_card (by { rw [expr h] [], exact [expr hp.1.one_lt] }) 1],
   classical,
   have [] [":", expr «expr ∣ »(fintype.card (subgroup.zpowers g), p)] [],
   { rw ["<-", expr h] [],
     apply [expr card_subgroup_dvd_card] },
   rw [expr nat.dvd_prime hp.1] ["at", ident this],
   cases [expr this] [],
   { rw [expr fintype.card_eq_one_iff] ["at", ident this],
     cases [expr this] ["with", ident t, ident ht],
     suffices [] [":", expr «expr = »(g, 1)],
     { contradiction },
     have [ident hgt] [] [":=", expr ht ⟨g, by { change [expr «expr ∈ »(g, subgroup.zpowers g)] [] [],
         exact [expr subgroup.mem_zpowers g] }⟩],
     rw ["[", "<-", expr ht 1, "]"] ["at", ident hgt],
     change [expr «expr = »((⟨_, _⟩ : subgroup.zpowers g), ⟨_, _⟩)] [] ["at", ident hgt],
     simpa [] [] [] [] [] ["using", expr hgt] },
   { use [expr g],
     intro [ident x],
     rw ["[", "<-", expr h, "]"] ["at", ident this],
     rw [expr subgroup.eq_top_of_card_eq _ this] [],
     exact [expr subgroup.mem_top _] }
 end⟩

theorem order_of_eq_card_of_forall_mem_zpowers [Fintype α] {g : α} (hx : ∀ x, x ∈ zpowers g) :
  orderOf g = Fintype.card α :=
  by 
    classical 
    rw [←Fintype.card_congr (Equiv.Set.univ α), order_eq_card_zpowers]
    simp [hx]
    apply Fintype.card_of_finset' 
    simp 
    intro x 
    exact hx x

instance Bot.is_cyclic {α : Type u} [Groupₓ α] : IsCyclic (⊥ : Subgroup α) :=
  ⟨⟨1, fun x => ⟨0, Subtype.eq$ Eq.symm (Subgroup.mem_bot.1 x.2)⟩⟩⟩

-- error in GroupTheory.SpecificGroups.Cyclic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
instance subgroup.is_cyclic {α : Type u} [group α] [is_cyclic α] (H : subgroup α) : is_cyclic H :=
by haveI [] [] [":=", expr classical.prop_decidable]; exact [expr let ⟨g, hg⟩ := is_cyclic.exists_generator α in
 if hx : «expr∃ , »((x : α), «expr ∧ »(«expr ∈ »(x, H), «expr ≠ »(x, (1 : α)))) then let ⟨x, hx₁, hx₂⟩ := hx in
 let ⟨k, hk⟩ := hg x in
 have hex : «expr∃ , »((n : exprℕ()), «expr ∧ »(«expr < »(0, n), «expr ∈ »(«expr ^ »(g, n), H))), from ⟨k.nat_abs, nat.pos_of_ne_zero (λ
   h, «expr $ »(hx₂, by rw ["[", "<-", expr hk, ",", expr int.eq_zero_of_nat_abs_eq_zero h, ",", expr zpow_zero, "]"] [])), match k, hk with
  | (k : exprℕ()), hk := by rw ["[", expr int.nat_abs_of_nat, ",", "<-", expr zpow_coe_nat, ",", expr hk, "]"] []; exact [expr hx₁]
  | «expr-[1+ ]»(k), hk := by rw ["[", expr int.nat_abs_of_neg_succ_of_nat, ",", "<-", expr subgroup.inv_mem_iff H, "]"] []; simp [] [] [] ["*"] [] ["at", "*"]
  end⟩,
 ⟨⟨⟨«expr ^ »(g, nat.find hex), (nat.find_spec hex).2⟩, λ ⟨x, hx⟩, let ⟨k, hk⟩ := hg x in
   have hk₁ : «expr ∈ »(«expr ^ »(g, «expr * »((nat.find hex : exprℤ()), «expr / »(k, nat.find hex))), zpowers «expr ^ »(g, nat.find hex)), from ⟨«expr / »(k, nat.find hex), by rw ["[", "<-", expr zpow_coe_nat, ",", expr zpow_mul, "]"] []⟩,
   have hk₂ : «expr ∈ »(«expr ^ »(g, «expr * »((nat.find hex : exprℤ()), «expr / »(k, nat.find hex))), H), by { rw [expr zpow_mul] [],
     apply [expr H.zpow_mem],
     exact_mod_cast [expr (nat.find_spec hex).2] },
   have hk₃ : «expr ∈ »(«expr ^ »(g, «expr % »(k, nat.find hex)), H), from «expr $ »((subgroup.mul_mem_cancel_right H hk₂).1, by rw ["[", "<-", expr zpow_add, ",", expr int.mod_add_div, ",", expr hk, "]"] []; exact [expr hx]),
   have hk₄ : «expr = »(«expr % »(k, nat.find hex), «expr % »(k, nat.find hex).nat_abs), by rw [expr int.nat_abs_of_nonneg (int.mod_nonneg _ (int.coe_nat_ne_zero_iff_pos.2 (nat.find_spec hex).1))] [],
   have hk₅ : «expr ∈ »(«expr ^ »(g, «expr % »(k, nat.find hex).nat_abs), H), by rwa ["[", "<-", expr zpow_coe_nat, ",", "<-", expr hk₄, "]"] [],
   have hk₆ : «expr = »(«expr % »(k, (nat.find hex : exprℤ())).nat_abs, 0), from by_contradiction (λ
    h, nat.find_min hex «expr $ »(int.coe_nat_lt.1, by rw ["[", "<-", expr hk₄, "]"] []; exact [expr int.mod_lt_of_pos _ (int.coe_nat_pos.2 (nat.find_spec hex).1)]) ⟨nat.pos_of_ne_zero h, hk₅⟩),
   ⟨«expr / »(k, (nat.find hex : exprℤ())), subtype.ext_iff_val.2 (begin
       suffices [] [":", expr «expr = »(«expr ^ »(g, «expr * »((nat.find hex : exprℤ()), «expr / »(k, nat.find hex))), x)],
       { simpa [] [] [] ["[", expr zpow_mul, "]"] [] [] },
       rw ["[", expr int.mul_div_cancel' (int.dvd_of_mod_eq_zero (int.eq_zero_of_nat_abs_eq_zero hk₆)), ",", expr hk, "]"] []
     end)⟩⟩⟩ else have «expr = »(H, («expr⊥»() : subgroup α)), from «expr $ »(subgroup.ext, λ
  x, ⟨λ
   h, by simp [] [] [] [] [] ["at", "*"]; tauto [], λ
   h, by rw ["[", expr subgroup.mem_bot.1 h, "]"] []; exact [expr H.one_mem]⟩),
 by clear [ident _let_match]; substI [expr this]; apply_instance]

open Finset Nat

section Classical

open_locale Classical

-- error in GroupTheory.SpecificGroups.Cyclic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem is_cyclic.card_pow_eq_one_le
[decidable_eq α]
[fintype α]
[is_cyclic α]
{n : exprℕ()}
(hn0 : «expr < »(0, n)) : «expr ≤ »((univ.filter (λ a : α, «expr = »(«expr ^ »(a, n), 1))).card, n) :=
let ⟨g, hg⟩ := is_cyclic.exists_generator α in
calc
  «expr ≤ »((univ.filter (λ
     a : α, «expr = »(«expr ^ »(a, n), 1))).card, (zpowers «expr ^ »(g, «expr / »(fintype.card α, gcd n (fintype.card α))) : set α).to_finset.card) : card_le_of_subset (λ
   x hx, let ⟨m, hm⟩ := show «expr ∈ »(x, submonoid.powers g), from «expr $ »(mem_powers_iff_mem_zpowers.2, hg x) in
   set.mem_to_finset.2 ⟨(«expr / »(m, «expr / »(fintype.card α, gcd n (fintype.card α))) : exprℕ()), have hgmn : «expr = »(«expr ^ »(g, «expr * »(m, gcd n (fintype.card α))), 1), by rw ["[", expr pow_mul, ",", expr hm, ",", "<-", expr pow_gcd_card_eq_one_iff, "]"] []; exact [expr (mem_filter.1 hx).2],
    begin
      rw ["[", expr zpow_coe_nat, ",", "<-", expr pow_mul, ",", expr nat.mul_div_cancel_left', ",", expr hm, "]"] [],
      refine [expr dvd_of_mul_dvd_mul_right (gcd_pos_of_pos_left (fintype.card α) hn0) _],
      conv [] [] { to_lhs,
        rw ["[", expr nat.div_mul_cancel (gcd_dvd_right _ _), ",", "<-", expr order_of_eq_card_of_forall_mem_zpowers hg, "]"] },
      exact [expr order_of_dvd_of_pow_eq_one hgmn]
    end⟩)
  «expr ≤ »(..., n) : let ⟨m, hm⟩ := gcd_dvd_right n (fintype.card α) in
  have hm0 : «expr < »(0, m), from «expr $ »(nat.pos_of_ne_zero, λ
   hm0, by { rw ["[", expr hm0, ",", expr mul_zero, ",", expr fintype.card_eq_zero_iff, "]"] ["at", ident hm],
     exact [expr hm.elim' 1] }),
  begin
    rw ["[", "<-", expr fintype.card_of_finset' _ (λ
      _, set.mem_to_finset), ",", "<-", expr order_eq_card_zpowers, ",", expr order_of_pow g, ",", expr order_of_eq_card_of_forall_mem_zpowers hg, "]"] [],
    rw ["[", expr hm, "]"] [] { occs := occurrences.pos «expr[ , ]»([2, 3]) },
    rw ["[", expr nat.mul_div_cancel_left _ (gcd_pos_of_pos_left _ hn0), ",", expr gcd_mul_left_left, ",", expr hm, ",", expr nat.mul_div_cancel _ hm0, "]"] [],
    exact [expr le_of_dvd hn0 (gcd_dvd_left _ _)]
  end

end Classical

theorem IsCyclic.exists_monoid_generator [Fintype α] [IsCyclic α] : ∃ x : α, ∀ (y : α), y ∈ Submonoid.powers x :=
  by 
    simpRw [mem_powers_iff_mem_zpowers]
    exact IsCyclic.exists_generator α

section 

variable[DecidableEq α][Fintype α]

theorem IsCyclic.image_range_order_of (ha : ∀ (x : α), x ∈ zpowers a) :
  Finset.image (fun i => a ^ i) (range (orderOf a)) = univ :=
  by 
    simpRw [←SetLike.mem_coe]  at ha 
    simp only [image_range_order_of, set.eq_univ_iff_forall.mpr ha]
    convert Set.to_finset_univ

theorem IsCyclic.image_range_card (ha : ∀ (x : α), x ∈ zpowers a) :
  Finset.image (fun i => a ^ i) (range (Fintype.card α)) = univ :=
  by 
    rw [←order_of_eq_card_of_forall_mem_zpowers ha, IsCyclic.image_range_order_of ha]

end 

section Totient

-- error in GroupTheory.SpecificGroups.Cyclic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
variables
[decidable_eq α]
[fintype α]
(hn : ∀ n : exprℕ(), «expr < »(0, n) → «expr ≤ »((univ.filter (λ a : α, «expr = »(«expr ^ »(a, n), 1))).card, n))

include hn

-- error in GroupTheory.SpecificGroups.Cyclic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem card_pow_eq_one_eq_order_of_aux
(a : α) : «expr = »((finset.univ.filter (λ b : α, «expr = »(«expr ^ »(b, order_of a), 1))).card, order_of a) :=
le_antisymm (hn _ (order_of_pos a)) (calc
   «expr = »(order_of a, @fintype.card (zpowers a) (id _)) : order_eq_card_zpowers
   «expr ≤ »(..., @fintype.card («expr↑ »(univ.filter (λ
      b : α, «expr = »(«expr ^ »(b, order_of a), 1))) : set α) (fintype.of_finset _ (λ
      _, iff.rfl))) : @fintype.card_le_of_injective (zpowers a) («expr↑ »(univ.filter (λ
     b : α, «expr = »(«expr ^ »(b, order_of a), 1))) : set α) (id _) (id _) (λ
    b, ⟨b.1, mem_filter.2 ⟨mem_univ _, let ⟨i, hi⟩ := b.2 in
      by rw ["[", "<-", expr hi, ",", "<-", expr zpow_coe_nat, ",", "<-", expr zpow_mul, ",", expr mul_comm, ",", expr zpow_mul, ",", expr zpow_coe_nat, ",", expr pow_order_of_eq_one, ",", expr one_zpow, "]"] []⟩⟩) (λ
    _ _ h, subtype.eq (subtype.mk.inj h))
   «expr = »(..., (univ.filter (λ b : α, «expr = »(«expr ^ »(b, order_of a), 1))).card) : fintype.card_of_finset _ _)

open_locale Nat

-- error in GroupTheory.SpecificGroups.Cyclic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
private
theorem card_order_of_eq_totient_aux₁ : ∀
{d : exprℕ()}, «expr ∣ »(d, fintype.card α) → «expr < »(0, (univ.filter (λ
   a : α, «expr = »(order_of a, d))).card) → «expr = »((univ.filter (λ
   a : α, «expr = »(order_of a, d))).card, exprφ() d)
| 0 := λ hd hd0, let ⟨a, ha⟩ := card_pos.1 hd0 in
«expr $ »(absurd (mem_filter.1 ha).2, «expr $ »(ne_of_gt, order_of_pos a))
| «expr + »(d, 1) := λ hd hd0, let ⟨a, ha⟩ := card_pos.1 hd0 in
have ha : «expr = »(order_of a, d.succ), from (mem_filter.1 ha).2,
have h : «expr = »(«expr∑ in , »((m), (range d.succ).filter ((«expr ∣ » d.succ)), (univ.filter (λ
    a : α, «expr = »(order_of a, m))).card), «expr∑ in , »((m), (range d.succ).filter ((«expr ∣ » d.succ)), exprφ() m)), from finset.sum_congr rfl (λ
 m hm, have hmd : «expr < »(m, d.succ), from mem_range.1 (mem_filter.1 hm).1,
 have hm : «expr ∣ »(m, d.succ), from (mem_filter.1 hm).2,
 card_order_of_eq_totient_aux₁ (hm.trans hd) (finset.card_pos.2 ⟨«expr ^ »(a, «expr / »(d.succ, m)), mem_filter.2 ⟨mem_univ _, by { rw ["[", expr order_of_pow a, ",", expr ha, ",", expr gcd_eq_right (div_dvd_of_dvd hm), ",", expr nat.div_div_self hm (succ_pos _), "]"] [] }⟩⟩)),
have hinsert : «expr = »(insert d.succ ((range d.succ).filter ((«expr ∣ » d.succ))), (range d.succ.succ).filter ((«expr ∣ » d.succ))), from «expr $ »(finset.ext, λ
 x, ⟨λ
  h, (mem_insert.1 h).elim (λ
   h, by simp [] [] [] ["[", expr h, ",", expr range_succ, "]"] [] []) (by clear [ident _let_match]; simp [] [] [] ["[", expr range_succ, "]"] [] []; tauto []), by clear [ident _let_match]; simp [] [] [] ["[", expr range_succ, "]"] [] [] { contextual := tt }; tauto []⟩),
have hinsert₁ : «expr ∉ »(d.succ, (range d.succ).filter ((«expr ∣ » d.succ))), by simp [] [] [] ["[", expr mem_range, ",", expr zero_le_one, ",", expr le_succ, "]"] [] [],
(add_left_inj «expr∑ in , »((m), (range d.succ).filter ((«expr ∣ » d.succ)), (univ.filter (λ
    a : α, «expr = »(order_of a, m))).card)).1 (calc
   «expr = »(_, «expr∑ in , »((m), insert d.succ (filter ((«expr ∣ » d.succ)) (range d.succ)), (univ.filter (λ
       a : α, «expr = »(order_of a, m))).card)) : eq.symm (finset.sum_insert (by simp [] [] [] ["[", expr mem_range, ",", expr zero_le_one, ",", expr le_succ, "]"] [] []))
   «expr = »(..., «expr∑ in , »((m), (range d.succ.succ).filter ((«expr ∣ » d.succ)), (univ.filter (λ
       a : α, «expr = »(order_of a, m))).card)) : sum_congr hinsert (λ _ _, rfl)
   «expr = »(..., (univ.filter (λ
      a : α, «expr = »(«expr ^ »(a, d.succ), 1))).card) : sum_card_order_of_eq_card_pow_eq_one (succ_pos d)
   «expr = »(..., «expr∑ in , »((m), (range d.succ.succ).filter ((«expr ∣ » d.succ)), exprφ() m)) : «expr ▸ »(ha, «expr ▸ »((card_pow_eq_one_eq_order_of_aux hn a).symm, (sum_totient _).symm))
   «expr = »(..., _) : by rw ["[", expr h, ",", "<-", expr sum_insert hinsert₁, "]"] []; exact [expr finset.sum_congr hinsert.symm (λ
     _ _, rfl)])

-- error in GroupTheory.SpecificGroups.Cyclic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem card_order_of_eq_totient_aux₂
{d : exprℕ()}
(hd : «expr ∣ »(d, fintype.card α)) : «expr = »((univ.filter (λ a : α, «expr = »(order_of a, d))).card, exprφ() d) :=
«expr $ »(by_contradiction, λ
 h, have h0 : «expr = »((univ.filter (λ
    a : α, «expr = »(order_of a, d))).card, 0) := not_not.1 (mt pos_iff_ne_zero.2 (mt (card_order_of_eq_totient_aux₁ hn hd) h)),
 let c := fintype.card α in
 have hc0 : «expr < »(0, c), from fintype.card_pos_iff.2 ⟨1⟩,
 «expr $ »(lt_irrefl c, calc
    «expr = »(c, (univ.filter (λ
       a : α, «expr = »(«expr ^ »(a, c), 1))).card) : «expr $ »(congr_arg card, by simp [] [] [] ["[", expr finset.ext_iff, ",", expr c, "]"] [] [])
    «expr = »(..., «expr∑ in , »((m), (range c.succ).filter ((«expr ∣ » c)), (univ.filter (λ
        a : α, «expr = »(order_of a, m))).card)) : (sum_card_order_of_eq_card_pow_eq_one hc0).symm
    «expr = »(..., «expr∑ in , »((m), ((range c.succ).filter ((«expr ∣ » c))).erase d, (univ.filter (λ
        a : α, «expr = »(order_of a, m))).card)) : eq.symm (sum_subset (erase_subset _ _) (λ
      m hm₁ hm₂, have «expr = »(m, d), by simp [] [] [] [] [] ["at", "*"]; cc,
      by simp [] [] [] ["[", "*", ",", expr finset.ext_iff, "]"] [] ["at", "*"]; exact [expr h0]))
    «expr ≤ »(..., «expr∑ in , »((m), ((range c.succ).filter ((«expr ∣ » c))).erase d, exprφ() m)) : sum_le_sum (λ
     m hm, have hmc : «expr ∣ »(m, c), by simp [] [] [] [] [] ["at", ident hm]; tauto [],
     (imp_iff_not_or.1 (card_order_of_eq_totient_aux₁ hn hmc)).elim (λ
      h, by simp [] [] [] ["[", expr nat.le_zero_iff.1 (le_of_not_gt h), ",", expr nat.zero_le, "]"] [] []) (λ
      h, by rw [expr h] []))
    «expr < »(..., «expr + »(exprφ() d, «expr∑ in , »((m), ((range c.succ).filter ((«expr ∣ » c))).erase d, exprφ() m))) : lt_add_of_pos_left _ (totient_pos (nat.pos_of_ne_zero (λ
       h, pos_iff_ne_zero.1 hc0 «expr $ »(eq_zero_of_zero_dvd, «expr ▸ »(h, hd)))))
    «expr = »(..., «expr∑ in , »((m), insert d (((range c.succ).filter ((«expr ∣ » c))).erase d), exprφ() m)) : eq.symm (sum_insert (by simp [] [] [] [] [] []))
    «expr = »(..., «expr∑ in , »((m), (range c.succ).filter ((«expr ∣ » c)), exprφ() m)) : finset.sum_congr (finset.insert_erase (mem_filter.2 ⟨mem_range.2 (lt_succ_of_le (le_of_dvd hc0 hd)), hd⟩)) (λ
     _ _, rfl)
    «expr = »(..., c) : sum_totient _))

-- error in GroupTheory.SpecificGroups.Cyclic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem is_cyclic_of_card_pow_eq_one_le : is_cyclic α :=
have (univ.filter (λ
  a : α, «expr = »(order_of a, fintype.card α))).nonempty, from «expr $ »(card_pos.1, by rw ["[", expr card_order_of_eq_totient_aux₂ hn dvd_rfl, "]"] []; exact [expr totient_pos (fintype.card_pos_iff.2 ⟨1⟩)]),
let ⟨x, hx⟩ := this in
is_cyclic_of_order_of_eq_card x (finset.mem_filter.1 hx).2

end Totient

-- error in GroupTheory.SpecificGroups.Cyclic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem is_cyclic.card_order_of_eq_totient
[is_cyclic α]
[fintype α]
{d : exprℕ()}
(hd : «expr ∣ »(d, fintype.card α)) : «expr = »((univ.filter (λ a : α, «expr = »(order_of a, d))).card, totient d) :=
begin
  classical,
  apply [expr card_order_of_eq_totient_aux₂ (λ n, is_cyclic.card_pow_eq_one_le) hd]
end

-- error in GroupTheory.SpecificGroups.Cyclic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- A finite group of prime order is simple. -/
theorem is_simple_group_of_prime_card
{α : Type u}
[group α]
[fintype α]
{p : exprℕ()}
[hp : fact p.prime]
(h : «expr = »(fintype.card α, p)) : is_simple_group α :=
⟨begin
   have [ident h'] [] [":=", expr nat.prime.one_lt (fact.out p.prime)],
   rw ["<-", expr h] ["at", ident h'],
   haveI [] [] [":=", expr fintype.one_lt_card_iff_nontrivial.1 h'],
   apply [expr exists_pair_ne α]
 end, λ H Hn, begin
   classical,
   have [ident hcard] [] [":=", expr card_subgroup_dvd_card H],
   rw ["[", expr h, ",", expr dvd_prime (fact.out p.prime), "]"] ["at", ident hcard],
   refine [expr hcard.imp (λ h1, _) (λ hp, _)],
   { haveI [] [] [":=", expr fintype.card_le_one_iff_subsingleton.1 (le_of_eq h1)],
     apply [expr eq_bot_of_subsingleton] },
   { exact [expr eq_top_of_card_eq _ (hp.trans h.symm)] }
 end⟩

end Cyclic

section QuotientCenter

open Subgroup

variable{G : Type _}{H : Type _}[Groupₓ G][Groupₓ H]

/-- A group is commutative if the quotient by the center is cyclic.
  Also see `comm_group_of_cycle_center_quotient` for the `comm_group` instance -/
theorem commutative_of_cyclic_center_quotient [IsCyclic H] (f : G →* H) (hf : f.ker ≤ center G) (a b : G) :
  (a*b) = b*a :=
  let ⟨⟨x, y, (hxy : f y = x)⟩, (hx : ∀ (a : f.range), a ∈ zpowers _)⟩ := IsCyclic.exists_generator f.range 
  let ⟨m, hm⟩ := hx ⟨f a, a, rfl⟩
  let ⟨n, hn⟩ := hx ⟨f b, b, rfl⟩
  have hm : x ^ m = f a :=
    by 
      simpa [Subtype.ext_iff] using hm 
  have hn : x ^ n = f b :=
    by 
      simpa [Subtype.ext_iff] using hn 
  have ha : ((y ^ -m)*a) ∈ center G :=
    hf
      (by 
        rw [f.mem_ker, f.map_mul, f.map_zpow, hxy, zpow_neg, hm, inv_mul_selfₓ])
  have hb : ((y ^ -n)*b) ∈ center G :=
    hf
      (by 
        rw [f.mem_ker, f.map_mul, f.map_zpow, hxy, zpow_neg, hn, inv_mul_selfₓ])
  calc (a*b) = ((y ^ m)*((y ^ -m)*a)*y ^ n)*(y ^ -n)*b :=
    by 
      simp [mul_assocₓ]
    _ = ((y ^ m)*(y ^ n)*(y ^ -m)*a)*(y ^ -n)*b :=
    by 
      rw [mem_center_iff.1 ha]
    _ = (((y ^ m)*y ^ n)*y ^ -m)*a*(y ^ -n)*b :=
    by 
      simp [mul_assocₓ]
    _ = (((y ^ m)*y ^ n)*y ^ -m)*((y ^ -n)*b)*a :=
    by 
      rw [mem_center_iff.1 hb]
    _ = b*a :=
    by 
      group
    

/-- A group is commutative if the quotient by the center is cyclic. -/
def commGroupOfCycleCenterQuotient [IsCyclic H] (f : G →* H) (hf : f.ker ≤ center G) : CommGroupₓ G :=
  { show Groupₓ G by 
      infer_instance with
    mul_comm := commutative_of_cyclic_center_quotient f hf }

end QuotientCenter

namespace IsSimpleGroup

section CommGroupₓ

variable[CommGroupₓ α][IsSimpleGroup α]

-- error in GroupTheory.SpecificGroups.Cyclic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
@[priority 100] instance : is_cyclic α :=
begin
  cases [expr subsingleton_or_nontrivial α] ["with", ident hi, ident hi]; haveI [] [] [":=", expr hi],
  { apply [expr is_cyclic_of_subsingleton] },
  { obtain ["⟨", ident g, ",", ident hg, "⟩", ":=", expr exists_ne (1 : α)],
    refine [expr ⟨⟨g, λ x, _⟩⟩],
    cases [expr is_simple_lattice.eq_bot_or_eq_top (subgroup.zpowers g)] ["with", ident hb, ident ht],
    { exfalso,
      apply [expr hg],
      rw ["[", "<-", expr subgroup.mem_bot, ",", "<-", expr hb, "]"] [],
      apply [expr subgroup.mem_zpowers] },
    { rw [expr ht] [],
      apply [expr subgroup.mem_top] } }
end

-- error in GroupTheory.SpecificGroups.Cyclic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem prime_card [fintype α] : (fintype.card α).prime :=
begin
  have [ident h0] [":", expr «expr < »(0, fintype.card α)] [":=", expr fintype.card_pos_iff.2 (by apply_instance)],
  obtain ["⟨", ident g, ",", ident hg, "⟩", ":=", expr is_cyclic.exists_generator α],
  refine [expr ⟨fintype.one_lt_card_iff_nontrivial.2 infer_instance, λ n hn, _⟩],
  refine [expr (is_simple_lattice.eq_bot_or_eq_top (subgroup.zpowers «expr ^ »(g, n))).symm.imp _ _],
  { intro [ident h],
    have [ident hgo] [] [":=", expr order_of_pow g],
    rw ["[", expr order_of_eq_card_of_forall_mem_zpowers hg, ",", expr nat.gcd_eq_right_iff_dvd.1 hn, ",", expr order_of_eq_card_of_forall_mem_zpowers, ",", expr eq_comm, ",", expr nat.div_eq_iff_eq_mul_left (nat.pos_of_dvd_of_pos hn h0) hn, "]"] ["at", ident hgo],
    { exact [expr (mul_left_cancel₀ (ne_of_gt h0) ((mul_one (fintype.card α)).trans hgo)).symm] },
    { intro [ident x],
      rw [expr h] [],
      exact [expr subgroup.mem_top _] } },
  { intro [ident h],
    apply [expr le_antisymm (nat.le_of_dvd h0 hn)],
    rw ["<-", expr order_of_eq_card_of_forall_mem_zpowers hg] [],
    apply [expr order_of_le_of_pow_eq_one (nat.pos_of_dvd_of_pos hn h0)],
    rw ["[", "<-", expr subgroup.mem_bot, ",", "<-", expr h, "]"] [],
    exact [expr subgroup.mem_zpowers _] }
end

end CommGroupₓ

end IsSimpleGroup

-- error in GroupTheory.SpecificGroups.Cyclic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem comm_group.is_simple_iff_is_cyclic_and_prime_card
[fintype α]
[comm_group α] : «expr ↔ »(is_simple_group α, «expr ∧ »(is_cyclic α, (fintype.card α).prime)) :=
begin
  split,
  { introI [ident h],
    exact [expr ⟨is_simple_group.is_cyclic, is_simple_group.prime_card⟩] },
  { rintro ["⟨", ident hc, ",", ident hp, "⟩"],
    haveI [] [":", expr fact (fintype.card α).prime] [":=", expr ⟨hp⟩],
    exact [expr is_simple_group_of_prime_card rfl] }
end

